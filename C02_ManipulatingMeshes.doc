/* -*- mode: c++; coding: utf-8 -*- */

namespace Life
{
/*! \page ManipulatingMeshes Manipulating Meshes
\ingroup Tutorial

\li \b Previous: \ref CreatingApplications
\li \b Next: \ref ManipulatingFunctionSpaces


In this section, we present some of the mesh definition and
manipulation tools provided by Life.

\section MeshDefinitions Mesh definition

We look at the definition of a mesh data structure. First, we define
the type of geometric entities that we shall use to form our mesh. Life supports

 - simplices: segment, triangle, tetrahedron
 - tensorized entities: segment, quadrangle, hexahedron

We choose between <tt>Simplex<Dim,Order,RealDim></tt>  and
<tt>SimplexProduct<Dim,Order,RealDim></tt>. They have the same
template arguments:
\begin{itemize}
\item <tt>Dim</tt>: the topological dimension of the entity
\item <tt>Order</tt>: the order of the entity(usually 1, higher order in development)
\item <tt>RealDim</tt>: the dimension of the real space
\end{itemize}

\dontinclude mymesh.cpp
\skip marker1
\until endmarker1

Then we define the mesh type, <tt>Mesh<Entity></tt> by passing as
argument the type of entity it is formed with. At the moment hybrid
meshes are not supported.

\skip marker2
\until endmarker2

The next step is to read some mesh files. Life supports only
the Gmsh mesh file format. It provides also some classes to manipulate
Gmsh <tt>.geo</tt> files and generate <tt>.msh</tt> files. To
begin, we use some helper functions to generate a <tt>.geo</tt> file.

 - <tt>createGMSHMesh</tt> allows to generate a mesh <tt>.msh</tt> file
   automatically from a description (e.g. <tt>.geo</tt> file) using the \p _desc
   parameter and store the generated mesh into the \p _mesh parameter allocated
   when calling the funciton

 - <tt>domain</tt> allows to generate \c .geo string description of simple
   domains : simplex and hypercube

Here is an example

\skip marker4
\until endmarker4


The parameter \c _h allows to change the mesh characteristic size to
<tt>M_meshSize</tt> which was given for example on the command line using the
<tt>Application</tt> framework, see this \ref CreatingApplications "section" for
more details.

We get a simplex (line in 1D, triangle in 2D and tetrahedron) geometry and mesh
when executing

\verbatim
life_doc_mymesh --shape="simplex" --nochdir
life_doc_mymesh --shape="hypercube" --nochdir
\endverbatim

generates the following graphics after post-processing with

\verbatim
gmsh mymesh-simplex.pos
gmsh mymesh-hypercube.pos
\endverbatim

\htmlonly <table><tr><td> \endhtmlonly
\image html mymesh-simplex-1.png "Line" width=5cm
\htmlonly </td><td> \endhtmlonly
\image html mymesh-simplex-2.png "Triangle" width=5cm
\htmlonly </td><td> \endhtmlonly
\image html mymesh-simplex-3.png "Tetrahedron" width=5cm
\htmlonly </td></tr></table> \endhtmlonly


\htmlonly <table><tr><td> \endhtmlonly
\image html mymesh-hypercube-1.png "Line" width=5cm
\htmlonly </td><td> \endhtmlonly
\image html mymesh-hypercube-2.png "Unit Square" width=5cm
\htmlonly </td><td> \endhtmlonly
\image html mymesh-hypercube-3.png "Unit Cube" width=5cm
\htmlonly </td></tr></table> \endhtmlonly

Here is the output of the execution

\htmlonly <table><tr><td> \endhtmlonly
Simplex
\include mymesh-simplex.out
\htmlonly </td><td> \endhtmlonly
Hypercube
\include mymesh-hypercube.out
\htmlonly </td></tr></table> \endhtmlonly

\subsection ManipulatingMeshesExport Exporting Meshes for post-processing

At this stage we are ready to use the mesh instance: we can for
example export the mesh to a postprocessing format. Two formats are
supported at the moment

 - <tt>Ensight</tt> (case and sos) which is supported by the
  software Ensight\footnote{\url{http://www.ensight.com}} and
  Paraview\footnote{\url{http://www.paraview.org}}
 - <tt>Gmsh</tt> which is post-processing format of Gmsh

First we define the \c Exporter data structure type

\dontinclude mymesh.cpp
\skip marker61
\until endmarker61

We then call in the code \c Exporter::setMesh() and \c Exporter::save() to save
the mesh to the format given to the command line \c --exporter=<format> (by default it is \c ensight)

\skip marker62
\until endmarker62


\section MeshIterators Iterating over the entities of a mesh Iterating over the entities of a mesh

Life mesh data structures provides powerful iterators that allows to
walk though the mesh in various ways: iterate over element, faces ,
points, marked (associated to an integer flag denoting a
  region, material, processor) elements, marked faces, ...

\li \b Previous: \ref CreatingApplications
\li \b Next: \ref ManipulatingFunctionSpaces
*/
}
/*
In this example, we create a \f$\mathbb{P}_{0}\f$ function space and save the
piecewise constant function that associates to each element the
process id it belongs to. In sequential, they all belong to processor
0.  In a parallel setting, the mesh is partitioned using Metis and
each element is associated with a corresponding processor. The figure
\ref{fig:1} displays a partitioned mesh in two regions and the
associated $\polyP{0}$ function.

\image html mymeshpartition.png "Screenshot of Paraview (3.2.1) of a 2D mesh partitioned and distributed on two processors"
\image latex mymeshpartition.png "Screenshot of Paraview (3.2.1) of a 2D mesh partitioned and distributed on two processors"  width=.7\linewidth
*/
