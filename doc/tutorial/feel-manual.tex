%%\documentclass{../doc/tex/feelstyle}
\documentclass[a4paper]{book}
%\documentclass{article}

\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
%%\usepackage{fullpage}
\usepackage{longtable}

\usepackage{url}
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead[RE,LO]{\leftmark}
\fancyhead[LE,RO]{\thepage}

\usepackage{fancybox}
%\usepackage{fancyvrb}
%\usepackage{color}
\usepackage{xspace}
\usepackage{multicol}
\usepackage{makeidx}
\usepackage{subfigure}
\usepackage{verbatim}

\usepackage[english]{babel}
\usepackage{tabularx}
\usepackage{times}
\usepackage{subfigure}
\usepackage{graphicx}
\graphicspath{%
  {pdfs/}%
  {pngs/}
}
\usepackage{amsmath,amssymb}

\usepackage{xspace}
\usepackage{tikz}
\usetikzlibrary{arrows,patterns,plotmarks,shapes,snakes,er,3d,automata,backgrounds,topaths,trees,petri,mindmap}

%
% les trois parties (front, main et back)
%

\renewcommand\backmatter{%
%  \let\minisommaire\null
  \cleardoublepage
 % \@mainmatterfalse
 % \@frontmatterfalse
  \fancyfoot{}
  \fancyhead[LE]{\bfseries\thepage}
  \fancyhead[RO]{\bfseries\thepage}
  \fancyhead[LO]{\bfseries\rightmark}
  \fancyhead[RE]{\bfseries\leftmark}
 % \renewcommand{\toclevel@chapter}{-1}% pour avoir le bookmark au même niveau
 %                                     % que part
}









%-----------------------------------------------------------------------
% index
\usepackage{index}
%-----------------------------------------------------------------------
%
% espace verticale entre les groupes dans l'index
%
\renewcommand\indexspace{\par \vskip 20pt plus5pt minus3pt\relax}
%-----------------------------------------------------------------------


%-----------------------------------------------------------------------
%
% pour avoir un lien correct dans les bookmark du pdf, sur l'index
%
\let\printindexORIG\printindex
\renewcommand{\printindex}{%
  \cleardoublepage
  \phantomsection% création d'une fausse section
  \addcontentsline{toc}{chapter}{Index}
  \printindexORIG}


\AtBeginDocument{%
  \makeindex%
}

%-----------------------------------------------------------------------


%-----------------------------------------------------------------------
% fancyvrb unixcom environment
\usepackage{styles/fvrb}

%-----------------------------------------------------------------------
% nota environment
\usepackage{styles/nota}
%\newcommand{\ficnota}{attention}
%\newcommand{\ficnota}{}
%\newcommand{\ficnote}{note}
\newcommand{\ficnote}{}
%\newcommand{\ficnotahack}{question}
\newcommand{\ficnotahack}{}

\setlength{\largeurnota}{.8cm}
\newenvironment{nota}{%
  \begin{pictonote}{\ficnota}}{\end{pictonote}}
\newenvironment{note}{%
  \begin{pictonote}{\ficnote}}{\end{pictonote}}
\newenvironment{notahack}{%
  \begin{pictonote}{\ficnotahack}}{\end{pictonote}}


\usepackage{xcolor}
\newtheorem{problem}{Problem}
\newtheorem{remark}{Remark}



\definecolor{lbcolor}{rgb}{0.95,0.95,0.95}
\definecolor{cblue}{rgb}{0.,0.0,0.6}

\usepackage[colorlinks=true]{hyperref}
\usepackage{filecontents,listings}
\lstset{language=c++,showspaces=false,showstringspaces=false,captionpos=t,literate={>>}{\ensuremath{>>}}1,mathescape}
%\lstset{float}
\lstset{basicstyle=\small\ttfamily}
\lstset{lineskip=-2pt}
\lstset{keywordstyle=\color{red}\bfseries}
%\lstset{keywordstyle=\mdseries\color{red}}
\lstset{emph={inline},emphstyle=\color{red}\bfseries}
%\lstset{stringstyle=\ttfamily}
\lstset{commentstyle=\ttfamily\color{cblue}}
\lstset{backgroundcolor=\color{lbcolor},rulecolor=}
%\lstset{numbers=left}
%\lstset{numbers={none}}
%\lstset{numberstyle=\tiny}
%\lstset{numbersep=1pt}
\lstset{frame=single,framerule=0.5pt}
\lstset{belowskip=\smallskipamount}
\lstset{aboveskip=\smallskipamount}
\lstset{emph={constant,cst,cst_ref,constant_ref,val,integrate,on,grad,gradt,gradv,dot,id,dx,dy,dz,idt,dxt,dyt,dzt,div,divt,idv,dxv,dyv,dzv,dn,dnt,mass,stiffness,trans,trace,jump,jumpt,average,averaget,maxface,project,P,Px,Py,Pz,h,H,Hface,hFace,N,Nx,Ny,Nz,sqrt,sin,cos,min,max,abs,sign,pow,chi,exp,log,form1,form2, FunctionSpace, bases,
prod,element_prod, range, subrange, inner_prod,unite,elements,markedelements,markedfaces,boundaryfaces,_Q},emphstyle=\color{blue}}
\lstset{includerangemarker=false,rangeprefix=\/\/\#\ ,% curly left brace plus space
  rangesuffix=\ \#}% space plus curly right brace

\newcommand{\acos}{\ensuremath{\mathrm{acos}}\xspace}
\newcommand{\asin}{\ensuremath{\mathrm{asin}}\xspace}
\newcommand{\atan}{\ensuremath{\mathrm{atan}}\xspace}
%\newcommand{\tanh}{\ensuremath{\mathrm{tanh}}\xspace}
\newcommand{\cc}{{\sl\sffamily C}\xspace}
\newcommand{\cpp}{C{\hspace{-.3em}\vspace{-.2em}\tiny++}\xspace}
\newcommand{\polyP}[1]{\ensuremath{\mathbb{P}_{#1}}\xspace}
\newcommand{\feel}{Feel\xspace}
\newcommand{\cmake}{\texttt{cmake}\xspace}
\newcommand{\ccmake}{\texttt{ccmake}\xspace}


\newcommand{\In}{\operatorname{in}}
\newcommand{\Out}{\operatorname{out}}

\newcommand{\setR}[1]{{\ensuremath{\mathbb{R}^{#1}}}\xspace}
\newcommand{\Om}[1]{{\ensuremath{\Omega^{#1}}}\xspace}
\newcommand{\Omst}{{\ensuremath{\Omega^{\text{st}}}}\xspace}

\newcommand{\aloc}[1]{{\ensuremath{a^{#1}_{\text{loc}}}}\xspace}
\newcommand{\iloc}{{\ensuremath{i_{\text{loc}}}}\xspace}
\newcommand{\jloc}{{\ensuremath{j_{\text{loc}}}}\xspace}
\newcommand{\nldof}{{\ensuremath{N_{\text{localdof}}}}\xspace}
\newcommand{\ngdof}{{\ensuremath{N_{\text{geomdof}}}}\xspace}
\newcommand{\ndof}{{\ensuremath{N_{\text{dof}}}}\xspace}
\newcommand{\nel}{{\ensuremath{N_{\text{el}}}}\xspace}
\newcommand{\PS}[1]{{\ensuremath{\mathbb{P}_N}}\xspace}
\newcommand{\QS}[1]{{\ensuremath{\mathbb{Q}_N}}\xspace}
\newcommand{\GT}[1]{{\ensuremath{\mathcal{T}^{#1}}}\xspace}
\newcommand{\GQ}[1]{{\ensuremath{\mathcal{Q}^{#1}}}\xspace}

%% Macros
\renewcommand{\div}{\operatorname{div}}
\newcommand{\rot}{\operatorname{rot}}

\newcommand{\meter}{\ensuremath{\mathrm{m}}\xspace}

\newcommand{\PP}[1]{{\ensuremath{\mathbb{P}_{#1}}}\xspace}

\newcommand{\pHat}{{\ensuremath{\Hat{p}}}\xspace}
\newcommand{\xHat}{{\ensuremath{\Hat{x}}}\xspace}
\newcommand{\wHat}{{\ensuremath{\Hat{w}}}\xspace}
\newcommand{\THat}{{\ensuremath{\Hat{T}}}\xspace}
\newcommand{\Pk}{\ensuremath{\mathbb{P}_k(K)}\xspace}
\newcommand{\PN}{\ensuremath{\mathbb{P}_N(K)}\xspace}
\newcommand{\Pkmun}{\ensuremath{\mathbb{P}_{k-1}(K)}\xspace}


\InputIfFileExists{version}{}{\def\feelversion{\texttt{x.y.z}}}
\title{Feel Manual\\
A Library for Finite and Spectral Element Methods in 1D, 2D and 3D\\
{\small \feelversion }}
\author{Christophe Prud'homme\thanks{Université de Grenoble,
51, rue des Mathématiques, BP53,38041 Grenoble}}
\date{}

\thispagestyle{empty}
\begin{document}
\thispagestyle{empty}


% \CssFile
% /* css.sty */
% body { width: 75% }
% h1,h2,h3,h4,h5,h6,pre,code,p {font-size: 1em; font-weight: normal; }
% dl,li,dt,dd,h1,h2,h3,h4,h5,h6,pre,form,body,html,p,blockquote,fieldset,input {margin: 0; padding: 0;}
% h2,h3,h4,h5,h6 { color: #B30000; }
% h1 { color: #FFB267; }
% h2 { border-bottom: 1px dotted #FFB267; border-left: 1px dotted #FFB267; }
% h3 { border-bottom: 1px dotted #D95934; }

% div.lstlisting{background: #eee; border: thin solid #000;  }
% div.lstinputlisting{background: #eee; border: thin solid #000; }

% \EndCssFile

%\maketitle

\begin{center}
  {\Large
    FEEL MANUAL\\
    A LIBRARY FOR \\
    FINITE AND SPECTRAL ELEMENT METHODS IN\\
    1D, 2D AND 3D\\
    \bigskip
    {\small Version \feelversion }}\\[0.6cm]
  Christophe \textsc{Prud'homme}\\
  \texttt{christophe.prudhomme@ujf-grenoble.fr}\\
  \par\vspace{2cm}

  % \begin{flushright}
  %   \footnotesize
  %   Version du \feelsvndate\\
  %   Revision \feelsvnrevision
  % \end{flushright}
  % \par\vspace{5cm}

  % \centerline{\begin{minipage}[l]{0.35\linewidth}
  %   \includegraphics[width=.7\linewidth]{logo-ujf}
  % \end{minipage}
  % \begin{minipage}[r]{0.35\linewidth}
  %   \includegraphics[width=.7\linewidth]{logo-ljk}
  % \end{minipage}}


\end{center}

\vfill \mbox{} \clearpage

\thispagestyle{empty}


\vfill
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled "GNU
Free Documentation License".

\newpage

\tableofcontents

\chapter{Building and Programming Environment}


\section{Building Feel}

\subsection{Getting the source via an archive}
\label{sec:getting-source-via-1}

\feel is distributed as a tarball once in a while. The tarballs are available
at
\begin{center}
  \href{http://ljkforge.imag.fr/feel}{http://ljkforge.imag.fr/feel}
\end{center}
Download the latest tarball. Then follow the steps and replace
\texttt{x},\texttt{y},\texttt{z} with the corresponding numbers

\begin{unixcom}
  tar xzf feel-x.y.z.tar.gz
  cd feel-x.y.z
\end{unixcom}


\subsection{Getting the source via Subversion}
\label{sec:getting-source-via}

\paragraph{Creating RSA keys}
\label{sec:creation-rsa-keys}
In order to download the sources of \feel, you have to go in
LJKForge website (https://ljkforge.imag.fr) and create an account. After the
administrator approval, you have to demand the rights to see the project tree.

Then, you will have to create RSA keys to be able to connect to the server
using ssh. To do that you have to type the commands :
\verb|ssh-keygen -t dsa| and \linebreak[2] \verb|ssh-keygen -t rsa| to create
the keys. After that, you have to copy the \verb|id_dsa.pub| and
\verb|id_rsa.pub| files in the My Page > Account Maintenance > Edit SSH Keys
section of the LJKForge website. Those files are located in the \verb|~/.ssh/|
folder of your computer. You will be able to connect to the server within an
hour.
\\
{\bfseries Important : } If you don't have the same login on your computer as on
LJKForge, you must add the commands
\begin{lstlisting}[language=sh]
host ljkforge.imag.fr
  user <your_login_ljkforge>
\end{lstlisting}
in the \verb|~/.ssh/config| file.

\subsubsection{Downloading the sources}
\label{sec:download-sources}

To be able to download the \feel sources, you need subversion and SSH > 1.xxx
installed on your computer. In a command prompt, go where you want \feel to be
downloaded and type the following command.
\\ \verb|svn co svn+ssh://login@ljkforge.imag.fr/svn/feel/feel/trunk feel|
where \\ \verb|login| is your login name in the LJKForge plateform. Then, if
you want to download the feel-test sources type :
\begin{unixcom}
  cd feel/benchmarks
  svn co svn+ssh://login@ljkforge.imag.fr/svn/feel-test/feel-test/trunk validation
\end{unixcom}

\subsection{Dealing with software dependencies}
\label{sec:about-dependencies}

In order to install \feel, you have to install many dependencies
before. Those libraries and programs are necessary for the
compilation and installation of the \feel librairies.

This is the list of all the librairies you must have installed on your
computer, and the \verb|*-dev| packages for some of them.

Here is the list of required packages:
\begin{itemize}
\item g++ (>=4.4)
\item MPI : openmpi (preferred) or mpich
\item Boost (>=1.39)
\item Petsc (>=2.3.3)
\item Cmake (>=2.6)
\item Gmsh\footnote{Gmsh is a pre/post processing software for scientific
computing available at \url{http://www.geuz.org/gmsh}}
\item Libxml2
\end{itemize}

Here is the list of optional packages:
\begin{itemize}
\item Eigen2
\item Superlu
\item Suitesparse(umfpack)
\item Metis: scoth with the metis interface (preferred), metis (non-free)
\item Trilinos (>=8.0.8)
\item Google perftools
\item Paraview\footnote{Paraview is a few parallel scientific data
    visualisation plateform, \url{http://www.paraview.org}}, this is
  not stricly required to run \feel programs but it is somehow
  necessary for visualisation
\item Python (>= 2.5) for the validation tools
\end{itemize}

Note that all these packages are available under Debian/GNU/Linux and
Ubuntu. They should be available

\subsection{Mac OS X installation}
\feel is also working on Mac operating systems. The way to make it work is quiet different.
\subsubsection{Compilers}
In order to \feel and \cmake work properly, you have to install differents compilers :
\begin{itemize}
\item Gcc \newline
The first step is to install the latest version of Xcode. If your computer is recent, you can install it with your DVD that came with your machine (not the OS DVD, but the applications one). You don't have to install the complete Xcode (you can uncheck iOS SDK for example, it's not necessary here and requiers a lot of memory). Xcode will provide your computer all basic tools to compile such as gcc 4.2. It's the first step, you'll see later how to easily install gcc 4.5 using MacPorts.
\item Fortran \newline
To build the Makefiles, \cmake will need a Fortran compiler. To make it works, please go to \href{http://hpc.sourceforge.net/}{SourceForge.net} and download \verb|gfortran-snwleo-intel-bin.tar.gz| which is the fortran compiler only (from now, don't download the complete install with gcc 4.6 because Feel needs gcc 4.5). To install it, go to the directory where you have downloaded the file and type in a command-line : 
\begin{unixcom}
		sudo tar -xvf gfortran-snwleo-intel-bin.tar -C /
\end{unixcom}

\end{itemize}

\subsubsection{MacPorts}

\paragraph{Introduction} 
MacPorts is an open-source community projet which aims to design an easy-to-use system for compiling, installing and upgrading open-source softwares on Mac OS X operating system. It is distributed under \href{http://opensource.org/licenses/bsd-license.php}{BSD License} and facilitate the access to thousands of ports (softwares) without installing or compiling open-source softwares. \newline \newline
MacPorts provides a single software tree which includes the latest stable releases of approximately 8050 ports targeting the current Mac OS X release (10.6 or 10.5). If you want more information, please visite their \href{http://www.macports.org/}{website}.

\paragraph{Installation}
To install the latest version of MacPorts, please go to \href{http://www.macports.org/install.php}{Installing MacPorts} page and follow the instructions. The simplest way is to download the $dmg$ disk image corresponding to your version of Mac OS X. It is recommended that you install X11 (X Window System) which is normally used to display X11 applications.%, and also the Xcode Tools (only the developer tools, iOS SDK is not required). 
\newline \newline
If you have installed with the package installer (\verb|MacPorts-1.x.x.dmg|) that means MacPorts will be installed in \verb|/opt/local|. From now on we will suppose that macports has been installed in \verb|/opt/local| which is the default MacPorts location. %At the end of the installation, you can check if your PATH has been upgraded by the command \verb|echo $PATH| which should return a line containing \verb|/opt/local/bin:/opt/local/sbin|.

\paragraph{Key commands}
In your command-line, the software MacPorts is called by the command \verb|port|. 
Here is a list of key commands for using MacPorts, if you want more informations please go to \href{http://guide.macports.org/#using.port}{MacPorts Commands}.
\begin{itemize}
\item \verb|sudo port -v selfupdate| \newline
	This action should be used regularly to update the local tree with the global MacPorts ports. The option \verb|-v| enables verbose which generates verbose messages.
\item \verb|port info flowd| \newline
	This action is used to get information about a port (description, license, maintainer, etc.)
\item \verb|sudo port install mypackage| \newline
	This action install the port mypackage
\item \verb|sudo port uninstall mypackage| \newline
	This action uninstall the port mypackage
\item \verb|port installed| \newline
	This action displays all ports installed and their versions, variants and activation status. You can also use the \verb|-v| option to also display the platform and CPU architecture(s) for which the ports were built, and any variants which were explicitly negated.
\item \verb|sudo port upgrade mypackage| \newline
	This action updgrades installed ports and their dependencies when a \verb|Portfile| in the repository has been updated. To avoid the upgrade of a port's dependencies, use the option \verb|-n|.
\end{itemize}

\paragraph{Portfile}
A Portfile is a TCL script which usually contains simple keyword values and TCL expressions. Each package/port has a corresponding Portfile but it's only a part of a port description.
Feel++ provides some mandatory Portfiles for its compilation which are either not available in MacPorts or are buggy but Feel++ also provides some Portfiles which are already available in MacPorts such as gmsh or petsc. They usually provide either some fixes to ensure Feel++ works properly or new version not yet available in MacPorts. \newline \newline
These Portfiles are installed in \verb|ports/macosx/macports|.

\subsubsection{MacPorts and Feel}


To be able to install feel++, add the following line in \verb|/opt/local/etc/macports/source.conf|
at the top of the file before any other sources :
\begin{lstlisting}[language=sh]
file:///<path to feel++ top directory>/ports/macosx/macports
\end{lstlisting} 

Once it's done, go to \verb|<path to feel++ top directory>/ports/macosx/macports| and type in a command-line :
\begin{unixcom}
		cd <your path to feel top directory>/ports/macosx/macports 
		portindex
\end{unixcom}

You should have an output like this : 
\begin{flushleft}
\fbox{
   \begin{minipage}{0.81\textwidth}
      	Reading port index in $<$your path to feel top directory$>$/ports/macosx/macports\\
	Adding port science/feel++ \\
	Adding port science/gmsh \\
	Adding port science/petsc \\ \\
	Total number of ports parsed:   3\\
	Ports successfully parsed:      3\\
	Ports failed:                   0\\
	Up-to-date ports skipped:       0
   \end{minipage}
}
\end{flushleft}
Your are now able to type 
\begin{unixcom}
		sudo port install feel++
\end{unixcom}
It might take some time (possibly an entire day) to compile all the requirements for Feel++
to compile properly. If you have several cores on your MacBook Pro, iMac or MacBook
we suggest that you configure macports to use all or some of them.
To do that uncomment the following line in the file \newline \verb|/opt/local/etc/macports/macports.conf|
\begin{flushleft}
\begin{lstlisting}[language=sh]
buildmakejobs	0 $\#$ all the cores
\end{lstlisting} 
\end{flushleft}
At the end of the \verb|sudo port install feel++|, you have all dependencies installed which is a good point. To build all the Makefile, \cmake is automatically launched but can have furthers libraries not found. Some are important, some are not. OpenMP is one of the necessary compiler to have and is not automatically installed on 64bits systems. We can install it now thanks to gcc4.5 that has been installed because it taks part of the feel dependencies. To install it, please go to \href{http://www.hpcs.cs.tsukuba.ac.jp/omni-openmp/download/download-omni.html}{Omni download} and download the latest stable release. Then type
\begin{unixcom}
		tar -xvf Omni-x.yz.tar.gz 
		cd  Omni-x.yz
		./configure --with-cc=/opt/local/bin/gcc-mp-4.5
		make
\end{unixcom}
Then, you have to become a super-user so type
\begin{unixcom}
		sudo su
\end{unixcom}
Enter your password, then to complete the installation 
\begin{unixcom}
		make install
\end{unixcom}
After the install is complete, you can delete the sources in your download directory because make install has built it in an appropriate directory. To make it work properly, always check that \cmake is using gcc 4.5. If \cmake doesn't recognize openMP, enter the configuration mode using \ccmake and enter \verb|-fopenmp| in the box \verb|OpenMP_CXX_FLAGS|

\subsubsection{Issues with slepc or petsc}
We have heard about issues with petsc and slepc with some new MacBook Pro while they are being installed with the \verb|sudo port install feel++|. If it's the case, you should do 
\begin{unixcom}
		cd <path to feel top directory>/ports/macosx/macports
		portindex -f
\end{unixcom}

then type in the exact same order :
\begin{unixcom}
		sudo port uninstall slepc 
		sudo port uninstall petsc
		sudo port install -d petsc
		sudo port install slepc
\end{unixcom}
and type once again
\begin{unixcom}
		sudo port install feel++
\end{unixcom}
%%%% A voir avec Stéphane si ça a bien réussi 

\subsubsection{Missing ports}
\cmake can build Makefiles even if some packages are missing (latex2html, VTK ...). It's not necessary to install them but you can complete the installation with MacPorts, \cmake will find them by itself once they have been installed.

\subsection{Compiling Feel with the CMake}

Feel build system supports
\cmake\index{cmake}\footnote{\url{http://www.cmake.org}}. This should become the
preferred way to build \feel as it is much simpler and more powerful in many
ways than the autotools. Check that \cmake is using gcc4.5 or 4.4 as C++ compiler (you can use the option \verb|CMAKE_CXX_COMPILER=<path>/g++-4.5| where the \verb|path| depends on your OS, it's probably \verb|/usr/bin| or \verb|/opt/local/bin| but you can also change it with the command \verb|ccmake| and press \verb|t| for advanced options). \newline It's important, as \cmake did not produce any Makefile, a CMakeCache.txt won't be created so you'll have to check each time that gcc 4.5 is the C++ compiler to be sure the build will be correct.\newline

\feel, using \cmake, can be built either in source and out of source and different
build type:
\begin{itemize}
\item minsizerel : minimal size release
\item release release
\item debug : debug
\item none(default)
\end{itemize}

\paragraph{CMake In Source Build}

This is not advised, you should consider out source builds, see next paragraph.

Enter the source tree and type
\begin{unixcom}
  cmake .
  make
\end{unixcom}

To customize or change some build setting one can use the \cmake curse interface
\ccmake
\begin{unixcom}
  ccmake . # configure and generate
  make
\end{unixcom}

\paragraph{CMake Out Source Build}

Create a build directory
\begin{unixcom}
  mkdir feel.opt
  cd feel.opt
  cmake <directory where the feel source are>
  # e.g cmake ../feel if feel.opt is at the same
  # directory level as feel
  make
\end{unixcom}

you can customize the build type:
\begin{unixcom}
  # Debug build type (-g...)
  cmake -D CMAKE_BUILD_TYPE=Debug
  # Release build type (-O3...)
  cmake -D CMAKE_BUILD_TYPE=Release
  ...
\end{unixcom}


% \subsection{Compiling Feel with the AutoTools}

% Go in the same folder in wich you have done the checkout and type the following
% commands :

% \subsubsection{From tarball}
% \label{sec:from-tarball}

% The steps are as follows to configure the \feel Development Plateform

% \begin{unixcom}
%   cd feel-x.y.z
%   mkdir opt
%   cd opt

%   ../configure --enable-opt2
% \end{unixcom}

% Then type
% \begin{unixcom}
%   make
% \end{unixcom}

% to compile the library and the tutorial. And finally type
% \begin{unixcom}
%   make check
% \end{unixcom}
% In order to compile the testsuite, the examples and the benchmarks and
% execute some of them to verity that the \feel library is functional.


% \subsubsection{From subversion}
% \label{sec:from-subversion}

% The steps are as follows to configure the \feel Development Plateform

% \begin{unixcom}
%   cd feel
%   make -f Makefile.dist
%   mkdir opt
%   cd opt

%   ../configure --enable-opt2
% \end{unixcom}

% Then, to build  the \feel library, type
% \begin{unixcom}
%   make
% \end{unixcom}

% And finally to check the library, type
% \begin{unixcom}
%   make check
% \end{unixcom}


% \begin{note}
%   The script \lstinline!configure! supports many command line
%   options. In particular if you are interested in writing some code or
%   examples inside the \feel environment you have to enable the so
%   called \emph{maintainer mode} to ensure that the makefiles are
%   properly regenerated when you modify a \lstinline!Makefile.am! or if
%   you modify \lstinline!configure.ac!, to achieve this type
%   \begin{unixcom}
%     configure --enable-maintainer-mode
%   \end{unixcom}
%   To list all configure options, type
%   \begin{unixcom}
%     configure --help
%   \end{unixcom}
% \end{note}


% \subsubsection{Compiling an extra module}
% \label{sec:compile-an-extra}

% If you work with an extra module, \emph{e.g.} \lstinline!validation!, the steps are as follows
% \begin{unixcom}
% cd feel
% make -f Makefile.dist
% cd benchmarks/validation
% make -f Makefile.dist
% cd ../../..
% mkdir opt
% cd opt
% ../feel/configure --enable-opt2 --enable-maintainer-mode
% make
% make check
% \end{unixcom}


\subsubsection{Compiling the Feel tutorial}
\label{sec:comp-feel-tutor}
If the command \lstinline!make check! has been run before the tutorial
should be already compiled and ready. The steps are as follows  to build the Feel tutorial
\begin{unixcom}
  cd opt/doc/tutorial
  make check
\end{unixcom}
Here is what the directory should look like
\begin{unixcom}
  cd opt/doc/tutorial
  ls

  laplacian     Makefile      myintegrals   mymesh       pngs/
  tutorial.blg  tutorial.out  tutorial.toc  laplacian.o  myapp
  myintegrals.o mymesh.o      stokes.assert tutorial.aux pdfs/ styles/
  stokes        stokes.o      tutorial.bbl  tutorial.log tutorial.pdf
\end{unixcom}


\section{Programming environment}

\section{Namepaces}

\begin{itemize}
\item \lstinline!Feel!
\item \lstinline!Feel::po!
\item \lstinline!Feel::mpl!
\item \lstinline!Feel::ublas!
\item \lstinline!Feel::math!
\item \lstinline!Feel::fem!
\item \lstinline!Feel::vf!

\end{itemize}

\section{Libraries}

\begin{itemize}
\item \lstinline!feel/feelcore!
\item \lstinline!feel/feelalg!
\item \lstinline!feel/feelpoly!
\item \lstinline!feel/feeldiscr!
\item \lstinline!feel/feelfilters!
\item \lstinline!feel/feelvf!
\end{itemize}



\chapter{Tutorial}
\label{sec:tutorial}


\section{Creating applications}
\label{sec:creat-appl}


\marginpar{\lstinline!myapp.cpp!}

\subsection{Application and Options}
\label{sec:options}

As a \feel user, the first step in order to use \feel is to create an
application. First we include the \lstinline!Application! header file,
\lstinline!feel/feelcore/application.hpp! and the header which the
internal \feel options. \feel uses the
\lstinline!boost::program_options!\footnote{\url{http://www.boost.org/doc/html/program_options.html}}
library from Boost to handle its command line options


\lstinputlisting[linerange=marker1-endmarker1]{myapp.cpp}

Next to ease the programming and reading, we use the \lstinline!using!
\cpp directive to bring the namespace Feel to the current namespace

\begin{lstlisting}
  using namespace Feel;
\end{lstlisting}

Then we define the command line options that the applications will
provide. Note that on the \lstinline!return! line, we incorporate the
options defined internally in \feel.

\lstinputlisting[linerange=marker2-endmarker2]{myapp.cpp}

In the example, we provide the options \lstinline!dt! which takes an
argument, a \lstinline!double! and its default value is \lstinline!1!
if the options is not set by the command line.

Then we describe the application by defining a class
\lstinline!AboutData! which will be typically used by the
\lstinline!help! command line options to describe the application


\lstinputlisting[linerange=marker3-endmarker3]{myapp.cpp}


Now we turn to the class \lstinline!MyApp! itself: it derives from
\lstinline!Feel::Application!. Two constructors take \lstinline!argc!,
\lstinline!argv! and the \lstinline!AboutData! as well as possibly the
description of the command line options \lstinline!Feel::po::option_description!.

The class \lstinline!MyApp! must redefine the \lstinline!run()! member
function. It is defined as a pure virtual function in
\lstinline!Application!.


\lstinputlisting[linerange=marker4-endmarker4]{myapp.cpp}

The implementation of the constructors is usually simple, we pass the
arguments to the super class \lstinline!Application! that will analyze
them and subsequently provide them with a
\lstinline!Feel::po::variable_map! data structure which operates like
a \lstinline!map!. Have a look at the document
\lstinline!boost::program_options! for further details.

\lstinputlisting[linerange=marker5-endmarker5]{myapp.cpp}

The \lstinline!run()! member function holds the application
commands/statements. Here we provide the smallest code unit: we print
the description of the application if the \lstinline!--help! command
line options is set.

\lstinputlisting[linerange=marker6-endmarker6]{myapp.cpp}

Finally the \lstinline!main()! function can be implemented. We pass
the results of the \lstinline!makeAbout()! and
\lstinline!makeOptions()! to the constructor of \lstinline!MyApp! as
well as \lstinline!argc! and \lstinline!argv!. Then we call the
\lstinline!run()! member function to execute the application.

\lstinputlisting[linerange=marker7-endmarker7]{myapp.cpp}

After compiling \lstinline!myapp!, we can execute it

\begin{lstlisting}[language=sh]
> myapp --help
myapp: my first Feel application
Allowed options:

MyApp options:
  --dt arg (=1)                              time step value

>./myapp --authors
myapp: my first Feel application
          Author Name       Task                          Email Address
-----------------------------------------------------------------------
Christophe Prud'homme   developer  christophe.prudhomme@ujf-grenoble.fr
\end{lstlisting}

\subsection{Application, Logging, Archiving, Configuring}
\label{sec:appl-logg-arch}

\feel provides some basic logging and archiving support: using the
\lstinline!changeRepository! member functions of the class
\lstinline!Application!, the logfile and results of the application
will be stored in a subdirectory of \lstinline!~/feel!. For
example the following code

\lstinputlisting[linerange=marker8-endmarker8]{myapp.cpp}

will create the directory \lstinline!~/feel/myapp! and will store the
logfile and any files created after calling
\lstinline!changeRepository!. Refer to the documentation of
\lstinline!Boost::format! of further details about the arguments to be
passed to \lstinline!changeRepository!. The logfile is named
\lstinline!~/feel/myapp/myapp-1.0!. The name of the logfile is built
using the application name, here \lstinline!myapp!, the number of
processes, here 1 and the id of the current process, here 0.

\begin{lstlisting}[language=sh]
> myapp
> cat ~/feel/myapp/myapp-1.0
myapp-1.0 is opened for debug
[Area 0] the value of dt is 1

> myapp --dt=0.1
> cat ~/feel/myapp/myapp-1.0
myapp-1.0 is opened for debug
[Area 0] the value of dt is 0.1
\end{lstlisting}

\subsubsection{MPI Application}

\marginpar{\lstinline!myapp.cpp!}
\feel relies on MPI for parallel computations and the class
\lstinline!Application!  initialises the MPI environment.

\begin{lstlisting}[language=sh]
> mpirun -np 2 mympiapp
> cat ~/feel/mympiapp/mympiapp-2.0
mympiapp-2.0 is opened for debug
[Area 0] the value of dt is 1
[Area 0] we are on processor eta
[Area 0] this is process number 0 out of 2
> cat ~/feel/mympiapp/mympiapp-2.1
mympiapp-2.1 is opened for debug
[Area 0] the value of dt is 1
[Area 0] we are on processor eta
[Area 0] this is process number 1 out of 2

> mpirun -np 2 mympiapp --dt=0.01
> cat ~/feel/mympiapp/mympiapp-2.0
mympiapp-2.0 is opened for debug
[Area 0] the value of dt is 0.01
[Area 0] we are on processor eta
[Area 0] this is process number 0 out of 2
> cat ~/feel/mympiapp/mympiapp-2.1
mympiapp-2.1 is opened for debug
[Area 0] the value of dt is 0.01
[Area 0] we are on processor eta
[Area 0] this is process number 1 out of 2
\end{lstlisting}

\subsubsection{Configuration files}


Each application can be configured via the command ling but also using a
\verb|.cfg| file. If they exist they may have been installed on your system
along with \feel or you may create your own configuration files.  \feel provides
a way to look for them and parse them.

The \verb|.cfg| file is searched in the following order
\begin{enumerate}
\item look in the current directory
\item look in the directory \verb|$HOME/feel/config/|
\item look in the directory \verb|$INSTALL_PREFIX/share/feel/config/|,
  \emph{e.g.} in\\ Debian \verb|/usr/share/feel/config/|
\end{enumerate}
The name of the file can be constructed in two ways \verb|<appname>.cfg| and
\verb|feel_<appname>.cfg| where \verb|<appname>| is the string given in the
\verb|AboutData| data structure passed to the construction of the
\verb|Application| class.


\subsection{Initializing PETSc and Trilinos}

\index{PETSc}\index{Trilinos}\index{Libraries!PETSc}\index{Libraries!Trilinos}

\feel supports also the PETSc and Trilinos framework, the class
\lstinline!Application!\index{Class!Application} takes care of
initialize the associated environments.

\section{Mesh Manipulation}
\label{sec:mesh-manipulation}

\index{mesh}\index{Class!Mesh}
\marginpar{\lstinline!mymesh.cpp!}
In this section, we present some of the mesh definition and
manipulation tools provided by \feel.

\subsection{Mesh definition}

We look at the definition of a mesh data structure. First, we define
the type of geometric entities that we shall use to form our mesh. \feel supports
\begin{itemize}
\item simplices: segment, triangle, tetrahedron
\item tensorized entities: segment, quadrangle, hexahedron
\end{itemize}

We choose between \lstinline!Simplex<Dim,Order,RealDim>!  and
\lstinline!SimplexProduct<Dim,Order,RealDim>!. They have the same
template arguments:
\begin{itemize}
\item \lstinline!Dim!: the topological dimension of the entity
\item \lstinline!Order!: the order of the entity(usually 1, higher order in development)
\item \lstinline!RealDim!: the dimension of the real space
\end{itemize}


\lstinputlisting[linerange=marker1-endmarker1]{mymesh.cpp}

Then we define the mesh type, \lstinline!Mesh<Entity>! by passing as
argument the type of entity it is formed with. At the moment hybrid
meshes are not supported.

\lstinputlisting[linerange=marker2-endmarker2]{mymesh.cpp}

It is customary, and usually a very good practice, to define the
\lstinline!boost::shared_ptr<>!  counterpart which is used actually in
practice. We can now instantiate a new mesh data structure.

\lstinputlisting[linerange=marker3-endmarker3]{mymesh.cpp}

The next step is to read some mesh files. \feel supports essentially
the Gmsh mesh file format. It provides also some classes to manipulate
Gmsh \lstinline!.geo! files and generate \lstinline!.msh! files. To
begin, we use some helper classes to generate a \lstinline!.geo! file.

\begin{itemize}
\item \lstinline!GmshTensorizedDomain! will allow to create a
  tensorized domain (e.g. cube) in 1D, 2D and 3D. It allows to modify
  \begin{itemize}
  \item the characteristic size of the mesh (by default $h=0.1$)
  \item the domain, by default it is the cube $[0;1]\times[0;1]\times[0;1]$
  \end{itemize}
\item \lstinline!GmshSimplexDomain! will allow to create a simplex
  domain (e.g. segment, triangle or tetrahedron). Again you can modify
  \begin{itemize}
  \item the characteristic size of the mesh (by default $h=0.1$)
  \item the domain vertices, by default $(-1,-1,-1), (1,-1,-1), (-1,1,-1), (-1,-1,1)$
  \end{itemize}
\end{itemize}

Here is an example

\lstinputlisting[linerange=marker4-endmarker4]{mymesh.cpp}

The call to \lstinline!setCharacteristicLength! allows to change the
mesh size to \lstinline!M_meshSize! which was given for example on the
command line using the \lstinline!Application! framework, see
section~\ref{sec:creat-appl}. The call to \lstinline!generate! creates
the \lstinline!.geo! file and generate the associated mesh. Note that
\lstinline!fname! holds the name of the \lstinline!.msh! file,
e.g. \lstinline!mymesh.msh!. \feel adds automatically the
\lstinline!.msh!  extension. Also note the last argument of
\lstinline!GmshTensorizedDomain!, it allows to change the type of
geometric entities used to generate the mesh. Here we use
\lstinline!Simplex!, we could have also used
\lstinline!SimplexProduct! (quadrangle or hexahedron).


Next we import the mesh using the
\lstinline!ImporterGmsh!\index{mesh!import}\index{Class!ImporterGmsh} class as follows:

\lstinputlisting[linerange=marker5-endmarker5]{mymesh.cpp}


At this stage we are ready to use the mesh instance: we can for
example export the mesh to a postprocessing format. Two formats are
supported at the moment
\begin{itemize}
\item \lstinline!Ensight! (case and sos) which is supported by the
  software Ensight\footnote{\url{http://www.ensight.com}} and
  Paraview\footnote{\url{http://www.paraview.org}}
\item \lstinline!Gmsh! which is post-processing format of Gmsh
\end{itemize}

The export stage reads as follows:

\lstinputlisting[linerange=marker6-endmarker6]{mymesh.cpp}

In this example, we create a $\polyP{0}$ function space and save the
piecewise constant function that associates to each element the
process id it belongs to. In sequential, they all belong to processor
0.  In a parallel setting, the mesh is partitioned using Metis and
each element is associated with a corresponding processor. The figure
\ref{fig:1} displays a partitioned mesh in two regions and the
associated $\polyP{0}$ function.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=.7\linewidth]{mymeshpartition}
  \label{fig:1}
  \caption{Screenshot of Paraview (3.2.1) of a 2D mesh partitioned and distributed on two processors}
\end{figure}


\subsection{Iterating over the entities of a mesh}

\feel mesh data structures provides powerful iterators that allows to
walk though the mesh in various ways: iterate over element, faces ,
points, marked\footnote{associated to an integer flag denoting a
  region, material, processor} elements, marked faces, ...



\section{Function Spaces}
\label{sec:function-spaces}

\subsection{Defining function spaces and functions}

\begin{itemize}
\item basis function
\item function spaces
\item element of a function space
\end{itemize}

\subsection{Using functions spaces and functions}

\begin{itemize}
\item interpolating
\item nodal projection
\item saving
\end{itemize}


\section{Linear Algebra}
\label{sec:linear-algebra}


\feel supports three different linear algebra environments that we
shall call \emph{backends}.
\begin{itemize}
\item Gmm\footnote{}
\item Petsc\footnote{}
\item Trilinos\footnote{}
\end{itemize}


\subsection{Choosing a linear algebra backend}
\label{sec:choos-line-algebra}

\index{Class!Backend}\index{boost!shared\_ptr}
To select a backend in order to solve a linear system, we instantiate
the \lstinline!Backend! class associated.

\begin{lstlisting}
#include <feel/feelalg/backend.hpp>
boost::shared_ptr<Backend<double> > backend =
     Backend<double>::build( BACKEND_PETSC );
\end{lstlisting}

The backend provides an interface to solve
\begin{equation}
  \label{eq:8}
  A x = b
\end{equation}
\noindent
where $A$ is a $n \times n $ sparse matrix and $x,b$ vectors of size $n$.
The backend defines the \cpp types for  each of these, e.g.
\begin{lstlisting}
Backend<double>::sparse_matrix_type A;
Backend<double>::vector_type x,b;
\end{lstlisting}
\noindent
In practice, we use the \lstinline!boost::shared_ptr<>! shared pointer
to ensure that we won't get memory leaks. The backends provide a
corresponding \lstinline!typedef!


\begin{lstlisting}
Backend<double>::sparse_matrix_ptrtype A( backend->newMatrix( Xh, Yh ) );
Backend<double>::vector_ptrtype x( backend->newVector( Yh ) );
Backend<double>::vector_ptrtype b( backend->newVector( Xh ) );
\end{lstlisting}
\noindent
where $X_h$ and $Y_h$ are function spaces providing the number of
degrees of freedom that will define the size of the matrix and vectors
thanks to the helpers functions \lstinline!Backend::newMatrix()! and
\lstinline!Backend::newVector!. In a parallel setting, the
local/global processor mapping would be passed down by the function
spaces.

\subsection{Defining and using matrices and vectors}
\label{sec:defin-using-matr}

\subsection{Solving}
\label{sec:solving}


\section{Variational Formulation}
\label{sec:vari-form}

\index{formulation!variational}
\begin{itemize}
\item keywords
\item principles
\end{itemize}

\subsection{Computing integrals}
\label{sec:computing-integrals}

\index{integrals}
\marginpar{\lstinline!myintegrals.cpp!}
We would like to compute some integrals on a domain of $\Omega=[0,1]^d\ \subset\ \mathbb{R}^d$
and parts of the domain, i.e. subregions and (parts of) boundary.

Once we have defined the computational mesh, we would like to compute
the area of the domain. We form the integral $\int_\Omega 1$, the code
reads as follows

\lstinputlisting[linerange=marker1-endmarker1]{myintegrals.cpp}

\lstinline!elements(mesh)! returns a pair of iterators over the
elements owned by the current processor, \lstinline!im! is an instance
of the \lstinline!im_type! which provides a quadrature method to
integrate exactly polynomials up to degree 2. In our case integrating
constant(degree 0) would have sufficed, but we will reuse
\lstinline!im! later. Now that we have computed the integral of 1 over
the region of $\Omega$ current processor (ie the area of the domain
owned by the processor), we want to compute the area of $\Omega$. To
do that we collect the integrals on all processors using a
\lstinline!reduce! MPI operation and sum all contributions. We have
used here the Boost.MPI library that provides an extremely powerful
\cpp wrapper around the MPI library. The code reads

\lstinputlisting[linerange=marker2-endmarker2]{myintegrals.cpp}

\noindent
Finally, we print to the log file the result of the local and global
integral calculation. Another calculation is for example to compute
the perimeter of the domain

\lstinputlisting[linerange=marker3-endmarker3]{myintegrals.cpp}

\noindent
the main difference with the domain area computation resides in the
elements with are iterating on: here we are iterating on the boundary
faces of the domain to compute the integral using
\lstinline!boundaryfaces(mesh)! to provide the pairs of iterators.


Now say that we want to compute
\begin{equation}
  \label{eq:5}
  \int_\Omega x^2 + y^2 dx dy.
\end{equation}
The Finite Element Embedded Language (FEEL++) language provides the
keyword \lstinline!Px()! and \lstinline!Py()! to denote the $x$ and
$y$ coordinates like in equation~(\ref{eq:5}).  The code reads then


\lstinputlisting[linerange=marker4-endmarker4]{myintegrals.cpp}

Note that in this case, we really require the use of a quadrature that
integrates exactly order 2 polynomials.

Let's run now the tutrial example \lstinline!myintegrals!. The results are stored
in the log file under \lstinline!~/feel/myintegrals/!.

\begin{lstlisting}{language=sh}
> cat ~/feel/myintegrals/Simplex_2_1/h_0.5/myintegrals-1.0
myintegrals-1.0 is opened for debug
[Area 0] int_Omega = 1[ 1 ]
[Area 0] int_Omega = 4[ 4 ]
[Area 0] int_Omega = 0.666667[ 0.666667 ]
\end{lstlisting}

We remark that the results are exact. Integrating higher order
polynomials ($\geq 3$) or non-polynomial function would typically
require higher order quadrature to get accurate results. To do that
increase \lstinline!imOrder! in the example and try integrating
$f(x,y)=x^3 + x y^2$.


In order to see what happens in parallel, use \lstinline!mpirun! to
launch \lstinline!myintegrals! on several processors, for example

\begin{lstlisting}{language=sh}
> mpirun -np 4 myintegrals --hsize=0.1
> cat ~/feel/myintegrals/Simplex_2_1/h_0.1/myintegrals-4.0
myintegrals-4.0 is opened for debug
[Area 0] int_Omega = 1[ 0.253348 ]
[Area 0] int_Omega = 4[ 1.44444 ]
[Area 0] int_Omega = 0.666667[ 0.0701812 ]
> cat ~/feel/myintegrals/Simplex_2_1/h_0.1/myintegrals-4.1
myintegrals-4.1 is opened for debug
[Area 0] int_Omega = 1[ 0.288919 ]
[Area 0] int_Omega = 4[ 0.444444 ]
[Area 0] int_Omega = 0.666667[ 0.186251 ]
> cat ~/feel/myintegrals/Simplex_2_1/h_0.1/myintegrals-4.2
myintegrals-4.2 is opened for debug
[Area 0] int_Omega = 1[ 0.183219 ]
[Area 0] int_Omega = 4[ 1.11111 ]
[Area 0] int_Omega = 0.666667[ 0.105008 ]
> cat ~/feel/myintegrals/Simplex_2_1/h_0.1/myintegrals-4.3
myintegrals-4.3 is opened for debug
[Area 0] int_Omega = 1[ 0.274514 ]
[Area 0] int_Omega = 4[ 1 ]
[Area 0] int_Omega = 0.666667[ 0.305227 ]
\end{lstlisting}

\subsection{Standard formulation: the Laplacian case}
\label{sec:defin-bilin-forms}
\index{laplacian}
\subsubsection{Mathematical formulation}
\label{sec:math-form-3}
\index{laplacian!formulation!mathematical}
\marginpar{\lstinline!laplacian.cpp!}
In this example, we would like to solve for the following problem in 2D
\begin{problem}
\label{prob:1}
 find $u$ such that
\begin{equation}
  \label{eq:1}
  -\Delta u = f\ \text{in}\ \Omega = [-1;1]^2
\end{equation}
with
\begin{equation}
  \label{eq:2}
  f= 2 \pi^2  g
\end{equation}
and $g$ is the exact solution
\begin{equation}
  \label{eq:3}
  g=\sin(\pi x) \cos(\pi y)
\end{equation}
The following boundary conditions apply
\begin{equation}
  \label{eq:4}
  u=g_{|x=\pm 1}, \quad \frac{\partial u}{\partial n} = 0_{|y=\pm 1}
\end{equation}
\end{problem}

We propose here two possible variational formulations. The first one,
handles the Dirichlet boundary conditions strongly, that is to say the
condition is \emph{incorporated} into the function space definitions.
The second one handles the Dirichlet condition \emph{weakly} and hence
we have a uniform treatment for all types of boundary conditions.



\paragraph{Strong Dirichlet conditions}
\label{sec:strong-dirichl-cond}

\noindent
The variational formulation reads as follows, we introduce the spaces
\begin{equation}
  \label{eq:11}
  \mathcal{X} = \Big\{ v \in H_1(\Omega) \text{ such that } v=g_{|x=-1,x=1} \Big\}
\end{equation}
and
\begin{equation}
  \label{eq:12}
  \mathcal{V} = \Big\{ v \in H_1(\Omega) \text{ such that } v=0_{|x=-1,x=1} \Big\}
\end{equation}
We multiply (\ref{eq:1}) by $v \in \mathcal{V}$ then integrate over $\Omega$ and obtain
\begin{equation}
  \label{eq:13}
  \int_\Omega -\Delta u v = \int_\Omega f v
\end{equation}
We integrate by parts and reformulate the problem as follows:
\begin{problem}
we look
for $u \in \mathcal{X}$ such that for all $v \in \mathcal{V}$
\begin{equation}
  \label{eq:14}
  \int_\Omega \nabla u \cdot \nabla v  = \int_\Omega f v
\end{equation}

\end{problem}
In the present space setting~(\ref{eq:12}) and boundary
conditions~(\ref{eq:4}), we have the boundary term from the integration by
parts which is dropped being equal to 0
\begin{equation}
  \label{eq:15}
  \int_{\partial \Omega} \frac{\partial u}{\partial n} v = 0,
\end{equation}
recalling that
\begin{equation}
  \label{eq:21}
  \frac{\partial u}{\partial n} \stackrel{\text{def}}{=} \nabla u \cdot n
\end{equation}
where $n$ is the outward normal to $\partial \Omega$ by convention.We
now discretize the problem, we create a mesh out of $\Omega$, we have
\begin{equation}
  \label{eq:10}
  \Omega = \cup_{e=1}^\nel \Omega^e
\end{equation}
where $\Omega^e$ can be segments, triangles or tetrahedra depending on
$d$ and we have $\nel$ of them. We introduce the finite dimensional
spaces of continuous piecewise polynomial of degree $N$ functions
\begin{equation}
  \label{eq:17}
  X_h = \Big\{ v_h  \in C^0(\Omega),\ {v_h}_{|\Omega^e} \in \mathbb{P}_N( \Omega^e ),\   v_h=g_{|x=-1,x=1}\Big\}
\end{equation}
and
\begin{equation}
  \label{eq:18}
  V_h = \Big\{ v_h \in C^0(\Omega),\ {v_h}_{|\Omega^e} \in \mathbb{P}_N( \Omega^e ),\   v_h=0_{|x=-1,x=1}\Big\}
\end{equation}
which are out trial and test function spaces respectively.  We now
have the problem we seek to solve which reads in our continuous
Galerkin framework
\begin{problem}
  \label{prob:2}
  we look for $u_h \in X_h \subset \mathcal{X}$ such that for all $v
  \in V_h \subset \mathcal{V}$
  \begin{equation}
    \label{eq:20}
    \int_\Omega \nabla u_h \cdot \nabla v_h  = \int_\Omega f v_h
  \end{equation}
\end{problem}

\paragraph{Weak Dirichlet conditions}
\label{sec:weak-dirichl-cond}

There is an alternative formulation which allows to treat weakly
Dirichlet(Essential) boundary conditions similarly to Neumann(Natural)
and Robin conditions. Following a similar development as in the previous section, the problem reads
\begin{problem}
  \label{prob:3}
  we look for $u \in X_h \subset H_1(\Omega)$ such that for all $v \in
  X_h$
\begin{equation}
  \label{eq:16}
  \int_\Omega \nabla u \cdot \nabla v +
  \int_{|x=-1,x=1} -\frac{\partial u}{\partial n} v - u \frac{\partial v}{\partial n} + \frac{\mu}{h} u v
  =
  \int_\Omega f v +
  \int_{|x=-1,x=1}  - g \frac{\partial v}{\partial n} + \frac{\mu}{h} g v
\end{equation}
where
\begin{equation}
  \label{eq:19}
  X_h = \Big\{ v_h \in C^0(\Omega),\ {v_h}_{|\Omega^e} \in \mathbb{P}_N( \Omega^e ) \Big\}
\end{equation}
\end{problem}
In (\ref{eq:16}), $g$ is defined by (\ref{eq:3}). $\mu$ serves as a penalisation
parameter which should be $> 0$, e.g. between 2 and 10, and $h$ is the
size of the face. The inconvenient of this formulation is the
introduction of the parameter $\mu$, but the advantage is the
\emph{weak} treatment of the Dirichlet condition.

\subsubsection{Feel formulation}
\label{sec:feel-formulation-1}

\index{laplacian!formulation!feel}
First we define the $f$ and $g$. To do that we use the
\lstinline!AUTO! keyword and associate to \lstinline!f! and
\lstinline!g! their expressions

\lstinputlisting[linerange=marker1-endmarker1]{laplacian.cpp}

\noindent where \lstinline!M_PI! is defined in the header
\lstinline!cmath!.  Using \lstinline!AUTO! allows to defined
\lstinline!f!  and \lstinline!g! --- which are moderately complex
object --- without having to know the actual type. \lstinline!AUTO!
determines automatically the type of the expression using the
\lstinline!__typeof__! keyword internally.

Then we form the right hand side by defining a linear form whose
algebraic representation will be stored in a
\lstinline!vector_ptrtype! which is provided by the chosen linear
algebra backend. The linear form is equated with an integral
expression defining our right hand side.

\lstinputlisting[linerange=marker2-endmarker2]{laplacian.cpp}

\noindent \lstinline!form1! generates an instance of the object
representing linear forms, that is to say it mimics the mathematical
object $\ell$ such that
\begin{equation}
  \label{eq:9}
  \begin{array}{rccl}
    \ell: & X_h & \mapsto & \mathbb{R}\\
    & v_h & \rightarrow &\ell(v_h)=\int_\Omega f v
  \end{array}
\end{equation}
which is represented algebraically in the code by the vector
\lstinline!F! using the argument \lstinline!_vector!. The last
argument \lstinline!_init!, if set to \lstinline!true!\footnote{It is
  set to \lstinline!false! by default.}, will zero-out the entries of
the vector \lstinline!F!.


We now turn to the left hand side and define the bilinear form using
the \lstinline!form2! helper function which is passed \textit{(i)} the
trial function space using the \lstinline!_trial! option,
\textit{(ii)} the test function space using the \lstinline!_test!
option, \textit{(iii)} the algebraic representation using
\lstinline!_matrix!, i.e. a sparse matrix whose type is derived from
one of the linear algebra backends and \textit{(iv)} whether the
associated matrix should initialized using
\lstinline!_init!.


\lstinputlisting[linerange=marker3-endmarker3]{laplacian.cpp}


Finally, we deal with the boundary condition, we implement both
formulation described in appendix~\ref{sec:vari-form-1}. For a
\emph{strong} treatment of the Dirichlet condition, we use the
\lstinline!on()! keyword of FEEL++ as follows

\lstinputlisting[linerange=marker5-endmarker5]{laplacian.cpp}

Notice that we add, using \lstinline!+=!, the Dirichlet contribution
for the bilinear form. The first argument is the set of boundary faces
to apply the condition: in gmsh the points satisfying $x=\pm 1$ are
marked using the flags $1$ and $3$ ($x=-1$ and $x=1$ respectively.)

To implement the weak Dirichlet boundary condition, we add the
following contributions to the left and right hand side:

\lstinputlisting[linerange=marker41-endmarker41]{laplacian.cpp}
\lstinputlisting[linerange=marker4-endmarker4]{laplacian.cpp}

Note that we use the command line option \lstinline!--weakdir! set to
1 by default to decide between weak/strong Dirichlet handling.  Apart
the uniform treatment of boundary conditions, the weak Dirichlet
formulation has the advantage to work also in a parallel environment.

Next we solve the linear system
\begin{equation}
  \label{eq:6}
  D u = F
\end{equation}

where the \lstinline!solve! function is implemented as follows

\lstinputlisting[linerange=marker6-endmarker6]{laplacian.cpp}

Finally we check for the $L_2$ error in our approximation by computing
\begin{equation}
  \label{eq:7}
  \|u-u_h\|_{L_2}\ =\ \sqrt{\int_\Omega (u-u_h)^2} = \sqrt{\int_\Omega (g-u_h)^2}
\end{equation}
where $u$ is the exact solution and is equal to $g$ and $u_h$ is the
numerical solution of the problem~(\ref{eq:1}) and the components of
$u_h$ in the $P_2$ Lagrange basis are given by solving (\ref{eq:6}).

The code reads

\lstinputlisting[linerange=marker7-endmarker7]{laplacian.cpp}


You can now verify that the $L_2$ error norm behaves like $h^{-(N+1)}$
where $h$ is the mesh size and $N$ the polynomial order. The $H_1$
error norm would be checked similarly in $h^{-N}$. The
figure~\ref{fig:2} displays the results using Paraview.

\begin{figure}[htbp]
  \centering
  \subfigure[Colored with $u$]{\includegraphics[width=.43\linewidth]{laplacian.png}}
  \subfigure[Elevation]{\includegraphics[width=.43\linewidth]{laplacian_warp.png}}
  \caption{Solution of problem~\ref{prob:3}}
  \label{fig:2}
\end{figure}

\subsection{Mixed formulation: the Stokes case}
\label{sec:mixed-form-stok}
\index{Stokes}
\subsubsection{Mathematical formulation}
\label{sec:math-form}

\index{Stokes!formulation!mathematical}
\marginpar{\lstinline!stokes.cpp!}  We are now interested in solving
the Stokes equations, we would like to solve for the following problem
in 2D
\begin{problem}
\label{prob:4}
 find $(\mathbf{u},p)$ such that
\begin{equation}
  \label{eq:22}
  - \mu \Delta \mathbf{u} +\nabla p = \mathbf{f}\quad \text{and}\quad \nabla \cdot \mathbf{u} = 0,\quad \text{in}\ \Omega = [-1;1]^2
\end{equation}
with
\begin{equation}
  \label{eq:24}
  \mathbf{f} = \mathbf{0}
\end{equation}
where $\mu$ being the viscosity. The following boundary conditions apply
\begin{equation}
  \label{eq:23}
  \mathbf{u}=\mathbf{1}_{|y=1}, \quad \mathbf{u}=\mathbf{0}_{|\partial \Omega \backslash \{(x,y) \in \Omega | y=1\}}
\end{equation}
\end{problem}

In problem (\ref{prob:2}), $p$ is known up to a constant $c$,
\emph{i.e.} if $p$ is a solution then $p+c$ is also solution. To
ensure uniqueness we impose the constraint that $p$ should have
zero-mean, \emph{i.e.}
\begin{equation}
  \label{eq:26}
  \int_\Omega p = 0
\end{equation}

The problem~\ref{prob:4} now reads
\begin{problem}
  \label{prob:5}
 find $(\mathbf{u},p,\lambda)$ such that
\begin{equation}
  \label{eq:34}
  - \mu \Delta \mathbf{u} +\nabla p = \mathbf{f}\quad, \quad \nabla \cdot \mathbf{u} + \lambda = 0, \quad \text{and}\quad \int_\Omega p = 0,\quad \text{in}\ \Omega = [-1;1]^2
\end{equation}
with
\begin{equation}
  \label{eq:35}
  \mathbf{f} = \mathbf{0}
\end{equation}
where $\mu$ being the viscosity. The following boundary conditions apply
\begin{equation}
  \label{eq:36}
  \mathbf{u}=\mathbf{1}_{|y=1}, \quad \mathbf{u}=\mathbf{0}_{|\partial \Omega \backslash \{(x,y) \in \Omega | y=1\}}
\end{equation}
\end{problem}

The functional framework is as follows, we look for $\mathbf{u}$ is
$H^1_0(\Omega)$ and $p$ in $L^2_0(\Omega)$. We shall not seek $p$ in
$L^2_0(\Omega)$ but rather in $L^2(\Omega)$ and use Lagrange
multipliers which live are the constants whose space we denote
$\mathbb{P}_0(\Omega)$, to enforce~(\ref{eq:26}).

Denote $\mathcal{X} = H^1_0(\Omega)\times
L^2(\Omega)\times\mathbb{P}_0(\Omega)$, the variational formulation
reads we look for $(\mathbf{u}, p, \lambda) \in \mathcal{X}$ for all
$(\mathbf{v},q,\nu) \in \mathcal{X}$
\begin{equation}
  \label{eq:25}
  \int_\Omega \mu \nabla \mathbf{u} : \nabla \mathbf{v} + \nabla \cdot \mathbf{v} p + \nabla \cdot \mathbf{u}\ q + q \lambda + p \nu  \ = \ \int_\Omega \mathbf{f} \cdot \mathbf{v}
\end{equation}

We build a triangulation $\Omega_h$ of $\Omega$, we choose compatible
(piecewise polynomial) discretisation spaces $X_h$ and $M_h$,
\emph{e.g.} the Taylor Hood element ($\mathbb{P}_N/\mathbb{P}_{N-1}$)
and we denote $\mathcal{X}_h=X_h\times M_h \times
\mathbb{P}_0(\Omega)$.  The discrete problem now reads, we look for
$(\mathbf{u}_h,p_h,\lambda_h) \in \mathcal{X}_h$ such that for all
$(\mathbf{v}_h,q_h,\nu_h) \in \mathcal{X}_h$
\begin{equation}
  \label{eq:27}
  \int_{\Omega_h} \mu \nabla \mathbf{u}_h \cdot \nabla \mathbf{v}_h + \nabla \cdot \mathbf{v}_h \ p_h + \nabla \cdot \mathbf{u}_h\ q_h + p_h \nu_h + q_h \lambda_h   = \ \int_{\Omega_h} \mathbf{f} \cdot \mathbf{v}_h
\end{equation}

The formulation~(\ref{eq:27}) leads to a linear system of the form
\begin{equation}
  \label{eq:28}
  \underbrace{\begin{pmatrix}
    A & B & 0\\
    B^T & 0 & C\\
    0 & C^T & 0
  \end{pmatrix}}_{\mathcal{A}}
\underbrace{
  \begin{pmatrix}
    \mathbf{u}_h\\
    p_h\\
    \lambda_h
  \end{pmatrix}}_{\mathcal{U}} =
\underbrace{\begin{pmatrix}
    F\\
    0\\
    0
  \end{pmatrix}}_{\mathcal{F}}
\end{equation}

where $A$ corresponds to the $(\mathbf{u},\mathbf{v})$ block, $B$ to
the $(\mathbf{u},q)$ block and $C$ to the $(p,\nu)$
block. $\mathcal{A}$ is a symetric positive definite matrix and thus
the system $\mathcal{A} \mathcal{U} = \mathcal{F}$ enjoys a unique
solution.

\subsubsection{Feel formulation}
\label{sec:feel-formulation}

\index{Stokes!formulation!feel}
Regarding the implementation of the Stokes problem~\ref{prob:4}, we
can start from the laplacian case, from
section~\ref{sec:defin-bilin-forms}. The implementation we choose to
display here defines and builds $\mathcal{X}_h$, $\mathcal{A}$,
$\mathcal{U}$ and $\mathcal{F}$.

We start by defining and building $\mathcal{X}_h$: first we define the
basis functions that will span each subspaces $X_h$, $M_h$ and
$\mathbb{P}_0(\Omega)$.

\lstinputlisting[linerange=marker1-endmarker1]{stokes.cpp}

note that on the \lstinline!typedef! we build a (MPL) vector of them. Now we are
ready to define the functionspace $\mathcal{X}_h$, much like in the
Laplacian case:

\lstinputlisting[linerange=marker2-endmarker2]{stokes.cpp}

Next we define a few types which are associated with $\mathcal{U}$,
$u$, $p$ and $\lambda$ respectively.

\lstinputlisting[linerange=marker3-endmarker3]{stokes.cpp}

Using these types we can instantiate elements of $\mathcal{X}_h$,
$X_h$, $M_h$ and $\mathbb{P}_0(\Omega_h)$ respectively:

\lstinputlisting[linerange=marker4-endmarker4]{stokes.cpp}

They will serve in the definition of the variational formulation. We
can now start assemble the various terms of the variational
formulation~(\ref{eq:27}). First we define some viscous stress tensor,
%$\tau(\mathbf{u}) = \frac{1}{2}(\nabla \mathbf{u} + \nabla \mathbf{u}^T)$,
$\tau(\mathbf{u}) = \nabla \mathbf{u}$,
associated with the trial and test functions
respectively

\lstinputlisting[linerange=marker5-endmarker5]{stokes.cpp}

Then we define the total stress tensor times the normal,
$\bar{\sigma}(\mathbf{u},p) \mathbf{n} = -p \mathbf{n} + 2 \mu \tau(\mathbf{u})
\mathbf{n}$ where $\mathbf{n}$ is the normal and $\bar{\sigma}(\mathbf{u},p) =
-p \mathbb{I} + 2 \mu \tau(\mathbf{u})$:

\lstinputlisting[linerange=marker6-endmarker6]{stokes.cpp}


We then form the matrix $\mathcal{A}$ starting with block $A$,  block $B$
block $C$ and finally the boundary conditions.


\lstinputlisting[linerange=marker7-endmarker7]{stokes.cpp}

The figure~\ref{fig:2} displays $p$ and $\mathbf{u}$ which are available in
\begin{unixcom}
  ls ~/feel/doc/tutorial/stokes/Simplex_2_1_2/P2/h_0.05
\end{unixcom}

\begin{figure}[htbp]
  \centering
  \subfigure[Colored with $p$, $h=0.05$]{\includegraphics[width=.43\linewidth]{stokes-p.png}}
  \subfigure[Colored with $\|\mathbf{u}\|$ and the arrows associated to $\mathbf{u}$ colored with $p$]{\includegraphics[width=.43\linewidth]{stokes-u.png}}
  \caption{Solution of problem~\ref{prob:4}}
  \label{fig:2}
\end{figure}


\chapter{Examples}
\label{cha:examples}

\section{Solving nonlinear equations}
\label{sec:nonlinear-equations}

\feel allows to solve nonlinear equations thanks to its interface to
the interface to the PETSc nonlinear solver library. It requires the
implementation of two extra functions in your application that will
update the jacobian matrix associated to the tangent problem and the
residual.

Consider that you have an application class \lstinline!MyApp! with a
backend as data member
\begin{lstlisting}{gobble=2}
#include <feel/feelcore/feel.hpp>
#include <feel/feelcore/application.hpp>
#include <feel/feelalg/backend.hpp>
namespace Feel {

class MyApp : public Application
{
  public:

  typedef Backend<double> backend_type;
  typedef boost::shared_ptr<backend_type> backend_ptrtype;

  MyApp( int argc, char** argv,
  AboutData const& ad, po::options_description const& od )
  :
  // init the parent class
  Application( argc, argv, ad, od ),
  // init the backend
  M_backend( backend_type::build( this->vm() ) ),
  {
    // define the callback functions (works only for the PETSc backend)
    M_backend->nlSolver()->residual =
      boost::bind( &self_type::updateResidual, boost::ref( *this ), _1, _2 );
    M_backend->nlSolver()->jacobian =
      boost::bind( &self_type::updateJacobian, boost::ref( *this ), _1, _2 );

  }
  void updateResidual( const vector_ptrtype& X, vector_ptrtype& R )
  {
    // update the matrix J (Jacobian matrix) associated
    // with the tangent problem
  }
  void updateJacobian( const vector_ptrtype& X, sparse_matrix_ptrtype& J)
  {
    // update the vector R associated with the residual
  }
  void run()
  {

    //define space
    Xh...
    element_type u(Xh);
    // initial guess is 0
    u = project( M_Xh, elements(mesh), constant(0.) );
    vector_ptrtype U( M_backend->newVector( u.functionSpace() ) );
    *U = u;

    // define R and J
    vector_ptrtype R( M_backend->newVector( u.functionSpace() ) );
    sparse_matrix_ptrtype J;

    // update R
    updateJacobian( U, R );
    // update J
    updateResidual( U, J );

    // solve using non linear methods (newton)
    // tolerance : 1e-10
    // max number of iterations : 10
    M_backend->nlSolve( J, U, R, 1e-10, 10 );

    // the soluution was stored in U
    u = *U;
  }
  private:

  backend_ptrtype M_backend;
};
} // namespace Feel
\end{lstlisting}

The function \lstinline!updateJacobian! and \lstinline!updateResidual!
implement the assmebly of the matrix $J$ (jacobian matrix) and the
vector $R$ (residual vector) respectively.

\subsection{A first nonlinear problem}
\label{sec:bratu}

As a simple example, let $\Omega$ be a subset of $\mathbb{R}^d, d=1,2,3$,
(\emph{i.e.} $\Omega=[-1,1]^d$) with boundary $\partial
\Omega$. Consider now the following equation and boundary condition
\begin{equation}
  \label{eq:29}
  -\Delta u + u^\lambda = f,\quad u = 0 \text{ on } \partial \Omega.
\end{equation}
where $\lambda \in \mathbb{R_+}$ is a given parameter and $f=1$.


\begin{nota}
  To be described in this section. For now see
  \texttt{doc/tutorial/nonlinearpow.cpp} for an implementation of this
  problem.
\end{nota}

\subsection{Simplified combustion problem: Bratu}
\label{sec:bratu}

As a simple example, let $\Omega$ be a subset of $\mathbb{R}^d, d=1,2,3$,
(\emph{i.e.} $\Omega=[-1,1]^d$) with boundary $\partial
\Omega$. Consider now the following equation and boundary condition
\begin{equation}
  \label{eq:29}
  -\Delta u + \lambda e^u = f,\quad u = 0 \text{ on } \partial \Omega
\end{equation}
where $\lambda$ is a given parameter. Ceci est généralement appellé le
problème de Bratu et apparaît lors de la simplification de modèles de
processus de diffusion non-linéaires par exemple dans le domaine de la
combustion.

\begin{nota}
  To be described in this section. For now see
  \texttt{doc/tutorial/bratu.cpp} for an implementation of this
  problem.
\end{nota}

\input{example-heatns}

% The discrete variational formulation reads, we look for $u \in V
% \subset H^1(\Omega)$ such that
% \begin{equation}
%   \label{eq:30}
%   \int_\Omega \nabla u \cdot \nabla v + \lambda e^u v + \int_{\partial \Omega} -\frac{\partial u}{\partial \mathbf{n}} v -\frac{\partial v}{\partial \mathbf{n}} u + \frac{\mu}{h} u v  = 0\quad \forall v \in V
% \end{equation}
% where the last terms integrate on $\partial \Omega$ are associated with the weak treatment of the Dirichlet condition, see~\ref{sec:weak-dirichl-cond}.
% Denote the residual
% \begin{equation}
%   \label{eq:31}
%   \mathcal{F}() v=  \int_\Omega \nabla u \cdot \nabla v + \lambda e^u v + \int_{\partial \Omega} -\frac{\partial u}{\partial \mathbf{n}} v -\frac{\partial v}{\partial \mathbf{n}} u + \frac{\mu}{h} u v
% \end{equation}
% Denote the Jacobian
% \begin{equation}
%   \label{eq:32}
%   \mathcal{J}_z(u,v) = \int_\Omega \lambda e^z u v + \underbrace{\int_\Omega \nabla u \cdot \nabla v + \int_{\partial \Omega} -\frac{\partial u}{\partial \mathbf{n}} v -\frac{\partial v}{\partial \mathbf{n}} u + \frac{\mu}{h} u v}_{\text{linear part, constant over the nonlinear iterations}}
% \end{equation}
% The Nonlinear iterations now reads if $J$ and $F$ are the matrices and
% vectors associated with $\mathcal{J}_z$ and $\mathcal{F}$ respectively: given $u^{0}$
% \begin{equation}
%   \label{eq:33}
%   J_{u^n} u^{n+1} = -F
% \end{equation}



\appendix
\newpage
% \chapter{Compiling the tutorial examples}
% \label{sec:comp-tutor-exampl}


% \section{CMake}

% The build system of the tutorial examples is
% CMake\footnote{\url{http://www.cmake.org}} by Kitware.Here is a excerpt from CMake web site

% CMake is a cross-platform, open-source make system. CMake is used to
% control the software compilation process using simple platform and
% compiler independent configuration files. CMake generates native
% makefiles and workspaces that can be used in the compiler environment
% of your choice. CMake is quite sophisticated: it is possible to
% support complex environments requiring system configuration,
% pre-processor generation, code generation, and template
% instantiation. Please go here to learn more about CMake.

% CMake was developed by Kitware as part of the NLM Insight Segmentation
% and Registration Toolkit project. The ASCI VIEWS project also provided
% support in the context of their parallel computation
% environment. Other sponsors include the Insight, VTK, and VXL open
% source software communities.

% The goals for CMake include the following:

% \begin{itemize}
% \item Develop an open source, cross-platform tool to manage the build process,
% \item Allow the use of native compilers and systems,
% \item Simplify the build process,
% \item Optionally provide a user-interface to manage the build system,
% \item Create an extensible framework,
% \item Grow a self-sustaining community of software users and developers.
% \end{itemize}

% \section{Building the examples}
% \label{sec:building-examples}

% The compilation is fairly simple. First make sure that the
% \lstinline!cmake! and eventually its text based(ncurses) interfaces
% \lstinline!ccmake! are in your \lstinline!PATH! (i.e. you can execute
% them).
% \noindent
% Then create a directory, where you will build and test the examples, e.g.
% \begin{lstlisting}{language=sh}
% mkdir tutorial-build
% cd tutorial-build
% \end{lstlisting}

% \noindent
% Then you configure and generate the \lstinline!Makefile!s using CMake
% \begin{lstlisting}{language=sh}
% cmake <path to tutorial sources>
% \end{lstlisting}
% \noindent
% CMake provides a text based interface using ncurses for configuration,
% you can check it out using the command
% \begin{lstlisting}{language=sh}
% ccmake <path to tutorial sources>
% \end{lstlisting}
% \noindent Follow the instructions at the bottom: press \lstinline!c!
% to configure, then \lstinline!g! to generate the \lstinline!Makefile!s

% \noindent
% You are now ready to compile the examples
% \begin{lstlisting}{language=sh}
% make
% \end{lstlisting}
% If somehow something fails during the build, try using the
% \lstinline!make!  option \lstinline!-k! which allows to continue
% after a failure.


\include{randomnotes}
\include{feel}
\include{gfdl}

\backmatter

\printindex

\nocite{*}
\bibliographystyle{plain}
\bibliography{feel-manual}




\end{document}
