\chapter{Random notes}
\label{cha:random-notes}

\section{Becoming a Feel++ developer}
\label{feeldevel}
\subsection{Interest}
Becoming a \feel developer makes library improvements possible, you may have several proposals which may be usefull. Taking part of the project will enable you to commit some modifications or new applications, we will be glad to count you among us. As an open-source project under GNU licence,  you will be able to commit and participate to the entire project and its various aspects. Our aim is that each user should be involved in the library's expansion. In the following part, you will see how you can become a \feel collaborator.

\subsection{Creating RSA keys}
\label{sec:creation-rsa-keys}
At the top of the manual, you have seen how to get the sources anonymously, if you want to checkout or commit properly, you will need an account on \href{https://forge.imag.fr/}{LJKForge website}. After the administrator approval, you have to demand the rights to see the project tree. \newline \newline
Once it's done, you will have to create RSA keys to be able to connect to the server using ssh. To do that you have to type the commands : \verb|ssh-keygen| and accept the 3 questions without typing anything. The generated key is placed in \verb|~/.ssh/id_rsa.pub|, you just need to copy this file's content in your LJK forge account. To make it, go on the LJKForge website and enter into your account's personnal page. At the bottom of the page, you'll have the possibility to edit your SSH keys, go into it and copy/paste the id\_rsa.pub content. Once it's done, the number of your SSH keys in that page should have increased. Now, you will be able to connect to the server within an hour.
%\verb|ssh-keygen -t dsa| and \linebreak[2] \verb|ssh-keygen -t rsa| to create the keys. After that, you have to copy the \verb|id_dsa.pub| and \verb|id_rsa.pub| files in the My Page > Account Maintenance > Edit SSH Keys section of the LJKForge website. Those files are located in the \verb|~/.ssh/| folder of your computer. You will be able to connect to the server within an hour.
\\ \\
{\bfseries Important : } If you don't have the same login on your computer as on
LJKForge, you must add the commands in the \verb|~/.ssh/config| file :
\begin{lstlisting}[language=sh]
host ljkforge.imag.fr
  user <your_login_ljkforge>
\end{lstlisting}


\subsection{Downloading the sources}
\label{sec:download-sources}

To be able to download the \feel sources, you need subversion and SSH > 1.xxx
installed on your computer. In a command prompt, go where you want \feel to be
downloaded and type the following command :
\\ \verb|svn co svn+ssh://login@scm.forge.imag.fr/var/lib/gforge/chroot/scmrepos|
\\ \verb|/svn/life/trunk/life/trunk/life/trunk feel|
\\ where \verb|login| is your login name in the LJKForge plateform.

% ---- Useless now ? the command above downloads all feel sources, included the feel-test ---------
%Then, if you want to download the feel-test sources type :
%\begin{unixcom}
% cd feel/benchmarks
%  svn co svn+ssh://login@scm.forge.imag.fr/var/lib/gforge/chroot/scmrepos/svn/feel-test/feel-test/trunk validation
%\end{unixcom}
You are now able to checkout, commit or add the file your judge usefull using \verb|svn|, please don't forget to comment on your various actions. The first commit is subject to the approbation of one of the main developers.


\section{Linear Algebra with PETSC}

\subsection{Using the Petsc Backend: recommended}

Using the Petsc backend is recommended. To do that type in the command line
\begin{lstlisting}
    myprog --backend=petsc
  \end{lstlisting}
  then you can change the type of solvers and preconditioners by
  adding Petsc options at \emph{the end of the command lines}, for example
\begin{verbatim}
-pc_type lu
\end{verbatim}
  will actually solve the problem in one iteration of an iterative solver
  (p.ex. gmres).
  \begin{equation}
    \label{notes:eq:1}
    P A x = P B
  \end{equation}
  where $P \approx A^{-1}$. Here $A$ is decomposed in $LU$ form and
  (\ref{notes:eq:1}) is solved in one iteration.

\subsection{List of solvers and preconditioners}
\label{sec:list-solv-prec}

List of some iterative solvers (Krylov subspace)
\begin{itemize}
\item cg, bicg
\item gmres, fgmres, lgmres
\item bcgs, bcgsl
\item see petsc/petscksp.h for more
\end{itemize}

List of some preconditioners
\begin{itemize}
\item lu, choleski
\item jacobi, sor
\item ilu, icc
\item see petsc/petscpc.h for more
\end{itemize}

\subsection{What is going on in the solvers?}
\label{sec:what-going-solvers}

In order to monitor what is going on (iterations, residual...) Petsc
provides some monitoring options
\begin{verbatim}
-ksp_monitor
\end{verbatim}
For example
\begin{verbatim}
myprog -backend=petsc -ksp_monitor -pc_type lu
\end{verbatim}
it should show only one iteration.

See {\tiny\texttt{http://www.mcs.anl.gov/petsc/petsc-as/snapshots/petsc-current/docs/manualpages/KSP/KSPMonitorSet.html}} for more details

\section{Numerical Schemes}
\label{sec:numerical-schemes}

\subsection{Stokes problem formulation and the pressure}
\label{sec:stok-probl-form}

\subsection{The Stokes problem}
\label{sec:stokes-problem}

Consider the following problem,
\begin{equation}
  \label{notes:eq:16}
  \mbox{Stokes: }\left\{
    \begin{array}{rcc}
      -\mu\Delta\mathbf{u} +
      \nabla p =
      \mathbf{f}\\
      \nabla\cdot\mathbf{u} = 0\\
      \mathbf{u}|_{\partial \Omega} = 0
    \end{array}
  \right.
\end{equation}
where $\Omega \subset \mathbb{R}^d$. There are no boundary condition
on the pressure. This problem is ill-posed, indeed we only control the
pressure through its gradient $\nabla p$. Thus if $(\mathbf{u},p)$ is
a solution, then $(\mathbf{u},p+c)$ is also a solution with $c$ any
constant. This comes from the way the problem is posed: the box is
closed and it is not possible to determine the pressure inside. The
remedy is to impose arbitrarily a constraint on the pressure, e.g. its
mean value is zero. In other words, we add this new equation to the
problem (\ref{notes:eq:16})
\begin{equation}
  \label{notes:eq:17}
  \int_\Omega p = 0
\end{equation}
\begin{remark}[The Navier-Stokes case]
  This is also true for the incompressible Navier-Stokes equations. We
  chose Stokes to simplify the exposure.
\end{remark}

\subsection{Reformulation}
  In order to impose the condition~(\ref{notes:eq:17}), we introduce a new
  unknown, a Lagrange multiplier, $\lambda \in \mathbb{R}$ and modify
  the incompressibility equation. Our problem reads now, find
  $(\mathbf{u},p,\lambda)$ such
  that
    \begin{equation}
      \label{notes:eq:18}
    \mbox{Stokes 2: }\left\{
      \begin{array}{rcl}
        -\mu\Delta\mathbf{u} +
        \nabla p &=&
        \mathbf{f}\\
        \nabla\cdot\mathbf{u} + \lambda &=& 0\\
        \mathbf{u}|_{\partial \Omega} &=& 0\\
        \int_\Omega p &=& 0
      \end{array}
    \right.
\end{equation}
\begin{remark}[The pressure as Lagrange multiplier]
  The pressure field $p$ can actually be seen as a Lagrange multiplier
  for the velocity $\mathbf{u}$ in order to enforce the constraint
  $\nabla \cdot \mathbf{u} = 0$. $\lambda$ will play the same role but
  for the pressure to enforce the condition (\ref{notes:eq:17}). As $h
  \rightarrow 0$, $\lambda \rightarrow 0$ as well as the divergence of
  $\mathbf{u}$. Note also that $\int_\Omega \nabla \cdot \mathbf{u}
  \approx - \int_\Omega \lambda$ from the second equation.
\end{remark}

\subsection{Variational formulation}
\label{sec:vari-form}

The variational formulation now reads: find $(\mathbf{u}, p,
\lambda) \in \mathbf{H}^1_0(\Omega) \times L^2_0(\Omega) \times
\mathbb{R}$ such that for all $(\mathbf{v}, q, \eta) \in
\mathbf{H}^1_0(\Omega) \times L^2_0(\Omega) \times \mathbb{R}$

\begin{equation}
  \label{notes:eq:20}
  \mbox{Stokes 3: }\left\{
    \begin{array}{rcl}
      \int_\Omega \Big(\nabla \mathbf{u} \colon \nabla \mathbf{v} + \nabla \cdot \mathbf{v} p\Big) &=& \int_\Omega \mathbf{f} \cdot \mathbf{v}\\
      \int_\Omega \Big(\nabla\cdot\mathbf{u} q + \lambda q\Big)   &=& 0\\
      \int_\Omega p \eta &=& 0
    \end{array}
  \right.
\end{equation}

Summing up all three equations we get the following condensed formulation:

\begin{equation}
  \label{notes:eq:19}
  \int_\Omega \nabla \mathbf{u} \colon \nabla \mathbf{v} + \nabla \cdot \mathbf{v} p + \nabla \cdot \mathbf{u} q + \lambda q + \eta p = \int_\Omega \mathbf{f} \cdot \mathbf{v}
\end{equation}
where $\mathbf{H}^1_0(\Omega)= \Big\{ \mathbf{v} \in \mathbf{L}^2(\Omega), \nabla \mathbf{v} \in [L^2(\Omega)]^{d\times d},\ \mathbf{v} = 0\ \text{on}\ \partial \Omega \Big\}$,
$L^2_0(\Omega)= \Big\{ v \in L^2(\Omega),\ \int_\Omega v = 0\Big\}$, and
$\mathbf{L}^2(\Omega)= \Big\{ \mathbf{v} \in [L^2(\Omega)]^d\Big\}$ that is to say each component of a  vector field of $\mathbf{L}^2(\Omega)$ are in $L^2(\Omega)$.


\subsection{Implementation}
\label{sec:implementation}

  \begin{lstlisting}
/*basis*/
typedef Lagrange<Order, Vectorial> basis_u_type; // velocity
typedef Lagrange<Order-1, Scalar> basis_p_type; // pressure
typedef Lagrange<0, Scalar> basis_l_type; // multipliers
typedef bases<basis_u_type, basis_p_type, basis_l_type> basis_type;
/*space: product of the velocity, pressure and multiplier spaces*/
typedef FunctionSpace<mesh_type, basis_type, value_type> space_type;
// ...
space_ptrtype Xh = space_type::New( mesh );
element_type U( Xh, "u" );
element_type V( Xh, "v" );
element_0_type u = U.element<0>();
element_0_type v = V.element<0>();
element_1_type p = U.element<1>();
element_1_type q = V.element<1>();
element_2_type lambda = U.element<2>();
element_2_type nu = V.element<2>();
// ...
sparse_matrix_ptrtype D( M_backend->newMatrix( Xh, Xh ) );
form2( Xh, Xh, D, _init=true )=
   integrate( elements(mesh), im,
             // $\nabla \mathbf{u} \colon \nabla \mathbf{v}$
              mu*trace(deft*trans(def))
              // $\nabla \cdot \mathbf{v} p + \nabla \cdot \mathbf{u} q$
              - div(v)*idt(p) + divt(u)*id(q)
              // $\lambda q + \eta p$
              +id(q)*idt(lambda) + idt(p)*id(nu) );
// ...
  \end{lstlisting}


\subsection{Fix point iteration for Navier-Stokes}
\label{sec:fix-point-iteration}

\subsubsection{Steady incompressible Navier-Stokes equations}
  Consider the following steady incompressible Navier-Stokes
  equations, find $(\mathbf{u},p)$ such that
  \begin{equation}
    \label{notes:eq:7}
    \begin{split}
      \underbrace{\rho \mathbf{u} \cdot \nabla \mathbf{u}}_{\text{convection}} - \underbrace{\nu \Delta  \mathbf{u}}_{\text{diffusion}} + \nabla p &=  \mathbf{f} \ \text{on}\ \Omega \\
      \nabla \cdot \mathbf{u} &= 0 \\
      \mathbf{u} &= \mathbf{0}\ \text{on}\ \partial \Omega
    \end{split}
  \end{equation}
  where $\rho$ is the density of the fluid, $\nu$ is the dynamic
  viscosity of the fluid(la viscosité cinématique $\eta = \nu/\rho$) and $\mathbf{f}$ is the external force
  density applied to the fluid, (e.g. $\mathbf{f}=-\rho g \mathbf{e}_2$ with $\mathbf{e}_2=(0,1)^T$ ).  This equation system is nonlinear due
  to the $\mathbf{u} \cdot \nabla \mathbf{u}$ convection term. A
  simple approach to solve~(\ref{notes:eq:7}) is to use a fix point
  algorithm.


The fixpoint algorithm for NS reads as follows, find
$(\mathbf{u}^{(k)},p^{(k)})$ such that
    \begin{equation}
      \label{notes:eq:13}
    \begin{split}
      \rho\mathbf{u}^{(k-1)} \cdot \nabla \mathbf{u}^{(k)} - \nu \Delta  \mathbf{u}^{(k)} + \nabla p^{(k)} &= \mathbf{f} \ \text{on}\ \Omega \\
      \nabla \cdot \mathbf{u}^{(k)} &= 0 \\
      \mathbf{u}^{(k)} &= 0\ \text{on}\ \partial \Omega\\
      (\mathbf{u}^{(0)},p^{(0)}) &= (\mathbf{0},0)
    \end{split}
  \end{equation}
  The system~(\ref{notes:eq:13}) is now linear at each iteration $k$ and we
  can write the variational formulation accordingly. A stopping
  criterium is for example that
  $\|\mathbf{u}^{k}-\mathbf{u}^{(k-1)}\|+\|p^{k}-p^{(k-1)}\| <
  \epsilon$ where $\epsilon$ is a given tolerance (e.g. $1e-4$) and
  $\|\cdot\|$ is the $L_2$ norm.

  Here is the implementation using Life:

  \begin{lstlisting}
    // define some tolerance $\epsilon$
    epsilon = 1e-4;
    // set $(\mathbf{u}^{(0)},p^{(0)})$ to $(\mathbf{0},0)$
    velocity_element_type uk(Xh);
    velocity_element_type uk1(Xh);
    pressure_element_type pk(Ph);
    pressure_element_type pk1(Ph);
    // by default uk1, uk and pk,pk1 are initialized to 0

    // assemble the linear form associated to $\mathbf{f}$
    // store in vector $F$, it does not change over the iterations

    // iterations to find $(\mathbf{u}^{(k)},p^{(k)})$
    do
    {
      // save results of previous iterations
      uk1 = uk;
      pk1 = pk;

      //assemble for bilinear form  associated to
      // $\rho\mathbf{u}^{(k-1)} \cdot \nabla \mathbf{u}^{(k)} - \nu \Delta  \mathbf{u}^{(k)} + \nabla p^{(k)}$
      // store in matrix $A^{(k)}$

      // solve the system $A^{(k)} X = F$ where $X = (\mathbf{u}^{(k)},p^{(k)})^T$

      // use uk,uk1 and pk,pk1 to compute the error estimation at each iteration
      error = $\|\mathbf{u}^{k}-\mathbf{u}^{(k-1)}\|+\|p^{k}-p^{(k-1)}\|$
    } while( error > epsilon );

  \end{lstlisting}

\subsection{A Fix point coupling algorithm}
\label{sec:coupling-algorithm}

\subsubsection{Coupling fluid flow and heat transfer: problem}
  Recall that we have to solve two coupled problems :

  $$
  \mbox{Heat(\textbf{u}) }\left\{
  \begin{array}{rcc}
    - \kappa\Delta T + \mathbf{u}\cdot\nabla T &=& 0 \\
    T|_{\Gamma_1} &=& T_0 \\
    \frac{\partial T}{\partial \mathbf{n}}|_{\Gamma_3} &=&1 \\
    \frac{\partial T}{\partial \mathbf{n}}|_{\Gamma_2,\Gamma_4} &=& 0
  \end{array}
  \right.
  $$

  and

  $$\mbox{Stokes(T) : }\left\{
    \begin{array}{rcc}
      -\nu\Delta\mathbf{u} +
      \frac{1}{\rho}\nabla p =
      \mathbf{F}\\
      \nabla\cdot\mathbf{u} = 0\\
      \mathbf{u}|_{\partial \Omega} = 0
    \end{array}
  \right.
  $$

Where $\mathbf{F}$ can be taken as $
 \left(
  \begin{array}{c}
    0 \\
    \beta(T-T_0)
  \end{array}
\right)
$
for some $\beta > 0$. $\beta$ is called the \emph{dilatation coefficient}.

\subsubsection{Coupling fluid flow and heat transfer: algorithm}
Here is a simple algorithm fix point strategy in pseudo-code:
\begin{lstlisting}
   double tol = 1.e-6;
   int maxIter = 50;
   //Initial guess Un = 0
   do
   {
     // Find Tn solution of Heat(Un)
     // Find Unp1 solution of Stokes(Tn)
     // compute stopTest = norme(Unp1 - Un)
     // Un = Unp1
   }while((stopTest < tol) && (niter <= maxIter));
\end{lstlisting}

\begin{remark}[The unsteady case]
  To solve the unsteady problems, one can insert the previous loop in
  the one dedicated to time discretization
\end{remark}

\subsection{A Newton coupling algorithm}
\label{sec:newt-coupl-algor}

\subsubsection{A fully coupled scheme}

  Another possiblity is to use a Newton method which allows us to
  solve the full nonlinear problem coupling velocity, pressure and
  temperature
  \begin{equation}
    \label{notes:eq:21}
    \text{Find}\ X\ \text{such that}\ F(X) = 0
  \end{equation}
  the method is iterative and reads, find $X^{(n+1)}$ such that
  \begin{equation}
    \label{notes:eq:22}
    J_F(X^{(n)})( X^{(n+1)}-X^{(n)}) = - F (X^{(n)})
  \end{equation}
  starting with $X^{(0)} = \mathbf{0}$ or some other initial value and
  where $J_F$ is the jacobian matrix of $F$ evaluated at
  $X=((u_i)_i,(p_i)_i,(\theta_i)_i)^T$.  For any $\phi_k, \psi_l$ and
  $\rho_m$ the \emph{test} functions associated respectively to velocity,
  pressure and temperature, our full system reads, Find $X=((u_i)_i,(p_i)_i,(\theta_i)_i)^T$ such that
  \begin{equation}
    \label{notes:eq:23}
    \begin{array}{rll}
      F_1((u_i)_i,(p_i)_i,(\theta_i)_i)&=\sum_{i,j} u_i u_j a(\phi_i,\phi_k,\phi_j) - \sum_i p_i b(\phi_k,\psi_i) + \sum_i \theta_i c(\rho_i, \phi_k)+\sum_i u_i d(\phi_i,\phi_k)  &= 0\\
      F_2((u_i)_i,(p_i)_i,(\theta_i)_i)&=\sum_i u_i b(\phi_i,\psi_l) &=0\\
      F_3((u_i)_i,(p_i)_i,(\theta_i)_i)&=\sum_{i,j} u_i\theta_j e(\phi_i,\rho_j,\rho_m) + \sum_i \theta_i f(\rho_i,\rho_m)-g(\rho_m) &=  0
    \end{array}
  \end{equation}
  where $F=(F_1,F_2,F_3)^T$ and
  \begin{equation}
    \label{notes:eq:26}
    \begin{array}{rl}
    a(\mathbf{u},\mathbf{v},\beta) &= \int_\Omega \mathbf{v}^T ((\nabla \mathbf{u} )\beta)\\
    b(\mathbf{v},p) &= \int_\Omega p (\nabla \cdot \mathbf{v}) - \int_{\partial \Omega} \mathbf{v}\cdot\mathbf{n} p\\
      c(\theta,\mathbf{v})&= \int_\Omega \theta \mathbf{e}_2 \cdot \mathbf{v}\\
      d(\mathbf{u},\mathbf{v}) &= \frac{1}{\sqrt{\mathrm{Gr}}} \Big(\int_\Omega \nabla \mathbf{u} \colon (\nabla \mathbf{v})^T - \int_{\partial \Omega} ((\nabla \mathbf{u}) \mathbf{n})\cdot \mathbf{v}\Big)\\
      e(\mathbf{u},\theta,\chi) &= \int_\Omega (\mathbf{u}\cdot \nabla \theta) \chi \\
      f(\theta,\chi) &=\frac{1}{\sqrt{\mathrm{Gr}}\mathrm{Pr}} \Big( \int_\Omega \nabla \theta \cdot \nabla \chi - \int_{\Gamma_1} (\nabla \theta \cdot \mathbf{n} ) \chi \Big)\\
      g(\chi) &=\frac{1}{\sqrt{\mathrm{Gr}}\mathrm{Pr}} \int_{\Gamma_3} \chi
    \end{array}
  \end{equation}
  \begin{remark}
    Note that the boundary integrals are kept in order to apply the
    weak Dirichlet boundary condition trick, see next section~\ref{sec:weak-dirichl-boud}.
  \end{remark}

\subsubsection{Jacobian matrix}
  In order to apply the newton scheme, we need to compute the jacobian
  matrix $J_F$ by deriving each equation with respect to each
  unknowns, ie $u_i, p_i$ and $\theta_i$.
  Consider the first equation
  \begin{itemize}
  \item Deriving the first equation with respect to $u_i$ we get
    \begin{equation}
      \label{notes:eq:30}
      \frac{\partial F_1}{\partial u_i} = \sum_j u_j a(\phi_i,\phi_k,\phi_j) + \sum_i u_i a(\phi_i,\phi_k,\phi_j) + d(\phi_i,\phi_k)
    \end{equation}
  \item Deriving the first equation with respect to $p_i$ we get
    \begin{equation}
      \label{notes:eq:30}
      \frac{\partial F_1}{\partial p_i} =  -b(\phi_k,\psi_l)
    \end{equation}
  \item Deriving the first equation with respect to $\theta_i$ we get
    \begin{equation}
      \label{notes:eq:30}
      \frac{\partial F_1}{\partial \theta_i} = c(\rho_i,\rho_k)
    \end{equation}

  \end{itemize}
  Consider the second equation, only the derivative with respect to $u_i$ is non zero.
  \begin{equation}
    \label{notes:eq:31}
    \frac{\partial F_2}{\partial u_i} = b(\phi_i,\psi_l)
  \end{equation}
  Finally the third component
  \begin{itemize}
  \item Deriving with respect to $u_i$
    \begin{equation}
      \label{notes:eq:33}
      \frac{\partial F_3}{\partial u_i} = \sum_j \theta_j e(\phi_i,\rho_j,\rho_m)
    \end{equation}
  \item Deriving with respect to $p_i$,
    \begin{equation}
      \label{notes:eq:34}
      \frac{\partial F_3}{\partial p_i} = 0
    \end{equation}
  \item Deriving with respect to $theta_i$,
    \begin{equation}
      \label{notes:eq:35}
      \frac{\partial F_3}{\partial \theta_i} = \sum_j u_j e(\phi_j,\rho_i,\rho_m) + f(\rho_i,\rho_m)
    \end{equation}
  \end{itemize}
  \begin{equation}
    \label{notes:eq:35}
    J_F =
    \begin{pmatrix}
      \frac{\partial F_1}{\partial u_i} & \frac{\partial F_1}{\partial p_i} & \frac{\partial F_1}{\partial \theta_i} \\
      {\frac{\partial F_2}{\partial u_i}} & {\frac{\partial F_2}{\partial p_i}}(=0) & {\frac{\partial F_2}{\partial \theta_i}}(=0) \\
      \frac{\partial F_3}{\partial u_i} & {\frac{\partial F_3}{\partial p_i}}(=0) & \frac{\partial F_3}{\partial \theta_i}
    \end{pmatrix}
  \end{equation}
  In order to implement $J_F$ and solve (\ref{notes:eq:22}), $J_F$ can be
  expressed as the matrix associated with the discretisation of
  \begin{equation}
    \label{notes:eq:37}
    \begin{array}{rl}
      a(\mathbf{u},\mathbf{v},\beta_1) + a(\beta_1, \mathbf{v}, \mathbf{u})+d(\mathbf{u},\mathbf{v})-b(\mathbf{v},p)+c(\theta,\mathbf{v}) &= 0\\
      b(\mathbf{u},q)&=0\\
      e(\beta_1,\theta,\chi)+f(\theta,\chi)+e(\mathbf{u},\beta_2,\chi)&=0\\
    \end{array}
  \end{equation}
  where $\beta_1 = u^{(n)}$, $\beta_2=\theta^{(n)}$ are known from the
  previous Newton iteration, indeed $J_F$ is actually evaluated in $X^{(n)}$.

\subsubsection{Life Implementation}
  Now we use the Life non linear framework in order to implement our
  Newton scheme~(\ref{notes:eq:22}).
  We need to define two new functions in our application
  \begin{itemize}
  \item \texttt{updateJacobian(X,J)} which takes as input \texttt{X}$=X^{(n)}$ and returns the matrix \texttt{J=}$J_F(X^{(n)})$
  \item \texttt{updateResidual(X,R)} which takes as input \texttt{X}$=X^{(n)}$ and returns the vector \texttt{R=}$F(X^{(n)})$
  \end{itemize}

  \begin{remark}{Backend}
    Only the PETSC backend supports the nonlinear solver framework.
    Use  in the command line like in the first section
    \begin{lstlisting}
      --backend=petsc
    \end{lstlisting}
  \end{remark}

  Here is a snippet of code that implements the nonlinear framework.
  \begin{lstlisting}
    class MyApp
    {
      public:
      void run();
      void updateResidual( const vector_ptrtype& X, vector_ptrtype& R );
      void updateJacobian( const vector_ptrtype& X, sparse_matrix_ptrtype& J);
      void solve( sparse_matrix_ptrtype& D, element_type& u, vector_ptrtype& F );
      private:

      backend_ptrtype M_backend;
      sparse_matrix_ptrtype M_jac;
      vector_ptrtype M_residual;
    };

    void
    MyApp::run()
    {
      // ...

      // plug the updateResidual and updateJacobian functions
      // in the nonlinear framework
      M_backend->nlSolver()->residual = boost::bind( &self_type::updateResidual,
                                                     boost::ref( *this ), _1, _2 );
      M_backend->nlSolver()->jacobian = boost::bind( &self_type::updateJacobian,
                                                     boost::ref( *this ), _1, _2 );

      vector_ptrtype U( M_backend->newVector( u.functionSpace() ) );
      *U = u;
      vector_ptrtype R( M_backend->newVector( u.functionSpace() ) );
      this->updateResidual( U, R );
      sparse_matrix_ptrtype J;
      this->updateJacobian( U, J );
      solve( J, u, R );

      *U = u;
      this->updateResidual( U, R );
      // R(u) should be small
      std::cout << "R( u ) = " << M_backend->dot( U, R ) << "\n";


    }
    void
    MyApp::solve( sparse_matrix_ptrtype& D, element_type& u, vector_ptrtype& F )
    {
      vector_ptrtype U( M_backend->newVector( u.functionSpace() ) );
      *U = u;
      M_backend->nlSolve( D, U, F, 1e-10, 10 );
      u = *U;
    }
    void
    MyApp::updateResidual( const vector_ptrtype& X, vector_ptrtype& R )
    {
      // compute R(X)

      R=M_residual;
    }
    void
    MyApp::updateJacobian( const vector_ptrtype& X, vector_ptrtype& R )
    {
      // compute J(X)

      J=M_jac;
    }
  \end{lstlisting}
  see \texttt{bratu.cpp} or \texttt{nonlinearpow.cpp} for example.


\section{Weak Dirichlet boudary conditions}
\label{sec:weak-dirichl-boud}

\subsection{Basic idea}

\subsubsection{Weak treatment}
  In order to treat the boundary conditions uniformly (i.e. the same
  way as Neumann and Robin Conditions), we wish to treat the Dirichlet
  BC (e.g. $u=g$) weakly.

  \begin{remark}{Initial Idea}
    add the penalisation term $\int_{\partial \Om{}} \mu( u - g
    )$ where $\mu$ is a constant. But this is not enough, this is not consistent with the
    initial formulation.
  \end{remark}

  One can use the Nitsche ``trick'' to implement weak Dirichlet conditions.
  \begin{itemize}
  \item write the equations in conservative form (i.e. identify the flux);
  \item add the terms to ensure consistency (i.e the flux on the boundary);
  \item symmetrize to ensure adjoint consistency;
  \item add a penalisation term with factor $\gamma (u-g)/h$ that ensures
    that the solution will be set to the proper value at the boundary;
  \end{itemize}


\subsubsection{Penalisation parameter}
    \begin{remark}{Choosing $\gamma$}
    $\gamma$ must be chosen such that the coercivity(or inf-sup)
    property is satisfied. Difficult to do in general. Increase
    $\gamma$ until the BC are properly satisfied, e.g. start with
    $\gamma=1$, typical values are between 1 and 10.

    The choice of $\gamma$ is a problem specially when $h$ is small.
  \end{remark}



\subsubsection{Advantages, disadvantages}
      \begin{remark}{Weak treatment: Advantages}
        \begin{itemize}
        \item uniform(weak) treatment of all boundary conditions type
        \item if boundary condition is independant of time, the terms
          are assembled once for all
        \item the boundary condition is not enforced exactely but the
          convergence order remain optimal
        \end{itemize}
      \end{remark}
      \begin{remark}{Weak treatment: Disadvantages}
        \begin{itemize}
        \item Introduction of the penalisation parameter $\gamma$ that
          needs to be tweaked
        \end{itemize}
      \end{remark}

\subsubsection{Advantages, disadvantages}
  \begin{remark}{Strong treatment: Advantages}
    \begin{itemize}
    \item Enforce exactely the boundary conditions
    \end{itemize}
  \end{remark}
  \begin{remark}{Strong treatment : Disadvantages}
    \begin{itemize}
    \item Need to modify the matrix once assembled to reflect that
      the Dirichlet degree of freedom are actually known. Then
          even if the boundary condition is independant of time, at
          every time step if there are terms depending on time that
          need reassembly (e.g. convection) the strong treatment needs to be reapplied.
        \item it can be expensive to apply depending on the type of
          sparse matrix used, for example using CSR format setting
          rows to 0 except on the diagonal to 1 is not expensive but
          one must do that also for the columns associated with each
          Dirichlet degree of freedom and that is expensive.
        \end{itemize}
      \end{remark}

\subsection{Laplacian}
\subsubsection{Example: Laplacian}
  \begin{equation}
    \label{notes:eq:44}
    -\Delta u = f (\text{non conservative}),\ -\nabla\cdot( \nabla u )= f (\text{conservative}),\ u=g|_{\partial \Omega}
  \end{equation}
  the flux is vector $\nabla u$

  \begin{equation}
    \label{notes:eq:51}
    \int_\Omega \nabla u \cdot \nabla v + \int_{\partial \Om{}} \underbrace{-\frac{\partial u}{\partial n}v}_{\text{integration by part}} \underbrace{-\frac{\partial v}{\partial n} u}_{\text{adjoint consistency: symetrisation}}  + \underbrace{\frac{\gamma}{h} u v}_{\text{penalisation: enforce Dirichlet condition}}
  \end{equation}
  \begin{equation}
    \label{notes:eq:52}
    \int_\Omega f \nabla v + \int_{\partial \Om{}} (\underbrace{-\frac{\partial v}{\partial n} g}_{\text{adjoint consistency}} + \underbrace{\frac{\gamma}{h} v) g}_{\text{penalisation: enforce Dirichlet condition}}
  \end{equation}


\subsubsection[containsverbatim]{Example: Laplacian}
  \begin{lstlisting}
// bilinear form (left hand side)
form2( Xh, Xh, D ) +=
integrate( boundaryfaces(mesh), im_type(),
           -(gradt(u)*N())*id(v) // integration by part
           -(grad(v)*N())*idt(u) // adjoint consistency
           +gamma*id(v)*idt(u)/hFace()); // penalisation
// linear form (right hand side)
form1( Xh, F ) +=
integrate( boundaryfaces(mesh), im_type(),
           -(grad(v)*N())*g // adjoint consistency
           +gamma*id(v)*g/hFace()); // penalisation
  \end{lstlisting}


\subsection{Convection-Diffusion}
\subsubsection{Example: Convection-Diffusion}
  \begin{remark}{Convection Diffusion}
    Consider now the following problem, find $u$ such that
    \begin{equation}
      \label{notes:eq:45}
      -\Delta u + \mathbf{c} \cdot \nabla u  = f,\quad u = g|_{\partial \Om{}},\quad \nabla \cdot \mathbf{c} = 0
    \end{equation}
    under conservative form the equation reads
    \begin{equation}
      \label{notes:eq:2}
      \nabla \cdot ( -\nabla u + \mathbf{c} u ) = f,\quad u = g|_{\partial \Om{}},\quad \nabla \cdot \mathbf{c} = 0
    \end{equation}
    the flux vector field is $\mathbf{F}=-\nabla u + \mathbf{c} u$. Note that
    here the condition, $\nabla \cdot \mathbf{c} = 0$ was crucial to
    expand $\nabla \cdot (\mathbf{c} u )$ into $\mathbf{c} \cdot \nabla u$ since
    \begin{equation}
      \label{notes:eq:3}
      \nabla \cdot (\mathbf{c} u ) = \mathbf{c} \cdot \nabla u + \underbrace{u \nabla \cdot \mathbf{c}}_{=0}
    \end{equation}
  \end{remark}


\subsubsection{Weak formulation for convection diffusion}
  Multiplying by any test function $v$ and integration by
  part of (\ref{notes:eq:2}) gives
  \begin{equation}
    \label{notes:eq:4}
    \int_\Omega \nabla u \cdot \nabla v + (\mathbf{c} \cdot \nabla u)v + \int_{\partial \Omega} (\mathbf{F}\cdot \mathbf{n}) v = \int_\Omega f v
  \end{equation}
  where $\mathbf{n}$ is the outward unit normal to $\partial
  \Omega$. We now introduce the penalisation term that will ensure
  that $u \rightarrow g$ as $h \rightarrow 0$ on $\partial \Omega$. (\ref{notes:eq:4}) reads now
  \begin{equation}
    \label{notes:eq:5}
    \int_\Omega \nabla u \cdot \nabla v + (\mathbf{c} \cdot \nabla u)v + \int_{\partial \Omega} (\mathbf{F}\cdot \mathbf{n}) v + \mathbf{\frac{\gamma}{h} u v}  = \int_\Omega f v + \mathbf{\int_{\partial \Omega} \frac{\gamma}{h} g v}
  \end{equation}

  Finally we incorporate the symetrisation of the bilinear form to ensure adjoint consistency and hence proper convergence order
  \begin{equation}
    \label{notes:eq:6}
    \begin{split}
      \int_\Omega \nabla u \cdot \nabla v + (\mathbf{c} \cdot \nabla u)v +
      \int_{\partial \Omega} ((-\nabla u + \mathbf{c} u)\cdot \mathbf{n}) v+ \mathbf{((-\nabla v + \mathbf{c} v)\cdot \mathbf{n}) u} + \frac{\gamma}{h} u v  = \\
      \int_\Omega f v + \int_{\partial \Omega} \mathbf{((-\nabla v + \mathbf{c} v)\cdot \mathbf{n}) g}+ \frac{\gamma}{h} g v
    \end{split}
  \end{equation}


\subsubsection[containsverbatim]{Example: Convection-Diffusion}
  \begin{lstlisting}
// bilinear form (left hand side)
form2( Xh, Xh, D ) +=
integrate( boundaryfaces(mesh), im_type(),
           // integration by part
           -(gradt(u)*N())*id(v) + (idt(u)*trans(idv(c))*N())*id(v)
           // adjoint consistency
           -(grad(v)*N())*idt(u) + (id(v)*trans(idv(c))*N())*idt(u)
           // penalisation
           +gamma*id(v)*idt(u)/hFace());
// linear form (right hand side)
form1( Xh, F ) +=
integrate( boundaryfaces(mesh), im_type(),
           // adjoint consistency
           -(grad(v)*N())*g + (id(v)*trans(idv(c))*N())*g
           // penalisation
           +gamma*id(v)*g/hFace());
  \end{lstlisting}


\subsection{Stokes}
\subsubsection{Example: Stokes}
  \begin{remark}{Stokes}
    Consider now the following problem, find $(\mathbf{u},p)$ such that
    \begin{equation}
      \label{notes:eq:45}
      -\Delta \mathbf{u} + \nabla p  = \mathbf{f},\quad \mathbf{u} = \mathbf{g}|_{\partial \Om{}},\quad \nabla \cdot \mathbf{u} = 0
    \end{equation}
    under conservative form the equation reads
    \begin{eqnarray}
      \nabla \cdot ( -\nabla \mathbf{u} + p \mathbb{I} ) &= \mathbf{f},\label{notes:eq:8}\\
      \nabla \cdot \mathbf{u} &= 0,\label{notes:eq:10}\\
      \mathbf{u} &= \mathbf{g}|_{\partial \Om{}}\label{notes:eq:11}
    \end{eqnarray}
    where $\mathbb{I}(\mathbf{x})=
    \begin{pmatrix}
      1 & 0\\
      0 & 1
    \end{pmatrix}\text{(in 2D)}
    \ \forall \mathbf{x} \in \Omega$ is the identity tensor(matrix) field $\in
    \mathbb{R}^{d\times d}$. The flux tensor field is
    $\mathbf{F}=-\nabla \mathbf{u} + p\mathbb{I}$. Indeed we have  the
    following relation, if $\mathbb{M}$ is a tensor (rank 2) field and $\mathbf{v}$ is a vector field
    \begin{equation}
      \label{notes:eq:12}
      \nabla \cdot ( \mathbb{M} \mathbf{v} ) = (\nabla \cdot \mathbb{M}) \cdot \mathbf{v} + \mathbb{M} \colon (\nabla \mathbf{v})
    \end{equation}
    where $\mathbb{M} \colon (\nabla \mathbf{v}) =
    \mathrm{trace}(\mathbb{M}*\nabla \mathbf{v}^T)$, $*$ is the
    matrix-matrix multiplication and $\nabla \cdot \mathbb{M}$ is the
    vector field with components the divergence of each row of
    $\mathbb{M}$. For example $\nabla \cdot (p\ \mathbb{I})=\nabla \cdot
    \begin{pmatrix}
      p & 0 \\
      0 & p
    \end{pmatrix}(\text{in 2D}) =  \nabla p$.
  \end{remark}


\subsubsection{Weak formulation for Stokes}
  Taking the scalar product of (\ref{notes:eq:8}) by any test function
  $\mathbf{v}$ (associated to velocity) and multiplying (\ref{notes:eq:10})
  by any test function $q$ (associated to pressure), the variational
  formulation of (\ref{notes:eq:8}) reads, thanks to~(\ref{notes:eq:12}),
  \begin{equation}
    \label{notes:eq:9}
    \int_\Omega \nabla \mathbf{u} \colon \nabla \mathbf{v} +  p \nabla \cdot \mathbf{v} + \int_{\partial \Omega} ( (-\nabla \mathbf{u} + p\mathbb{I}) \mathbf{n}) \cdot \mathbf{v} = \int_\Omega \mathbf{f} \cdot \mathbf{v}
  \end{equation}
  where $\mathbf{n}$ is the outward unit normal to $\partial
  \Omega$. We now introduce the penalisation term that will ensure
  that $\mathbf{u} \rightarrow \mathbf{g}$ as $h \rightarrow 0$ on $\partial \Omega$. (\ref{notes:eq:9}) reads now
  \begin{equation}
    \label{notes:eq:14}
    \int_\Omega \nabla \mathbf{u} \colon \nabla \mathbf{v} +  p \nabla \cdot \mathbf{v} + \int_{\partial \Omega} ((-\nabla \mathbf{u} + p\mathbb{I}) \mathbf{n})\cdot \mathbf{v} + \mathbf{\frac{\gamma}{h} \mathbf{u}\cdot \mathbf{v}}  = \int_\Omega \mathbf{f} \cdot \mathbf{v} + \mathbf{\int_{\partial \Omega} \frac{\gamma}{h} \mathbf{g} \cdot \mathbf{v}}
  \end{equation}

  Finally we incorporate the symetrisation of the bilinear form to ensure adjoint consistency and hence proper convergence order
  \begin{equation}
    \label{notes:eq:15}
    \begin{split}
      \int_\Omega \nabla \mathbf{u} \colon \nabla \mathbf{v} +  p \nabla \cdot \mathbf{v} +
      \int_{\partial \Omega} ((-\nabla \mathbf{u} + p\mathbb{I}) \mathbf{n})\cdot \mathbf{v} + ((-\nabla \mathbf{v} + q\mathbb{I}) \mathbf{n})\cdot \mathbf{u} + \frac{\gamma}{h} \mathbf{u}\cdot \mathbf{v} = \\
      \int_\Omega \mathbf{f} \cdot \mathbf{v} + \int_{\partial \Omega} ((-\nabla \mathbf{v} + q\mathbb{I}) \mathbf{n})\cdot \mathbf{g} + \frac{\gamma}{h} \mathbf{g} \cdot \mathbf{v}
    \end{split}
  \end{equation}


\subsubsection[containsverbatim]{Example: Stokes}
  \begin{lstlisting}
    // total stress tensor (trial)
    AUTO( SigmaNt, (-idt(p)*N()+mu*gradt(u)*N()) );
    // total stress tensor (test)
    AUTO( SigmaN, (-id(p)*N()+mu*grad(v)*N()) );
    // linear form (right hand side)
    form1( Xh, F ) +=
    integrate( boundaryfaces(mesh), im,
               trans(g)*(-SigmaN+gamma*id(v)/hFace() ) );
    // bilinear form (left hand side)
    form2( Xh, Xh, D )+=
    integrate( boundaryfaces(mesh), im,
               -trans(SigmaNt)*id(v)
               -trans(SigmaN)*idt(u)
               +gamma*trans(idt(u))*id(v)/hFace() );
  \end{lstlisting}



\section{Stabilisation techniques}

\subsection{Convection dominated flows}

Consider this type of problem
\begin{equation}
  \label{notes:eq:46}
  -\epsilon \Delta u + \mathbf{c} \cdot \nabla u + \gamma u = f,\quad \nabla \cdot \mathbf{c} = 0
\end{equation}
Introduce $\mathrm{Pe}=\frac{|\mathbf{c}|h}{\epsilon}$ the \emph{Péclet}
number. The dominating convection occurs when, on at least some cells,
$\mathrm{Pe} >> 1$. We talk about singularly (i.e. $\epsilon << h$)
perturbed flows.

Without doing anything wiggles occur. There are remedies  so
called \emph{Stabilisation Methods}, here some some examples:
\begin{itemize}
\item Artificial diffusion (streamline diffusion) (SDFEM)
\item Galerkin Least Squares method (GaLS)
\item Streamline Upwind Petrov Galerkin (SUPG)
\item Continuous Interior Penalty methods (CIP)
\end{itemize}

\subsection{The CIP methods}
  Add the term
  \begin{equation}
    \label{notes:eq:47}
    \sum_{F \in \Gamma_\mathrm{int} } \int_{F} \gamma\ h_F^2\ |\mathbf{c} \cdot \mathbf{n}|\  [\nabla u]  [\nabla v]
  \end{equation}
  where $\Gamma_\mathrm{int}$ is the set of internal faces where the
  $\mathrm{Pe}>>1$ (typically it is applied to all internal faces) and
  \begin{equation}
    \label{notes:eq:50}
    [\nabla u] = \nabla u \cdot \mathbf{n}|_1 + \nabla u \cdot \mathbf{n}|_2
  \end{equation}
  is the jump of $\nabla u$(scalar valued) across the face.  In the
  case of scalar valued functions
  \begin{equation}
    \label{notes:eq:53}
    [u] = u \mathbf{n}|_1 + u \mathbf{n}|_2
  \end{equation}
  \begin{remark}[Choice for $\gamma$]
    $\gamma$ can be taken in the range $[1e-2;1e-1]$. A typical value is $2.5e-2$.
  \end{remark}


\begin{lstlisting}
    // define the stabilisation coefficient expression
    AUTO( stab_coeff , ($\gamma_\beta$ abs(trans(N())*idv(beta)))*
                        vf::pow(hFace(),2.0));

    // assemble the stabilisation operator
    form2( Xh, Xh, M ) +=
     integrate(
        // internal faces of the mesh
        internalfaces(Xh->mesh()),
        // integration method
        _Q<OrderOfPolynomialToBeIntegratedExactely>,
        // stabilisation term
        stab_coeff*(trans(jumpt(gradt(u)))*jump(grad(v))));
\end{lstlisting}

\section{Interpolation}

In order to interpolate a function defined on one domain to another domain, one
can use the \lstinline{interpolate} function. The basis function of the image
space must be of \lstinline{Lagrange} type.

\begin{lstlisting}
typedef bases<Lagrange<Order, Vectorial> > basis_type; // velocity
typedef FunctionSpace<mesh_type, basis_type, value_type> space_type;
// ...
space_ptrtype Xh = space_type::New( mesh1 );
element_type u( Xh, "u" );
space_ptrtype Yh = space_type::New( mesh2 );
element_type v( Yh, "v" );

// interpolate u on mesh2 and store the result in v
interpolate( Yh, u, v );
\end{lstlisting}

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-parse-self: t
%%% x-symbol-8bits: nil
%%% TeX-auto-regexp-list: TeX-auto-full-regexp-list
%%% TeX-master: "feel-manual"
%%% ispell-local-dictionary: "american"
%%% End:

