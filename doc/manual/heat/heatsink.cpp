/* -*- mode: c++; coding: utf-8; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; show-trailing-whitespace: t -*- vim:fenc=utf-8:ft=tcl:et:sw=4:ts=4:sts=4

  This file is part of the Feel library

  Author(s): Christophe Prud'homme <christophe.prudhomme@feelpp.org>
       Date: 2007-06-11

  Copyright (C) 2007-2012 Universit√© Joseph Fourier (Grenoble I)

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 3.0 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/

namespace Feel {

/** \page HeatSink Heat Sink
\author Christophe Prud'homme
\author Baptiste Morin
\date 2011-06-28

\tableofcontents
<br>
<hr>
<br>

This problem considers the performance of a heat sink designed for the thermal management of high-density electronic components. The heat sink is comprised of a base/spreader which in turn supports a number of plate fins exposed to flowing air. We model the flowing air through a simple convection heat transfer coefficient. From the engineering point of view, this problem illustrates the application of conduction analysis to an important class of cooling problems: electronic components and systems.
<br>
<br>
Our interest is in the conduction temperature distribution at the base of the spreader. The target is to study how the heat transfer occures with different parameters on our heat sink. The heat generated by high-density electronic components is such that it's very expensive to cool large structures (data center). The cooling optimization is consequent in the run for decreasing operating costs.

A classical thermal CPU cooler looks like this
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/complete_cooler.png</td>
</tr>
<tr>
  <td><center>Mesh of a classical CPU cooler</center></td>
</tr>
</table>
</center>

We are here going to describe how it is theorically working and how it is impleted with \feel.

\section HeatSink_Description Description
\subsection Description_Domain Domain
We consider here a classical "radiator" which is a CPU heat sink. Those types of coolers are composed with a certain number of plate fins exposed to flowing air or exposed to a ventilator. Regarding the periodicity and geometry of our concern, we can make our study on a characteristic element of the problem : a half cell of the heat sink single thermal fin with its spreader at the basis. Let's take a look at the geometry of our problem :
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/sink_geom.png</td>
</tr>
<tr>
  <td><center>Geometry of heat sink</center></td>
</tr>
</table>
</center>

Our study is avaible in 2 or 3 dimensions, depending on the application's parameters. You'll see later how to work with it. Let's see on which meshes we are working on :
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/mesh_2d.png</td>
  <td>\image html heatsink/mesh_3d.png</td>
</tr>
<tr>
  <td><center>2D mesh</center></td>
  <td><center>3D mesh</center></td>
</tr>
</table>
</center>


\subsection Description_Inputs Inputs
The implementation of thoses parameters is described in the section \ref Implementation_Parameters.<br>
\subsubsection Inputs_Material Material
Here the material parameter can be described with furthers parameters. We have, with \f$i=1\f$ for the fin and \f$i=2\f$ for the base :
\li the thermal conductivity \f$\kappa_i\f$
\li the material's density \f$\rho_i\f$
\li the heat capacity of the material \f$C_i\f$

The term \f$\rho_i C_i\f$ corresponds to the heat volumetric capacity. In that way, we make possible the construction of a heat sink with \f$2\f$ different materials. Here is a list of the well-known ones, \f$\rho\f$ and \f$C\f$ are gave at \f$298 K\f$ :
<table class="manual">
<tr><th>Material</th><th>Thermal conductivity<br>\f$\kappa$ in $W.m^{-1}.K^{-1}\f$</th><th>Density<br>\f$\rho$ in $kg.m^{-3}\f$</th><th>Heat Capacity <br>\f$C\f$ in \f$J.kg^{-1}.K^{-1}\f$</th></tr>
<tr><td>Aluminium <td></td>180 (alloys)<br> or 290 (pure) <td></td> 2700 <td></td> 897 </td></tr>
<tr><td>Copper  <td></td>386 <td></td>8940 <td></td>385 </td></tr>
<tr><td>Gold <td></td>314 <td></td>19320 <td></td>129 </td></tr>
<tr><td>Silver <td></td>406 <td></td>10500 <td></td>233 </td></tr>
</table>

\subsubsection Inputs_Physical Physical
\li Depth<br>
This parameter is only to take into account for the 3D simulation. It represents the depth of the caracteristical heat sink and is called \c depth in the application.
\li Length<br>
You can also parameterize the length of the fin. This one is called \c L in the application's parameters, its dimension is the meter.
\li Width<br>
Typically, this parameter is linked with constructor's standards. This parameter is called \c width in the application's implementation.

\subsubsection Inputs_Thermal Thermal
\li Heat flux<br>
It represents the heat flux brought by the electronic component at the bottom of the base. Here it's typically the heat brought by the processor.
\li Thermal coefficient<br>
The thermal coefficient \f$h\f$ named \f$therm_coeff\f$ in the application is representative of the heat transfer between the fin and the air flow. 
\li Ambien temperature}<br>
This parameter called \f$T_{amb}\f$ represents the temperature around the heat sink at the beginning. That means the ambient temperature before the computer is turned on.

\subsubsection Inputs_Summary Summary table
The following table displays the various fixed and variables parameters of this application.
<table class="manual">
<tr><th>Name <th></th> Description <th></th> Nominal Value <th></th> Range <th></th> Units</th></tr>
<tr><th>BDF parameters </th></tr>
<tr><td>\f$time-initial\f$ <td></td> begining <td></td> \f$0\f$ <td></td> <td></td>  </td></tr>
<tr><td>\f$time-final\f$ <td></td> end <td></td> \f$50\f$ <td></td> \f$]0, 1500]\f$ <td></td>   </td></tr>
<tr><td>\f$time-step\f$ <td></td> time step <td></td> \f$0.1\f$ <td></td> \f$]0,1[\f$ <td></td>   </td></tr>
<tr><td>\f$steady\f$ <td></td> steady state <td></td> \f$0\f$ <td></td> \f$\{0,1\}\f$ <td></td>   </td></tr>
<tr><td>\f$order\f$ <td></td> order <td></td> \f$2\f$ <td></td> \f$[0, 4]\f$ <td></td>  </td></tr>
<tr><th>Physical parameters </th></tr>
<tr><td>\f$L\f$ <td></td> fin's length <td></td> \f$2\cdot 10^{-2}\f$ <td></td> \f$[0.02, 0.05]\f$ <td></td> \f$m\f$ </td></tr>
<tr><td>\f$width\f$ <td></td> fin's width <td></td> \f$5\cdot 10^{-4}\f$ <td></td> \f$[10^{-5}, 10^{-4}]\f$ <td></td> \f$m\f$ </td></tr>
<tr><td>\f$deep\f$ <td></td> heat sink depth <td></td> \f$0\f$ <td></td> \f$[0, 7\cdot 10^{-2}]\f$ <td></td> \f$m\f$ </td></tr>
<tr><th>Mesh parameter </th></tr>
<tr><td>\f$hsize\f$ <td></td> mesh's size <td></td> \f$10^{-4}\f$ <td></td> \f$[10^{-5},10^{-3} ]\f$ <td></td> </td></tr>
<tr><th>Fin Parameters </th></tr>
<tr><td>\f$\kappa_f\f$ <td></td> thermal conductivity <td></td> \f$386\f$ <td></td> \f$[100,500]\f$ <td></td> \f$W \cdot m^{-1} \cdot K^{-1}\f$</td></tr>
<tr><td>\f$\rho_f\f$ <td></td> material density <td></td> \f$8940\f$ <td></td> \f$[10^3,12\cdot 10^3 ]\f$ <td></td> \f$kg\cdot m^{-3}\f$</td></tr>
<tr><td>\f$C_f\f$ <td></td> heat capacity <td></td> \f$385\f$ <td></td> \f$[10^2,10^3]\f$ <td></td> \f$J\cdot kg^{-1} \cdot K^{-1}\f$</td></tr>
<tr><th>Base/spreader Parameters </th></tr>
<tr><td>\f$\kappa_s\f$ <td></td> thermal conductivity <td></td> \f$386\f$ <td></td> \f$[100,500]\f$ <td></td> \f$W \cdot m^{-1} \cdot K^{-1}\f$</td></tr>
<tr><td>\f$\rho_s\f$ <td></td> material density <td></td> \f$8940\f$ <td></td> \f$[10^3,12\cdot 10^3 ]\f$ <td></td> \f$kg\cdot m^{-3}\f$</td></tr>
<tr><td>\f$C_s\f$ <td></td> heat capacity <td></td> \f$385\f$ <td></td> \f$[10^2,10^3]\f$ <td></td> \f$J\cdot kg^{-1} \cdot K^{-1}\f$</td></tr>
<tr><th>Heat Parameters </th></tr>
<tr><td>\f$T_{amb}\f$ <td></td> ambient temperature <td></td> \f$300\f$ <td></td> \f$[300,310]\f$ <td></td> \f$K\f$ </td></tr>
<tr><td>\f$heat\_flux\f$ <td></td> heat flux \f$Q\f$ <td></td> \f$10^6\f$ <td></td> \f$[0 ,10^{6}]\f$ <td></td> \f$W \cdot m^{-3}\f$</td></tr>
<tr><td>\f$therm\_coeff\f$ <td></td> thermal coefficient \f$h\f$ <td></td> \f$10^3\f$ <td></td> \f$[0,10^3]\f$ <td></td> \f$W\cdot m^{-2} \cdot K^{-1}\f$ </td></tr>
</table>

\section HeatSink_Theory Theory
\subsection Theory_Figure Figure
The global domain is \f$\varOmega = \varOmega_1 \cup \varOmega_2 \f$ where \f$\varOmega_1\f$ is the fin's domain and \f$\varOmega_2\f$ the spreader's domain. We note \f$\partial\varOmega\f$ the border of the domain \f$\varOmega\f$. The physical lines we are using will be noted as \f$\Gamma_i\f$ such as described above. The following figure describes the parameters and the geometry we are using in the equations to solve our 3D issue :
The following figures describe the parameters and the geometry we are using in the equations to solve our 2D or 3D issue :
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/figure_2d.png</td>
  <td>\image html heatsink/figure_3d.png</td>
</tr>
<tr>
  <td><center>2D geometry details</center></td>
  <td><center>3D geometry details</center></td>
</tr>
</table>
</center>

\subsection Theory_Equations Equations
Our concern satisfies the heat equation which reads
\f{eqnarray}
\sum_{i=1}^{2} \kappa_i \Delta T - \rho_i C_i \frac{ \partial T}{\partial t} & =& 0& \\
\kappa_1 \frac{\partial T}{\partial n} &= & 0 & \text{on }  \Gamma_2 \text{ and }  \Gamma_6\quad\quad \\
\kappa_2 \frac{\partial T}{\partial n} &= & 0 & \text{on } \Gamma_5 , \Gamma_7 \text{ and }  \Gamma_8\quad\quad \\
\kappa_1 \frac{\partial T}{\partial n} &= &- h( T - T_{amb}) & \text{on } \Gamma_1\quad\quad \\
\kappa_2 \frac{\partial T}{\partial n} &= & Q(1-e^{-t}) & \text{on } \Gamma_4\quad\quad \\
T_{|\varOmega_1} &= &T_{| \varOmega_2} & \text{on } \Gamma_3\quad\quad \\
\kappa_1 \nabla T \cdot n &=& \kappa_2 \nabla T \cdot n & \text{on } \Gamma_3\quad\quad
\f}
with \f$i=1\f$ for the fin and \f$i=2\f$ for the base and where \f$\kappa_i\f$ is the thermal conductivity, \f$\rho_i\f$ is the material's density (\f$kg.m^{-3}\f$ in the SI unit), \f$C_i\f$ the heat capacity and \f$T\f$ the temperature at a precise point (in 2D or 3D). To see how it has been coded, you can read \ref Implemtation .


\subsection Theory_Boundary Boundary Conditions
The problem requieres that the temperature and heat flux are continute on \f$\Gamma_3\f$. Considering the problem's geometry, we also impose zero heat flux on the vertical surfaces of the spreader. Let's detail the conditions we have imposed :
\li Homogeneous Neumann condition ( \f$(2)\f$ ) and ( \f$(3)\f$ ) : it represents the fact that the heat flux is only vertical (for \f$\Gamma_6\f$ and \f$\Gamma_7\f$) or the fact that the heat flux is only provided by \f$\Gamma_4\f$ (for \f$\Gamma_2\f$ and \f$\Gamma_5\f$).
\li Homogeneous Neumann condition ( \f$(4)\f$ ) : it imposes that the heat flux is brought by this surface (it mathematically represents that the heat sink is placed on the heat source).
\li Non-homogeneous Neumann condition ( \f$(5)\f$ ) :  this boundary condition represents the transient state for the heat transfer calculation.
\li Temperature continuity ( \f$(6)\f$ ) : it imposes that the temperature is continute at the interface between the two materials (if there are two materials, we can also have the same one for the two pieces).
\li Heat flux continuity ( \f$(7)\f$ ) : it represents that the heat flux is continute at the interface between the two materials. Literally, it means that the two flows offset each other.

Theses conditions have been coded as explained in the section \ref Implementation_Equations.

\subsection Theory_FEM Finite Element Method
Let's apply the method to our concern, we introduce the test function \f$v\f$ and we integrate the main equation, which reads now as :
\f{equation*}
\sum_{i=1}^{2} \rho_i C_i \int_{\varOmega_i} v\frac{ \partial T}{\partial t} - \kappa_i \int_{\varOmega_i} v\Delta T   & = 0
\f}
We integrate by parts, which leads to :
\f{equation*}
\sum_{i=1}^{2} \rho_i C_i \int_{\varOmega_i} v\frac{ \partial T}{\partial t} +  \kappa_i \int_{\varOmega_i} {\nabla v \cdot \nabla T} - \kappa_i \int_{\partial \varOmega_i} {(\nabla T \cdot n) v}   & = 0
\f}
then, by decomposing the borders \f$\partial\varOmega_i\f$, we obtain :
\f{multline*}
\displaystyle{- \kappa_1 \int_{\Gamma_1}{(\nabla T \cdot n) v} - \kappa_2 \int_{\Gamma_4} {(\nabla T \cdot n) v} - \kappa_1 \int_{\Gamma_{2,6}}{(\nabla T \cdot n) v}  - \kappa_2 \int_{\Gamma_{5,7,8}}{(\nabla T \cdot n) v} } \quad + \\ \displaystyle{ \sum_{i=1}^{2}  \rho_i C_i \int_{\varOmega_i} v\frac{ \partial T}{\partial t} + \kappa_i \int_{\varOmega_i} {\nabla v \cdot \nabla T} - \kappa_i \int_{\partial\varOmega_i \cap \Gamma_3}{(\nabla T \cdot n) v}  } =   0
\f}
Now, we apply the conditions \f$(2)\f$, \f$(3)\f$, \f$(4)\f$ and \f$(5)\f$ which brings us to :
\f{equation*}
\int_{\Gamma_1}{hv(T-T_{amb})} - \int_{\Gamma_4} {vQ(1-e^{-t})} + \sum_{i=1}^{2}  \rho_i C_i \int_{\varOmega_i} v\frac{ \partial T}{\partial t} + \kappa_i \int_{\varOmega_i} {\nabla v \cdot \nabla T}  - \underbrace{\kappa_i \int_{\partial\varOmega_i \cap \Gamma_3}{(\nabla T \cdot n) v}}_{\text{=0}}   & =   0
\f}
Now we apply the boundary conditions ( \f$(7)\f$ ) which results in :
\f{equation*}
   \begin{split}
 \displaystyle{ h \int_{\Gamma_1}{v(T-T_{amb})} - \int_{\Gamma_4} {vQ(1-e^{-t})}  + \sum_{i=1}^{2} \rho_i C_i \int_{\varOmega_i} v\frac{ \partial T}{\partial t} + \kappa_i \int_{\varOmega_i} {\nabla v \cdot \nabla T} } & =   0
  \end{split}
\f}
We can now start to transform the equation by puting in the right hand the known terms :
\f{equation*}
   \begin{split}
 \displaystyle{ h \int_{\Gamma_1}{v T}  + \sum_{i=1}^{2} \rho_i C_i \int_{\varOmega_i} v\frac{ \partial T}{\partial t} + \kappa_i \int_{\varOmega_i} {\nabla v \cdot \nabla T} } & =
 \int_{\Gamma_4} {vQ(1-e^{-t})}	 +  hT_{amb}\int_{\Gamma_1}{v}
  \end{split}
\f}
We discretize \f$\displaystyle{\frac{\partial T}{\partial t}}\f$ where \f$\delta t\f$ is the time step, such as:
\f{equation*}
   \begin{split}
 \displaystyle{ h \int_{\Gamma_1}{v T} + \sum_{i=1}^{2} \rho_i C_i \int_{\varOmega_i} v\frac{T^{n+1} - T^n}{\delta t} + \kappa_i \int_{\varOmega_i} {\nabla v \cdot \nabla T} } & =
 \int_{\Gamma_4} {vQ(1-e^{-t})}	 +  hT_{amb}\int_{\Gamma_1}{v}
  \end{split}
\f}
Finally we obtain :
\f{equation*}
\color{red}
   \begin{split}
 \displaystyle{ h \int_{\Gamma_1}{v T} + \sum_{i=1}^{2} \rho_i C_i \int_{\varOmega_i} v\frac{T^{n+1}}{\delta t} + \kappa_i \int_{\varOmega_i} {\nabla v \cdot \nabla T}} & =  
	\displaystyle{ \int_{\Gamma_4} {vQ(1-e^{-t})} +  hT_{amb}\int_{\Gamma_1}{v}	+  \sum_{i=1}^{2}  \rho_i C_i \int_{\varOmega_i} v \frac{T^n}{\delta t}  }
  \end{split}
\f}
This is that equation which is implemented in the application \c feel_heatsink.


\section HeatSink_Implementation Implementation
\subsection Implementation_Parameters Application Parameters
The parameters of the application are implemented such as
\snippet heatsink.cpp marker1


\subsection Implementation_Surfaces Surfaces
To be able to calculate the surfaces in further dimension without changing the code, we have given the same names for the faces we were interested in. In 2D \f$\Gamma_i\f$ represents a line whereas in 3D it represents a surface. The calculation of those surfaces which makes possible the calculation of averages temperature is as follow :
\snippet heatsink.cpp marker2

\subsection Implementation_Equations Equations
First we start by calculate the non-steady state which means that we integrate all the time-independant terms, which is done with :
\snippet heatsink.cpp marker3

Then, to compute the transient state, which means time dependant terms, you have to initialize the temperature (which is initialized as \f$T_{amb}\f$ on \f$X_h\f$ space) and create a new vector \f$F_t\f$ which corresponds to the time dependent term. The code is as follow :
\snippet heatsink.cpp marker4


\section HeatSink_Results Results
As you can see in the equation's implementation above, there are two ouputs :
\li \c Gmsh format : this file contains the entire mesh and the temperatures associated to each degrees of freedom of the mesh. To open it, you juste have to do as you always do with \c Gmsh : \c gmsh heatsink-1_0.msh. You will obtain the figure with the different temperatures, you are now able to click on "play" with its significative logo and admire the evolution
\li \c averages file : this file is completed at each time step, each line contains the current time, the average temperature on \f$\Gamma_4\f$ (surface where is the contact between the heat sink and the heat source) and the average temperature on \f$\Gamma_1\f$. To analyze this file, we recommend you to work with \c Octave  which is an open-source software similar to \c Matlab.<br>
If it is installed, open a command line and go to
\verbatim
~/feel/heatsink/Simplex_'.'.'/0.000'/
\endverbatim
 and try :
\verbatim
> octave
octave:1> M=load('averages');
octave:2> plot(M(:,1),M(:,2))
octave:3> plot(M(:,1),M(:,3))
octave:4> plot(M(1:70,1),M(1:70,2))
octave:5> plot(M(1:70,1),M(1:70,3))
\endverbatim
The \f$ 4^{th}\f$ and \f$ 5^{th}\f$ lines are here to observe the transient state.


\subsection Results_How How to use it ?
To make easier the use of this application, we recommand you to use the configurations files. This is the fastest way : to do it, you juste have to create the file \c heatsink.cfg and place it in the same directory that your application's executable. <br>
We have created \f$3\f$ typical \c cfg files such as :
\co
# file heatsink_1.cfg
# spreader and fin in copper
# 2D simulation
hsize=1e-4
                                             
kappa_s=386 # W/m/K
c_s=385
rho_s=8940
                                             
kappa_f=386 # W/m/K
c_f=385 #J/kg/K
rho_f=8940
                                             
L=15e-3
width=5e-4
                                             
therm_coeff=1000  #W/(m2K)
heat_flux=1e6
                                             
[bdf]
order=2
time-step=0.05
time-final=100
steady=0
                                             
[exporter]
format=gmsh
\eco

\co
# file heatsink_3.cfg
# spreader in copper
# fin in aluminium
# 3D simulation
hsize=3e-4
kappa_s=386 # W/m/K
c_s=385
rho_s=8940
                                                 
kappa_f=386 # W/m/K
c_f=385 #J/kg/K
ho_f=8940
                                                 
L=15e-3
width=5e-4
deep=4e-2
                                                 
therm_coeff=1000  #W/(m2K)
heat_flux=1e6
                                                 
[bdf]
order=2
time-step=0.05
time-final=100
steady=0
                                                 
[exporter]
format=gmsh
\eco

This file is the only modification you will have to bring to the application, in that way you won't have to compile each time the files (except for \c heatsink.cpp if you want to increase the order and/or the dimension, in that case you'ill have to modify this parameter at then end of the file in the \c main method).

\subsection Results_Figures Figures
\subsubsection Results_2D 2D cases
Here are some results of the 2D simulations considering different configurations files. The figures have been extracted thanks to \c Gmsh and \c Octave :
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/heatsink_1.png</td>
</tr>
<tr>
  <td><center>\c heatsink_1.cfg : steady state, spreader and fin in copper, \f$Q=1e6\f$ and \f$h=1e3\f$</center></td>
</tr>
</table>
</center>
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/heatsink_1_gamma4.png</td>
  <td>\image html heatsink/heatsink_1_gamma1.png</td>
</tr>
<tr>
  <td><center>\c heatsink_1.cfg : transient state on \f$\Gamma_4\f$</center></td>
  <td><center>\c heatsink_1.cfg : transient state on \f$\Gamma_1\f$</center></td>
</tr>
</table>
</center>

\subsubsection Results_3D 3D cases
Here is the result of 3D simulations considering the following configurations :
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/heatsink_3.png</td>
</tr>
<tr>
  <td><center>\c heatsink_3.cfg : spreader and fin in copper, \f$Q=1e6\f$ and \f$h=1e3\f$</center></td>
</tr>
</table>
</center>
<center>
<table border=0px>
<tr>
  <td>\image html heatsink/heatsink_3_gamma4.png</td>
  <td>\image html heatsink/heatsink_3_gamma1.png</td>
</tr>
<tr>
  <td><center>\c heatsink_3.cfg : transient state on \f$\Gamma_4\f$</center></td>
  <td><center>\c heatsink_3.cfg : transient state on \f$\Gamma_1\f$</center></td>
</tr>
</table>
</center>


*/

}


#include <feel/feel.hpp>

Feel::gmsh_ptrtype makefin( double hsize, double width, double deep , double L );


/// [marker1]
inline
Feel::po::options_description
makeOptions()
{
    Feel::po::options_description heatsinkoptions( "heatsink options" );
    heatsinkoptions.add_options()
    // mesh parameters
    ( "hsize", Feel::po::value<double>()->default_value( 0.0001 ),
      "first h value to start convergence" )
    ( "L", Feel::po::value<double>()->default_value( 0.02 ),
      "dimensional length of the sink (in meters)" )
    ( "width", Feel::po::value<double>()->default_value( 0.0005 ),
      "dimensional width of the fin (in meters)" )

    // 3D parameter
    ( "deep", Feel::po::value<double>()->default_value( 0 ),
      "depth of the mesh (in meters) only in 3D simulation" )

    // thermal conductivities parameters
    ( "kappa_s", Feel::po::value<double>()->default_value( 386 ),
      "thermal conductivity of the base spreader in SI unit W.m^{-1}.K^{-1}" )
    ( "kappa_f", Feel::po::value<double>()->default_value( 386 ),
      "thermal conductivity of the fin in SI unit W.m^{-1}.K^{-1}" )

    // density parameter
    ( "rho_s", Feel::po::value<int>()->default_value( 8940 ),
      "density of the spreader's material in SI unit kg.m^{-3}" )
    ( "rho_f", Feel::po::value<int>()->default_value( 8940 ),
      "density of the fin's material in SI unit kg.m^{-3}" )

    // heat capacities parameter
    ( "c_s", Feel::po::value<double>()->default_value( 385 ),
      "heat capacity of the spreader's material in SI unit J.kg^{-1}.K^{-1}" )
    ( "c_f", Feel::po::value<double>()->default_value( 385 ),
      "heat capacity of the fin's material in SI unit J.kg^{-1}.K^{-1}" )

    // physical coeff
    ( "therm_coeff", Feel::po::value<double>()->default_value( 1e3 ),
      "thermal coefficient" )
    ( "Tamb", Feel::po::value<double>()->default_value( 300 ),
      "ambiant temperature" )
    ( "heat_flux", Feel::po::value<double>()->default_value( 1e6 ),
      "heat flux generated by CPU" )

    ( "steady", Feel::po::value<bool>()->default_value( false ),
      "if true : steady else unsteady" )

    // export
    ( "export-matlab", "export matrix and vectors in matlab" );

    return heatsinkoptions.add( Feel::feel_options() );
}
/// [marker1]

inline
Feel::AboutData
makeAbout()
{
    Feel::AboutData about( "heatsink" ,
                           "heatsink" ,
                           "0.1",
                           "nD(n=1,2,3) Heat sink thermal fin on simplices or simplex products",
                           Feel::AboutData::License_GPL,
                           "Copyright (c) 2006-2011 Universite Joseph Fourier" );

    about.addAuthor( "Christophe Prud'homme", "developer", "christophe.prudhomme@feelpp.org", "" );
    about.addAuthor( "Baptiste Morin", "junior developer", "baptistemorin@gmail.com","" );
    return about;
}


namespace Feel
{
/**
 * Heat sink application
 */
template<int Dim, int Order>
class HeatSink
    :
public Application
{
    typedef Application super;
public:

#define Entity Simplex

    // -- TYPEDEFS --
    typedef double value_type;

    typedef Backend<value_type> backend_type;
    typedef boost::shared_ptr<backend_type> backend_ptrtype;

    /*matrix*/
    typedef backend_type::sparse_matrix_type sparse_matrix_type;
    typedef backend_type::sparse_matrix_ptrtype sparse_matrix_ptrtype;
    typedef backend_type::vector_type vector_type;
    typedef backend_type::vector_ptrtype vector_ptrtype;

    /*mesh*/
    typedef Entity<Dim> entity_type;
    typedef Mesh<entity_type> mesh_type;
    typedef boost::shared_ptr<mesh_type> mesh_ptrtype;

    typedef FunctionSpace<mesh_type, bases<Lagrange<0, Scalar> >, Discontinuous > p0_space_type;
    typedef typename p0_space_type::element_type p0_element_type;

    /*basis*/
    typedef bases<Lagrange<Order, Scalar> > basis_type;

    /*space*/
    typedef FunctionSpace<mesh_type, basis_type, value_type> space_type;
    typedef boost::shared_ptr<space_type> space_ptrtype;
    typedef typename space_type::element_type element_type;

    /* BDF discretization */
    typedef Bdf<space_type>  bdf_type;
    typedef boost::shared_ptr<bdf_type> bdf_ptrtype;

    /* export */
    typedef Exporter<mesh_type> export_type;

    /* constructor */
    HeatSink();

    /* run the simulation */
    void run();

private:

    /**
     * export results to ensight format
     */
    void exportResults( double time, element_type& u );

private:

    backend_ptrtype M_backend;

    /* mesh parameters */
    double meshSize;
    double depth;
    double L;
    double width;

    /* thermal conductivities */
    double kappa_s;
    double kappa_f;

    /* density of the materials */
    int rho_s;
    int rho_f;

    /* heat capacity of the materials*/
    double c_s;
    double c_f;

    /* thermal coeff */
    double therm_coeff;

    /* ambien temperature, and heat flux (Q) */
    double Tamb;
    double heat_flux;

    /* surfaces*/
    double surface_base, surface_fin;

    /* mesh, pointers and spaces */
    mesh_ptrtype mesh;
    space_ptrtype Xh;

    sparse_matrix_ptrtype D;
    vector_ptrtype F;

    /* time management */
    bdf_ptrtype M_bdf;
    bool steady;

    // average file
    std::ofstream out;
    double Tavg, Tgamma1;
    boost::shared_ptr<export_type> M_exporter;

}; // HeatSink class

/* Constructor */
template<int Dim, int Order>
HeatSink<Dim,Order>::HeatSink()
    :
    super(),
    M_backend( backend_type::build( this->vm() ) ),
    meshSize( this->vm()["hsize"].template as<double>() ),
    depth( this->vm()["deep"].template as<double>() ),
    L( this->vm()["L"].template as<double>() ),
    width( this->vm()["width"].template as <double>() ),
    kappa_s( this-> vm()["kappa_s"].template as<double>() ),
    kappa_f( this-> vm()["kappa_f"].template as<double>() ),
    rho_s( this-> vm()["rho_s"].template as<int>() ),
    rho_f( this-> vm()["rho_f"].template as<int>() ),
    c_s( this-> vm()["c_s"].template as<double>() ),
    c_f( this-> vm()["c_f"].template as<double>() ),
    therm_coeff( this-> vm()["therm_coeff"].template as <double>() ),
    Tamb( this-> vm()["Tamb"].template as <double>() ),
    heat_flux( this-> vm()["heat_flux"].template as <double>() ),
    steady( this->vm()["steady"].template as<bool>() ),
    M_exporter()
{
    this->changeRepository( boost::format( "%1%/%2%/%3%/" )
                            % this->about().appName()
                            % entity_type::name()
                            % this->vm()["hsize"].template as<double>()
                          );
    using namespace Feel::vf;

    /*
     * First we create the mesh
     */
    mesh = createGMSHMesh ( _mesh = new mesh_type,
                            _desc = makefin( meshSize, width, depth , L ) );
    // build exporter
    M_exporter = exporter( _mesh=mesh );

    /// [marker2]
    /*
     * Calculate the two surfaces used for averages calculation
     */
    surface_base = integrate( _range= markedfaces( mesh, "gamma4" ), _expr= cst( 1. ) ).evaluate()( 0,0 );
    surface_fin = integrate( _range= markedfaces( mesh,"gamma1" ), _expr=cst( 1. ) ).evaluate()( 0,0 );
    /// [marker2]

    /*
     * The function space associated to the mesh
     */
    Xh = space_type::New( mesh );
    M_bdf = bdf( _space=Xh, _name="Temperature" );

    /*
     * Right hand side
     */
    F = M_backend->newVector( Xh );

    /*
     * Left hand side
     */
    D = M_backend->newMatrix( Xh, Xh );

}



template<int Dim, int Order>
void
HeatSink<Dim, Order>::run()
{
    if ( this->vm().count( "help" ) )
    {
        std::cout << this->optionsDescription() << "\n";
        return;
    }

    using namespace Feel::vf;

    LOG(INFO) << "meshSize = " << meshSize << "\n"
          << "L = "<< L <<"\n"
          << "width = " << width << "\n"
          << "depth = " << depth << "\n"
          << "kappa_spreader = " << kappa_s << "\n"
          << "kappa_fin = " << kappa_f << "\n"
          << "rho_spreader = " << rho_s << "\n"
          << "rho_fin = " << rho_f << "\n"
          << "heat capacity of the base = " << c_s << "\n"
          << "heat capacity of the fin = " << c_f << "\n"
          << "ambient temperature = " << Tamb << "\n"
          << "thermal coefficient = " << therm_coeff << "\n"
          << "heat flux Q = " << heat_flux << "\n"
          << "steady state = " << steady << "\n";

    /*
     * T is the unknown, v the test function
     */
    element_type T( Xh, "T" );
    element_type v( Xh, "v" );

    /// [marker3]
    /*
     * Right hand side construction (steady state)
     */
    form1( _test=Xh, _vector=F, _init=true ) = integrate( _range= markedfaces( mesh, "gamma1" ), _expr= therm_coeff*Tamb*id( v ) );

    /*
     * Left hand side construction (steady state)
     */
    form2( Xh, Xh, D, _init=true ) = integrate( _range= markedelements( mesh,"spreader_mesh" ), _expr= kappa_s*gradt( T )*trans( grad( v ) ) );
    form2( Xh, Xh, D ) += integrate( _range= markedelements( mesh,"fin_mesh" ), _expr= kappa_f*gradt( T )*trans( grad( v ) ) );
    form2 ( Xh, Xh, D ) += integrate( _range= markedfaces( mesh, "gamma1" ), _expr= therm_coeff*idt( T )*id( v ) );

    M_bdf->start();

    //from now if the option "steady" is set to true then M_bdf->setSteady will set time-step=time-final=1e30
    if ( steady )
    {
        M_bdf->setSteady();
    }

    form2( Xh, Xh, D ) +=
        integrate( _range=markedelements( mesh, "spreader_mesh" ), _expr=rho_s*c_s*idt( T )*id( v )*M_bdf->polyDerivCoefficient( 0 ) )
        + integrate( _range=markedelements( mesh, "fin_mesh" ), _expr=rho_f*c_f*idt( T )*id( v )*M_bdf->polyDerivCoefficient( 0 ) );
    /// [marker3]
    D->close();


    /*
     * Left and right hand sides construction (non-steady state) with BDF
     */
    T = vf::project( _space=Xh, _expr=cst( Tamb ) );

    M_bdf->initialize( T );
    this->exportResults( M_bdf->timeInitial(), T );

    std::cout << "The step is : " << M_bdf->timeStep() << "\n"
              << "The initial time is : " << M_bdf->timeInitial() << "\n"
              << "The final time is  : " << M_bdf->timeFinal() << "\n";

    // average file which contains: time Tavg_base Tavg_gamma1
    out.open( "averages", std::ios::out );
    auto Ft = M_backend->newVector( Xh );

    /// [marker4]
    for ( M_bdf->start(); M_bdf->isFinished()==false; M_bdf->next() )
    {
        // update right hand side with time dependent terms
        auto bdf_poly = M_bdf->polyDeriv();
        form1( _test=Xh, _vector=Ft ) =
            integrate( _range=markedelements( mesh, "spreader_mesh" ), _expr=rho_s*c_s*idv( bdf_poly )*id( v ) ) +
            integrate( _range=markedelements( mesh, "fin_mesh" ), _expr=rho_f*c_f*idv( bdf_poly )*id( v ) );
        form1( _test=Xh, _vector=Ft ) +=
            integrate( _range= markedfaces( mesh,"gamma4" ), _expr= heat_flux*( 1-math::exp( -M_bdf->time() ) )*id( v ) );

        // add contrib from time independent terms
        Ft->add( 1., F );

        M_backend->solve( _matrix=D, _solution=T, _rhs=Ft );

        Tavg = integrate( _range=markedfaces( mesh,"gamma4" ), _expr=( 1/surface_base )*idv( T ) ).evaluate()( 0,0 );
        Tgamma1 = integrate( _range=markedfaces( mesh,"gamma1" ), _expr=( 1/surface_fin )*idv( T ) ).evaluate()( 0,0 );

        // export results
        out << M_bdf->time() << " " << Tavg << " " << Tgamma1 << "\n";
        this->exportResults( M_bdf->time(), T );

    }
    /// [marker4]

    std::cout << "Resolution ended, export done \n";

} // HeatSink::run


template<int Dim, int Order>
void
HeatSink<Dim, Order>::exportResults( double time, element_type& U )
{
    if ( this->vm().count( "export" ) )
    {
        //M_exporter->step( time )->addRegions();
        M_exporter->step( time )->add( "Temperature", U );
        M_exporter->save();
    }
} // HeatSink::exportResults

} // Feel


int
main( int argc, char** argv )
{
    using namespace Feel;
    Environment env( _argc=argc, _argv=argv,
                     _desc=makeOptions(),
                     _about=makeAbout() );

    /* Parameters to be changed */
    const int nDim = 2;
    const int nOrder = 2;

    /* define application */
    typedef Feel::HeatSink<nDim, nOrder> heat_sink_type;

    /* instanciate */
    heat_sink_type heatsink;

    /* run */
    heatsink.run();
}





