namespace Life
{
/*! \page CreatingApplications Creating applications
    \ingroup Tutorial

\section ApplicationOptions Application and Options

As a Life user, the first step in order to use Life is to create an
application. First we include the <tt>Application</tt> header file,
<tt>life/lifecore/application.hpp</tt> and the header which the internal Life
options. Life uses the <tt>boost::program_options</tt> ( see <a
href="http://www.boost.org/doc/html/program_options.html">Boost Program
Options</a> ) library from Boost to handle its command line options

\dontinclude myapp.cpp
\skip marker1
\until endmarker1

Next to ease the programming and reading, we use the <tt>using</tt>
C++ directive to bring the namespace Life to the current namespace

\code
  using namespace Life;
\endcode

Then we define the command line options that the applications will
provide. Note that on the <tt>return</tt> line, we incorporate the
options defined internally in Life.

\skip marker2
\until endmarker2

In the example, we provide the options <tt>dt</tt> which takes an
argument, a <tt>double</tt> and its default value is <tt>1</tt>
if the options is not set by the command line.

Then we describe the application by defining a class
<tt>AboutData</tt> which will be typically used by the
<tt>help</tt> command line options to describe the application

\skip marker3
\until endmarker3

Now we turn to the class <tt>MyApp</tt> itself: it derives from
<tt>Life::Application</tt>. Two constructors take <tt>argc</tt>,
<tt>argv</tt> and the <tt>AboutData</tt> as well as possibly the
description of the command line options <tt>Life::po::option_description</tt>.

The class <tt>MyApp</tt> must redefine the <tt>run()</tt> member
function. It is defined as a pure virtual function in
<tt>Application</tt>.

\skip marker4
\until endmarker4

The implementation of the constructors is usually simple, we pass the
arguments to the super class <tt>Application</tt> that will analyze
them and subsequently provide them with a
<tt>Life::po::variable_map</tt> data structure which operates like
a <tt>map</tt>. Have a look at the document
<tt>boost::program_options</tt> for further details.

\skip marker5
\until endmarker5

The <tt>MyApp::run()</tt> member function holds the application
commands/statements. Here we provide the smallest code unit: we print
the description of the application if the <tt>--help</tt> command
line options is set.

\dontinclude myapp.cpp
\skip marker6
\until endmarker6


Finally the <tt>main()</tt> function can be implemented. We pass
the results of the <tt>makeAbout()</tt> and
<tt>makeOptions()</tt> to the constructor of <tt>MyApp</tt> as
well as <tt>argc</tt> and <tt>argv</tt>. Then we call the
<tt>MyApp::run()</tt> member function to execute the application.

\skip marker7
\until endmarker7

Here is the full code
\include myapp.cpp

The next step is to compile it and execute it
\verbatim
make life_doc_myapp
./life_doc_myapp
\endverbatim

The output should be

\include myapp-1.0

\section ApplicationLoggingArchiving Application, Logging and Archiving

Life provides some basic logging and archiving support: using the
<tt>Application::changeRepository</tt> member functions of the class
<tt>Application</tt>, the logfile and results of the application
will be stored in a subdirectory of <tt>~/life</tt>. For
example the following code

\skip marker8
\until endmarker8


will create the directory <tt>~/life/myapp</tt> and will store the
logfile and any files created after calling
<tt>changeRepository</tt>. Refer to the documentation of
<tt>Boost::format</tt> of further details about the arguments to be
passed to <tt>Application::changeRepository</tt>. The logfile is named
<tt>~/life/myapp/myapp-1.0</tt>. The name of the logfile is built
using the application name, here <tt>myapp</tt>, the number of
processes, here 1 and the id of the current process, here 0.

\include myapp-1.0

\section ParallelApplication Parallel Application

Life relies on MPI for parallel computations and the class
<tt>Application</tt>  initialises the MPI environment.

\section PetscTrilinos Initializing PETSc and Trilinos

Life supports also the PETSc and Trilinos framework, the class takes care of
 initialize the associated environments.

*/
}
