<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Feel++: Feel::MatrixSparse&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="feel_logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Feel++
   &#160;<span id="projectnumber">0.109.0-alpha.1</span>
   </div>
   <div id="projectbrief">Finite Element Embedded Library in C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classFeel_1_1MatrixSparse.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#friends">Friends</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classFeel_1_1MatrixSparse-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Feel::MatrixSparse&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class Feel::MatrixSparse&lt; T &gt;</h3>

<p>Generic sparse matrix. </p>
<p>This class contains pure virtual members that must be overloaded in derived classes. Using a derived class allows for uniform access to sparse matrices from various different solver packages in different formats.</p>
<dl class="section author"><dt>Author</dt><dd>Benjamin S. Kirk, 2003 </dd>
<dd>
Christophe Prud'homme, 2005 </dd></dl>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Feel::MatrixSparse&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classFeel_1_1MatrixSparse.png" usemap="#Feel::MatrixSparse_3C_20T_20_3E_map" alt=""/>
  <map id="Feel::MatrixSparse_3C_20T_20_3E_map" name="Feel::MatrixSparse_3C_20T_20_3E_map">
<area href="classFeel_1_1MatrixEigenDense.html" title="interface to eigen sparse matrix" alt="Feel::MatrixEigenDense&lt; T &gt;" shape="rect" coords="0,56,181,80"/>
<area href="classFeel_1_1MatrixEigenSparse.html" title="interface to eigen sparse matrix" alt="Feel::MatrixEigenSparse&lt; T &gt;" shape="rect" coords="191,56,372,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af154a6d470908d4e78f71af90892b566"><td class="memTemplParams" colspan="2"><a id="af154a6d470908d4e78f71af90892b566"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:af154a6d470908d4e78f71af90892b566"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#af154a6d470908d4e78f71af90892b566">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; U &gt; &amp;m)</td></tr>
<tr class="memdesc:af154a6d470908d4e78f71af90892b566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the print method above, but allows you to print to a stream in the standard syntax. <br /></td></tr>
<tr class="separator:af154a6d470908d4e78f71af90892b566"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a398dc2f164f0ddd63a8aa6f2b415fad5"><td class="memItemLeft" align="right" valign="top"><a id="a398dc2f164f0ddd63a8aa6f2b415fad5"></a>
typedef std::shared_ptr&lt; <a class="el" href="classFeel_1_1DataMap.html">datamap_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>datamap_ptrtype</b></td></tr>
<tr class="separator:a398dc2f164f0ddd63a8aa6f2b415fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d56e040603726dfb50df50e7537025"><td class="memItemLeft" align="right" valign="top"><a id="ae5d56e040603726dfb50df50e7537025"></a>
typedef <a class="el" href="classFeel_1_1DataMap.html">DataMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>datamap_type</b></td></tr>
<tr class="separator:ae5d56e040603726dfb50df50e7537025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b06bd88480d0dd1962b08155f6e4e"><td class="memItemLeft" align="right" valign="top"><a id="a990b06bd88480d0dd1962b08155f6e4e"></a>
typedef std::shared_ptr&lt; <a class="el" href="classFeel_1_1GraphCSR.html">graph_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>graph_ptrtype</b></td></tr>
<tr class="separator:a990b06bd88480d0dd1962b08155f6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0ecbc0fd205e0811590a1a2d5adedb"><td class="memItemLeft" align="right" valign="top"><a id="a4f0ecbc0fd205e0811590a1a2d5adedb"></a>
typedef <a class="el" href="classFeel_1_1GraphCSR.html">GraphCSR</a>&#160;</td><td class="memItemRight" valign="bottom"><b>graph_type</b></td></tr>
<tr class="separator:a4f0ecbc0fd205e0811590a1a2d5adedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7ecf6a2df5ef12a83b0ad175d90dd7"><td class="memItemLeft" align="right" valign="top"><a id="a1d7ecf6a2df5ef12a83b0ad175d90dd7"></a>
typedef datamap_type::indexsplit_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><b>indexsplit_ptrtype</b></td></tr>
<tr class="separator:a1d7ecf6a2df5ef12a83b0ad175d90dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f56097f12edb83ecdbea67f49c95841"><td class="memItemLeft" align="right" valign="top"><a id="a8f56097f12edb83ecdbea67f49c95841"></a>
typedef <a class="el" href="classFeel_1_1IndexSplit.html">datamap_type::indexsplit_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>indexsplit_type</b></td></tr>
<tr class="separator:a8f56097f12edb83ecdbea67f49c95841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b08cb0037519828ae2b3fca9d0ab64b"><td class="memItemLeft" align="right" valign="top"><a id="a6b08cb0037519828ae2b3fca9d0ab64b"></a>
typedef <a class="el" href="structFeel_1_1type__traits.html">type_traits</a>&lt; T &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><b>real_type</b></td></tr>
<tr class="separator:a6b08cb0037519828ae2b3fca9d0ab64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb67f40bee475349653d38c4bd6a0082"><td class="memItemLeft" align="right" valign="top"><a id="adb67f40bee475349653d38c4bd6a0082"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename <a class="el" href="classSizeT.html">datamap_type::size_type</a></td></tr>
<tr class="separator:adb67f40bee475349653d38c4bd6a0082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259372c1cfeab64c88c787a0e6f66733"><td class="memItemLeft" align="right" valign="top"><a id="a259372c1cfeab64c88c787a0e6f66733"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_matrix_ptrtype</b> = std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a259372c1cfeab64c88c787a0e6f66733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad9f5880844965fbf9974594960ca8b"><td class="memItemLeft" align="right" valign="top"><a id="afad9f5880844965fbf9974594960ca8b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>super</b> = <a class="el" href="classFeel_1_1CommObject.html">CommObject</a></td></tr>
<tr class="separator:afad9f5880844965fbf9974594960ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad48603a9b89f11f28ac4e7d91aae5a6"><td class="memItemLeft" align="right" valign="top"><a id="aad48603a9b89f11f28ac4e7d91aae5a6"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:aad48603a9b89f11f28ac4e7d91aae5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6087028c6ca3951f0c48c8b48f553cb"><td class="memItemLeft" align="right" valign="top"><a id="ad6087028c6ca3951f0c48c8b48f553cb"></a>
typedef std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vector_ptrtype</b></td></tr>
<tr class="separator:ad6087028c6ca3951f0c48c8b48f553cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ae9bbda7f145ab9b7a7db6e047af93"><td class="memItemLeft" align="right" valign="top"><a id="a55ae9bbda7f145ab9b7a7db6e047af93"></a>
typedef <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vector_type</b></td></tr>
<tr class="separator:a55ae9bbda7f145ab9b7a7db6e047af93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada6dc78edf86b4f893e6942c0c9cc5e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ada6dc78edf86b4f893e6942c0c9cc5e8">add</a> (const size_type i, const size_type j, const value_type &amp;value)=0</td></tr>
<tr class="memdesc:ada6dc78edf86b4f893e6942c0c9cc5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>value</code> to the element <code></code>(i,j).  <a href="classFeel_1_1MatrixSparse.html#ada6dc78edf86b4f893e6942c0c9cc5e8">More...</a><br /></td></tr>
<tr class="separator:ada6dc78edf86b4f893e6942c0c9cc5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6758aaea35eb76187f19fe852e59f5c9"><td class="memItemLeft" align="right" valign="top"><a id="a6758aaea35eb76187f19fe852e59f5c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a6758aaea35eb76187f19fe852e59f5c9">addDiagonal</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; const &amp;vecDiag)</td></tr>
<tr class="memdesc:a6758aaea35eb76187f19fe852e59f5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add diagonal entries from vector vecDiag <br /></td></tr>
<tr class="separator:a6758aaea35eb76187f19fe852e59f5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97edf38d012379d8e8f3f4196af47648"><td class="memItemLeft" align="right" valign="top"><a id="a97edf38d012379d8e8f3f4196af47648"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a97edf38d012379d8e8f3f4196af47648">addDiagonal</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;vecDiag)</td></tr>
<tr class="memdesc:a97edf38d012379d8e8f3f4196af47648"><td class="mdescLeft">&#160;</td><td class="mdescRight">add diagonal entries from vector vecDiag <br /></td></tr>
<tr class="separator:a97edf38d012379d8e8f3f4196af47648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e476f614f38b318706c48182de2c5ae"><td class="memItemLeft" align="right" valign="top"><a id="a2e476f614f38b318706c48182de2c5ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a2e476f614f38b318706c48182de2c5ae">addMatrix</a> (const T &amp;s, std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &gt; const &amp;m, <a class="el" href="namespaceFeel.html#a3d7a6c5948e669b187f2d4620499715a">Feel::MatrixStructure</a> matStruc=Feel::SAME_NONZERO_PATTERN)</td></tr>
<tr class="memdesc:a2e476f614f38b318706c48182de2c5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Sparse matrix <code>_X</code>, scaled with <code>_a</code>, to <code>this</code>, stores the result in <code>this:</code> \(\texttt{this} = \_a*\_X + \texttt{this} \). <br /></td></tr>
<tr class="separator:a2e476f614f38b318706c48182de2c5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3895b14b5c5973db9881164bb1e044b0"><td class="memItemLeft" align="right" valign="top"><a id="a3895b14b5c5973db9881164bb1e044b0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a3895b14b5c5973db9881164bb1e044b0">addMatrix</a> (const T, <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; const &amp;, <a class="el" href="namespaceFeel.html#a3d7a6c5948e669b187f2d4620499715a">Feel::MatrixStructure</a> matStruc=Feel::SAME_NONZERO_PATTERN)=0</td></tr>
<tr class="memdesc:a3895b14b5c5973db9881164bb1e044b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Sparse matrix <code>_X</code>, scaled with <code>_a</code>, to <code>this</code>, stores the result in <code>this:</code> \(\texttt{this} = \_a*\_X + \texttt{this} \). <br /></td></tr>
<tr class="separator:a3895b14b5c5973db9881164bb1e044b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dca4dcd7b153818229139706d8d30c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#aa4dca4dcd7b153818229139706d8d30c">addMatrix</a> (const ublas::matrix&lt; value_type &gt; &amp;dm, const std::vector&lt; size_type &gt; &amp;dof_indices)=0</td></tr>
<tr class="memdesc:aa4dca4dcd7b153818229139706d8d30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, but assumes the row and column maps are the same.  <a href="classFeel_1_1MatrixSparse.html#aa4dca4dcd7b153818229139706d8d30c">More...</a><br /></td></tr>
<tr class="separator:aa4dca4dcd7b153818229139706d8d30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf1685918b0346985a4647e3a40e3d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a2bf1685918b0346985a4647e3a40e3d8">addMatrix</a> (const ublas::matrix&lt; value_type &gt; &amp;dm, const std::vector&lt; size_type &gt; &amp;rows, const std::vector&lt; size_type &gt; &amp;cols)=0</td></tr>
<tr class="memdesc:a2bf1685918b0346985a4647e3a40e3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the full matrix to the Sparse matrix.  <a href="classFeel_1_1MatrixSparse.html#a2bf1685918b0346985a4647e3a40e3d8">More...</a><br /></td></tr>
<tr class="separator:a2bf1685918b0346985a4647e3a40e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae40a37ba2a5627390813893bc997f1"><td class="memItemLeft" align="right" valign="top"><a id="afae40a37ba2a5627390813893bc997f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#afae40a37ba2a5627390813893bc997f1">addMatrix</a> (<a class="el" href="classint.html">int</a> *rows, <a class="el" href="classint.html">int</a> nrows, <a class="el" href="classint.html">int</a> *cols, <a class="el" href="classint.html">int</a> ncols, value_type *data, size_type K, size_type K2)=0</td></tr>
<tr class="memdesc:afae40a37ba2a5627390813893bc997f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the full matrix to the Sparse matrix. This is useful for adding an element matrix at assembly time. <br /></td></tr>
<tr class="separator:afae40a37ba2a5627390813893bc997f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0836e10b679e6722b2e2cf1c92fc5a"><td class="memItemLeft" align="right" valign="top"><a id="a6d0836e10b679e6722b2e2cf1c92fc5a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>applyInverseSqrt</b> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;vec_in, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;vec_out)</td></tr>
<tr class="separator:a6d0836e10b679e6722b2e2cf1c92fc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1ce35289fc7655c50a5db9abd8893c"><td class="memItemLeft" align="right" valign="top"><a id="aab1ce35289fc7655c50a5db9abd8893c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkProperties</b> () const</td></tr>
<tr class="separator:aab1ce35289fc7655c50a5db9abd8893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05699de2637646583a3df40e5157609"><td class="memItemLeft" align="right" valign="top"><a id="ae05699de2637646583a3df40e5157609"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ae05699de2637646583a3df40e5157609">clear</a> ()=0</td></tr>
<tr class="memdesc:ae05699de2637646583a3df40e5157609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all memory and return to a state just like after having called the default constructor. <br /></td></tr>
<tr class="separator:ae05699de2637646583a3df40e5157609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473eba28aae1b62ddd1e531768be2c56"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a473eba28aae1b62ddd1e531768be2c56">close</a> () const =0</td></tr>
<tr class="memdesc:a473eba28aae1b62ddd1e531768be2c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the Sparse assemble routines.  <a href="classFeel_1_1MatrixSparse.html#a473eba28aae1b62ddd1e531768be2c56">More...</a><br /></td></tr>
<tr class="separator:a473eba28aae1b62ddd1e531768be2c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6395626717c2ac69a9919d98450edfee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a6395626717c2ac69a9919d98450edfee">closed</a> () const</td></tr>
<tr class="separator:a6395626717c2ac69a9919d98450edfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3dd6d9d27943803b606a4d62bc8afd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a9c3dd6d9d27943803b606a4d62bc8afd">createSubmatrix</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;submatrix, const std::vector&lt; size_type &gt; &amp;rows, const std::vector&lt; size_type &gt; &amp;cols) const</td></tr>
<tr class="memdesc:a9c3dd6d9d27943803b606a4d62bc8afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a matrix called "submatrix" which is defined by the row and column indices given in the "rows" and "cols" entries.  <a href="classFeel_1_1MatrixSparse.html#a9c3dd6d9d27943803b606a4d62bc8afd">More...</a><br /></td></tr>
<tr class="separator:a9c3dd6d9d27943803b606a4d62bc8afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27993bcdfc805dd2c3e8c3142720f879"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a27993bcdfc805dd2c3e8c3142720f879">createSubMatrix</a> (std::vector&lt; size_type &gt; const &amp;rows, std::vector&lt; size_type &gt; const &amp;cols, bool useSameDataMap=false, bool checkAndFixRange=true) const</td></tr>
<tr class="memdesc:a27993bcdfc805dd2c3e8c3142720f879"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a matrix called "submatrix" which is defined by the row and column indices given in the "rows" and "cols" entries.  <a href="classFeel_1_1MatrixSparse.html#a27993bcdfc805dd2c3e8c3142720f879">More...</a><br /></td></tr>
<tr class="separator:a27993bcdfc805dd2c3e8c3142720f879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7baa7297519a29818895af5d139db6d"><td class="memItemLeft" align="right" valign="top"><a id="ab7baa7297519a29818895af5d139db6d"></a>
virtual std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ab7baa7297519a29818895af5d139db6d">diagonal</a> () const</td></tr>
<tr class="memdesc:ab7baa7297519a29818895af5d139db6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return copy vector of the diagonal part of the matrix. <br /></td></tr>
<tr class="separator:ab7baa7297519a29818895af5d139db6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d324260c3576e84cfaf2d3164d60cc"><td class="memItemLeft" align="right" valign="top"><a id="a23d324260c3576e84cfaf2d3164d60cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a23d324260c3576e84cfaf2d3164d60cc">diagonal</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; &amp;dest) const</td></tr>
<tr class="memdesc:a23d324260c3576e84cfaf2d3164d60cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the diagonal part of the matrix into <code>dest</code>. <br /></td></tr>
<tr class="separator:a23d324260c3576e84cfaf2d3164d60cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b125a43ee70bfe128ca4f174213959f"><td class="memItemLeft" align="right" valign="top"><a id="a0b125a43ee70bfe128ca4f174213959f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a0b125a43ee70bfe128ca4f174213959f">diagonal</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;dest) const =0</td></tr>
<tr class="memdesc:a0b125a43ee70bfe128ca4f174213959f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the diagonal part of the matrix into <code>dest</code>. <br /></td></tr>
<tr class="separator:a0b125a43ee70bfe128ca4f174213959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f30cd21052749616971af82a6a0153"><td class="memItemLeft" align="right" valign="top">real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#aa0f30cd21052749616971af82a6a0153">energy</a> (vector_ptrtype const &amp;v, vector_ptrtype const &amp;u, bool _transpose=false) const</td></tr>
<tr class="memdesc:aa0f30cd21052749616971af82a6a0153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the scalar product \((Au, v)= v^T A u\).  <a href="classFeel_1_1MatrixSparse.html#aa0f30cd21052749616971af82a6a0153">More...</a><br /></td></tr>
<tr class="separator:aa0f30cd21052749616971af82a6a0153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec47bcf734704ed4305b0fd57b9c61bb"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#aec47bcf734704ed4305b0fd57b9c61bb">energy</a> (<a class="el" href="classFeel_1_1Vector.html">vector_type</a> const &amp;v, <a class="el" href="classFeel_1_1Vector.html">vector_type</a> const &amp;u, bool <a class="el" href="classFeel_1_1MatrixSparse.html#a32ab430d70d048e5da30004e5d88ac5d">transpose</a>=false) const =0</td></tr>
<tr class="memdesc:aec47bcf734704ed4305b0fd57b9c61bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the A scalar product \(v^T A u\)  <a href="classFeel_1_1MatrixSparse.html#aec47bcf734704ed4305b0fd57b9c61bb">More...</a><br /></td></tr>
<tr class="separator:aec47bcf734704ed4305b0fd57b9c61bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e524507ca2161f64e7828044b46b5ed"><td class="memItemLeft" align="right" valign="top"><a id="a5e524507ca2161f64e7828044b46b5ed"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a5e524507ca2161f64e7828044b46b5ed">getMatInfo</a> (std::vector&lt; double &gt; &amp;)</td></tr>
<tr class="memdesc:a5e524507ca2161f64e7828044b46b5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get informations (filling, nnz, ...) Implemented in MatrixPetsc. <br /></td></tr>
<tr class="separator:a5e524507ca2161f64e7828044b46b5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9ecc0a4baf17089e56cba0d9c08a8a"><td class="memItemLeft" align="right" valign="top">graph_ptrtype const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a0f9ecc0a4baf17089e56cba0d9c08a8a">graph</a> () const</td></tr>
<tr class="separator:a0f9ecc0a4baf17089e56cba0d9c08a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1698552e4b5b2f1c776822a03b72d91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ab1698552e4b5b2f1c776822a03b72d91">hasGraph</a> () const</td></tr>
<tr class="separator:ab1698552e4b5b2f1c776822a03b72d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39bb96aeebdb24713c601b641aa1807"><td class="memItemLeft" align="right" valign="top"><a id="af39bb96aeebdb24713c601b641aa1807"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>haveConsistentProperties</b> () const</td></tr>
<tr class="separator:af39bb96aeebdb24713c601b641aa1807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cb48e97e54a97d424f2a593604cb94"><td class="memItemLeft" align="right" valign="top">indexsplit_ptrtype const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a68cb48e97e54a97d424f2a593604cb94">indexSplit</a> () const</td></tr>
<tr class="separator:a68cb48e97e54a97d424f2a593604cb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912ef58fbd90fbad544f010b25310065"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a912ef58fbd90fbad544f010b25310065">init</a> (const size_type m, const size_type n, const size_type m_l, const size_type n_l, const size_type <a class="el" href="classFeel_1_1MatrixSparse.html#ad2645f380bddc0bd0031a4663fc23587">nnz</a>=30, const size_type noz=10)=0</td></tr>
<tr class="memdesc:a912ef58fbd90fbad544f010b25310065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Sparse matrix that is of global dimension \( m \times n \) with local dimensions \( m_l \times n_l \).  <a href="classFeel_1_1MatrixSparse.html#a912ef58fbd90fbad544f010b25310065">More...</a><br /></td></tr>
<tr class="separator:a912ef58fbd90fbad544f010b25310065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8793f66e8e5daca00fd0daeb6ec0b8da"><td class="memItemLeft" align="right" valign="top"><a id="a8793f66e8e5daca00fd0daeb6ec0b8da"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a8793f66e8e5daca00fd0daeb6ec0b8da">init</a> (const size_type m, const size_type n, const size_type m_l, const size_type n_l, graph_ptrtype const &amp;<a class="el" href="classFeel_1_1MatrixSparse.html#a0f9ecc0a4baf17089e56cba0d9c08a8a">graph</a>)=0</td></tr>
<tr class="memdesc:a8793f66e8e5daca00fd0daeb6ec0b8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize using sparsity structure computed by <code>dof_map</code>. <br /></td></tr>
<tr class="separator:a8793f66e8e5daca00fd0daeb6ec0b8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c312fea9b2f74aad81666328796646f"><td class="memItemLeft" align="right" valign="top"><a id="a1c312fea9b2f74aad81666328796646f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDense</b> () const</td></tr>
<tr class="separator:a1c312fea9b2f74aad81666328796646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8b2a534956f22288523a69f329943e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a5b8b2a534956f22288523a69f329943e">isHermitian</a> () const</td></tr>
<tr class="separator:a5b8b2a534956f22288523a69f329943e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1baf6e8072a2553cb46e2a861764e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a1db1baf6e8072a2553cb46e2a861764e">isHermitianPositiveDefinite</a> () const</td></tr>
<tr class="separator:a1db1baf6e8072a2553cb46e2a861764e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38cd3585c4fca22d0c1a7e1d01a71b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ac38cd3585c4fca22d0c1a7e1d01a71b3">isIndefinite</a> () const</td></tr>
<tr class="separator:ac38cd3585c4fca22d0c1a7e1d01a71b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bddd0749f4536b327f8cebb85f71cb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a71bddd0749f4536b327f8cebb85f71cb">isInitialized</a> () const</td></tr>
<tr class="separator:a71bddd0749f4536b327f8cebb85f71cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0619ab62153c145b70938064c275a312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a0619ab62153c145b70938064c275a312">isNegativeDefinite</a> () const</td></tr>
<tr class="separator:a0619ab62153c145b70938064c275a312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515160494e2f4b4a72461c7a5aa792fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a515160494e2f4b4a72461c7a5aa792fe">isNonHermitian</a> () const</td></tr>
<tr class="separator:a515160494e2f4b4a72461c7a5aa792fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29043cb90ff6739681d7f39d9479cb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#af29043cb90ff6739681d7f39d9479cb4">isPositiveDefinite</a> () const</td></tr>
<tr class="separator:af29043cb90ff6739681d7f39d9479cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b817486861f34255500b639b3b002e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a4b817486861f34255500b639b3b002e6">isSingular</a> () const</td></tr>
<tr class="separator:a4b817486861f34255500b639b3b002e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f19ec0c200c3b56bbcb517d12f30a22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a1f19ec0c200c3b56bbcb517d12f30a22">isSPD</a> () const</td></tr>
<tr class="separator:a1f19ec0c200c3b56bbcb517d12f30a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa217a194c7a3be2e1a82f6d20248c0ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#aa217a194c7a3be2e1a82f6d20248c0ba">isStructurallySymmetric</a> () const</td></tr>
<tr class="separator:aa217a194c7a3be2e1a82f6d20248c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e3110e30e9f413dcccdf1b659afef8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a01e3110e30e9f413dcccdf1b659afef8">isSymmetric</a> (bool check=false) const</td></tr>
<tr class="separator:a01e3110e30e9f413dcccdf1b659afef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c2d679bb05e71a9eeabefe991ec812"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a02c2d679bb05e71a9eeabefe991ec812">isTransposeOf</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;<a class="el" href="classFeel_1_1vf_1_1Trans.html">Trans</a>) const</td></tr>
<tr class="separator:a02c2d679bb05e71a9eeabefe991ec812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b896d0669d8ba227aaa189663c587a"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a82b896d0669d8ba227aaa189663c587a">l1Norm</a> () const =0</td></tr>
<tr class="memdesc:a82b896d0669d8ba227aaa189663c587a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the l1-norm of the matrix, that is \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\), (max.  <a href="classFeel_1_1MatrixSparse.html#a82b896d0669d8ba227aaa189663c587a">More...</a><br /></td></tr>
<tr class="separator:a82b896d0669d8ba227aaa189663c587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aeca146775f1151a3669e03c546538"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ab1aeca146775f1151a3669e03c546538">linftyNorm</a> () const =0</td></tr>
<tr class="memdesc:ab1aeca146775f1151a3669e03c546538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linfty-norm of the matrix, that is.  <a href="classFeel_1_1MatrixSparse.html#ab1aeca146775f1151a3669e03c546538">More...</a><br /></td></tr>
<tr class="separator:ab1aeca146775f1151a3669e03c546538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b58e12090f12423dd3ee4c6a108c07"><td class="memItemLeft" align="right" valign="top"><a id="ac4b58e12090f12423dd3ee4c6a108c07"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>load</b> (std::string const &amp;filename=&quot;default_archive_name&quot;, std::string const &amp;format=&quot;binary&quot;)</td></tr>
<tr class="separator:ac4b58e12090f12423dd3ee4c6a108c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a5a41f52fdd6911d6e8a838e957739"><td class="memItemLeft" align="right" valign="top"><a id="a24a5a41f52fdd6911d6e8a838e957739"></a>
<a class="el" href="classFeel_1_1DataMap.html">datamap_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a24a5a41f52fdd6911d6e8a838e957739">mapCol</a> () const</td></tr>
<tr class="memdesc:a24a5a41f52fdd6911d6e8a838e957739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return datamap for cols. <br /></td></tr>
<tr class="separator:a24a5a41f52fdd6911d6e8a838e957739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9942291b6bc74ac2acf64fe1862f590"><td class="memItemLeft" align="right" valign="top"><a id="ab9942291b6bc74ac2acf64fe1862f590"></a>
datamap_ptrtype const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ab9942291b6bc74ac2acf64fe1862f590">mapColPtr</a> () const</td></tr>
<tr class="memdesc:ab9942291b6bc74ac2acf64fe1862f590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return datamap for cols. <br /></td></tr>
<tr class="separator:ab9942291b6bc74ac2acf64fe1862f590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaf57321f8ee979bd1f7df25ecc2f07"><td class="memItemLeft" align="right" valign="top"><a id="a3aaf57321f8ee979bd1f7df25ecc2f07"></a>
<a class="el" href="classFeel_1_1DataMap.html">datamap_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a3aaf57321f8ee979bd1f7df25ecc2f07">mapRow</a> () const</td></tr>
<tr class="memdesc:a3aaf57321f8ee979bd1f7df25ecc2f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return datamap for rows. <br /></td></tr>
<tr class="separator:a3aaf57321f8ee979bd1f7df25ecc2f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb5ae60346339ba86fa424917956b0"><td class="memItemLeft" align="right" valign="top"><a id="ac3fb5ae60346339ba86fa424917956b0"></a>
datamap_ptrtype const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ac3fb5ae60346339ba86fa424917956b0">mapRowPtr</a> () const</td></tr>
<tr class="memdesc:ac3fb5ae60346339ba86fa424917956b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return datamap for rows. <br /></td></tr>
<tr class="separator:ac3fb5ae60346339ba86fa424917956b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc366e4c2a25933386f6de56d395e21a"><td class="memItemLeft" align="right" valign="top"><a id="abc366e4c2a25933386f6de56d395e21a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>matInverse</b> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;Inv)</td></tr>
<tr class="separator:abc366e4c2a25933386f6de56d395e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f3704f7d58a5709c9176d5d418c3dd"><td class="memItemLeft" align="right" valign="top"><a id="a82f3704f7d58a5709c9176d5d418c3dd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a82f3704f7d58a5709c9176d5d418c3dd">matMatMult</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; const &amp;In, <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;Res) const</td></tr>
<tr class="memdesc:a82f3704f7d58a5709c9176d5d418c3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this by a Sparse matrix <code>In</code>, stores the result in <code>Res:</code> \( Res = \texttt{this}*In \). <br /></td></tr>
<tr class="separator:a82f3704f7d58a5709c9176d5d418c3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38638152ec4d5a9181e1287a19380dc"><td class="memItemLeft" align="right" valign="top"><a id="ad38638152ec4d5a9181e1287a19380dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixSparse</b> (datamap_ptrtype const &amp;dmRow, datamap_ptrtype const &amp;dmCol)</td></tr>
<tr class="separator:ad38638152ec4d5a9181e1287a19380dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5985d34f2bcbee5c9cb9c089111b5fec"><td class="memItemLeft" align="right" valign="top"><a id="a5985d34f2bcbee5c9cb9c089111b5fec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixSparse</b> (datamap_ptrtype const &amp;dmRow, datamap_ptrtype const &amp;dmCol, worldcomm_ptr_t const &amp;<a class="el" href="namespaceFeel.html#aeb29bac2a3e332bb2282ce149f33bcc3">worldComm</a>)</td></tr>
<tr class="separator:a5985d34f2bcbee5c9cb9c089111b5fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f77635be141df03a1067b86340b325e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a0f77635be141df03a1067b86340b325e">MatrixSparse</a> (worldcomm_ptr_t const &amp;<a class="el" href="namespaceFeel.html#aeb29bac2a3e332bb2282ce149f33bcc3">worldComm</a>=<a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>())</td></tr>
<tr class="memdesc:a0f77635be141df03a1067b86340b325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor; initializes the matrix to be empty, without any structure, i.e.  <a href="classFeel_1_1MatrixSparse.html#a0f77635be141df03a1067b86340b325e">More...</a><br /></td></tr>
<tr class="separator:a0f77635be141df03a1067b86340b325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cca15636c6bf0807cd43a8cb27f008"><td class="memItemLeft" align="right" valign="top"><a id="ab6cca15636c6bf0807cd43a8cb27f008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ab6cca15636c6bf0807cd43a8cb27f008">multAddVector</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;arg, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;dest) const</td></tr>
<tr class="memdesc:ab6cca15636c6bf0807cd43a8cb27f008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix with <code>arg</code> and adds the result to <code>dest</code>. <br /></td></tr>
<tr class="separator:ab6cca15636c6bf0807cd43a8cb27f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc358be6c92e37ddf96277eed6a336b3"><td class="memItemLeft" align="right" valign="top"><a id="acc358be6c92e37ddf96277eed6a336b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#acc358be6c92e37ddf96277eed6a336b3">multVector</a> (const std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; &amp;arg, std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; &amp;dest) const</td></tr>
<tr class="memdesc:acc358be6c92e37ddf96277eed6a336b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix with <code>arg</code> and stores the result in <code>dest</code>. <br /></td></tr>
<tr class="separator:acc358be6c92e37ddf96277eed6a336b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b66c37c16f89be5cdd4dbc8039a3c2b"><td class="memItemLeft" align="right" valign="top"><a id="a2b66c37c16f89be5cdd4dbc8039a3c2b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a2b66c37c16f89be5cdd4dbc8039a3c2b">multVector</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;arg, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;dest, bool <a class="el" href="classFeel_1_1MatrixSparse.html#a32ab430d70d048e5da30004e5d88ac5d">transpose</a>=false) const</td></tr>
<tr class="memdesc:a2b66c37c16f89be5cdd4dbc8039a3c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix with <code>arg</code> and stores the result in <code>dest</code>. <br /></td></tr>
<tr class="separator:a2b66c37c16f89be5cdd4dbc8039a3c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2645f380bddc0bd0031a4663fc23587"><td class="memItemLeft" align="right" valign="top">virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ad2645f380bddc0bd0031a4663fc23587">nnz</a> () const =0</td></tr>
<tr class="separator:ad2645f380bddc0bd0031a4663fc23587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f480700bcd3a918ed0925de10cd460"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a71f480700bcd3a918ed0925de10cd460">operator()</a> (const size_type i, const size_type j) const =0</td></tr>
<tr class="memdesc:a71f480700bcd3a918ed0925de10cd460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the entry <code></code>(i,j).  <a href="classFeel_1_1MatrixSparse.html#a71f480700bcd3a918ed0925de10cd460">More...</a><br /></td></tr>
<tr class="separator:a71f480700bcd3a918ed0925de10cd460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4ac4599b1a36309c741d27547bc660"><td class="memItemLeft" align="right" valign="top"><a id="a9b4ac4599b1a36309c741d27547bc660"></a>
virtual <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; const &amp;M)=0</td></tr>
<tr class="separator:a9b4ac4599b1a36309c741d27547bc660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9b621361fb0e49e3f3b1c91a2fcc00"><td class="memItemLeft" align="right" valign="top"><a id="ace9b621361fb0e49e3f3b1c91a2fcc00"></a>
<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &gt; const &amp;M)</td></tr>
<tr class="separator:ace9b621361fb0e49e3f3b1c91a2fcc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5ed0d00c596a4ec70b9ea8abd1573f"><td class="memItemLeft" align="right" valign="top"><a id="aad5ed0d00c596a4ec70b9ea8abd1573f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#aad5ed0d00c596a4ec70b9ea8abd1573f">PAPt</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; const &amp;P, <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;C) const</td></tr>
<tr class="memdesc:aad5ed0d00c596a4ec70b9ea8abd1573f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the matrix product C = P * A * P^T with A the current matrix. <br /></td></tr>
<tr class="separator:aad5ed0d00c596a4ec70b9ea8abd1573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770720a8d311130c33b238dc982cb480"><td class="memItemLeft" align="right" valign="top"><a id="a770720a8d311130c33b238dc982cb480"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a770720a8d311130c33b238dc982cb480">print</a> (std::ostream &amp;os=std::cout) const</td></tr>
<tr class="memdesc:a770720a8d311130c33b238dc982cb480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the matrix to the screen in a uniform style, regardless of matrix/solver package being used. <br /></td></tr>
<tr class="separator:a770720a8d311130c33b238dc982cb480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e9c5e8d3ca180ade2b929c4c4f5cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ad79e9c5e8d3ca180ade2b929c4c4f5cc">printMatlab</a> (const std::string name=&quot;NULL&quot;) const</td></tr>
<tr class="memdesc:ad79e9c5e8d3ca180ade2b929c4c4f5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the matrix in Matlab's sparse matrix format.  <a href="classFeel_1_1MatrixSparse.html#ad79e9c5e8d3ca180ade2b929c4c4f5cc">More...</a><br /></td></tr>
<tr class="separator:ad79e9c5e8d3ca180ade2b929c4c4f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a62c54f6d9ec009654cae5dcc05c7f3"><td class="memItemLeft" align="right" valign="top"><a id="a1a62c54f6d9ec009654cae5dcc05c7f3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a1a62c54f6d9ec009654cae5dcc05c7f3">printPersonal</a> (std::ostream &amp;=std::cout) const</td></tr>
<tr class="memdesc:a1a62c54f6d9ec009654cae5dcc05c7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the matrix to the screen in a package-personalized style, if available. <br /></td></tr>
<tr class="separator:a1a62c54f6d9ec009654cae5dcc05c7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce92691a30b7be319e54e8b0292e672"><td class="memItemLeft" align="right" valign="top"><a id="afce92691a30b7be319e54e8b0292e672"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#afce92691a30b7be319e54e8b0292e672">PtAP</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; const &amp;P, <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;C) const</td></tr>
<tr class="memdesc:afce92691a30b7be319e54e8b0292e672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the matrix product C = P^T * A * P with A the current matrix. <br /></td></tr>
<tr class="separator:afce92691a30b7be319e54e8b0292e672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140551aa8f92ad9853a67bf0d1ccc8bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a140551aa8f92ad9853a67bf0d1ccc8bb">reinitSubmatrix</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;submatrix, const std::vector&lt; size_type &gt; &amp;rows, const std::vector&lt; size_type &gt; &amp;cols) const</td></tr>
<tr class="memdesc:a140551aa8f92ad9853a67bf0d1ccc8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to the one above, but it allows you to reuse the existing sparsity pattern of "submatrix" instead of reallocating it again.  <a href="classFeel_1_1MatrixSparse.html#a140551aa8f92ad9853a67bf0d1ccc8bb">More...</a><br /></td></tr>
<tr class="separator:a140551aa8f92ad9853a67bf0d1ccc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d86cf00a8b2f300ea35343b435584fc"><td class="memItemLeft" align="right" valign="top"><a id="a9d86cf00a8b2f300ea35343b435584fc"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a9d86cf00a8b2f300ea35343b435584fc">rowStart</a> () const =0</td></tr>
<tr class="memdesc:a9d86cf00a8b2f300ea35343b435584fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">return row_start, the index of the first matrix row stored on this processor <br /></td></tr>
<tr class="separator:a9d86cf00a8b2f300ea35343b435584fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecd0afd3539f36ffdb8b27390e62fed"><td class="memItemLeft" align="right" valign="top"><a id="afecd0afd3539f36ffdb8b27390e62fed"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#afecd0afd3539f36ffdb8b27390e62fed">rowStop</a> () const =0</td></tr>
<tr class="memdesc:afecd0afd3539f36ffdb8b27390e62fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">return row_stop, the index of the last matrix row (+1) stored on this processor <br /></td></tr>
<tr class="separator:afecd0afd3539f36ffdb8b27390e62fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b843956326fc68d4e8e4e045aba8f4"><td class="memItemLeft" align="right" valign="top"><a id="a37b843956326fc68d4e8e4e045aba8f4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>save</b> (std::string const &amp;filename=&quot;default_archive_name&quot;, std::string const &amp;format=&quot;binary&quot;)</td></tr>
<tr class="separator:a37b843956326fc68d4e8e4e045aba8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673a688afee4f06967f2cd9d7a001d7c"><td class="memItemLeft" align="right" valign="top"><a id="a673a688afee4f06967f2cd9d7a001d7c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b> (const T)=0</td></tr>
<tr class="separator:a673a688afee4f06967f2cd9d7a001d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0333712d390479a5935088518fe5496"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ac0333712d390479a5935088518fe5496">set</a> (const size_type i, const size_type j, const value_type &amp;value)=0</td></tr>
<tr class="memdesc:ac0333712d390479a5935088518fe5496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element <code></code>(i,j) to <code>value</code>.  <a href="classFeel_1_1MatrixSparse.html#ac0333712d390479a5935088518fe5496">More...</a><br /></td></tr>
<tr class="separator:ac0333712d390479a5935088518fe5496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eea2613170b5215bf1eadf8cb0e8dd"><td class="memItemLeft" align="right" valign="top"><a id="a68eea2613170b5215bf1eadf8cb0e8dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a68eea2613170b5215bf1eadf8cb0e8dd">setDiagonal</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; const &amp;vecDiag)</td></tr>
<tr class="memdesc:a68eea2613170b5215bf1eadf8cb0e8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">set diagonal entries from vector vecDiag <br /></td></tr>
<tr class="separator:a68eea2613170b5215bf1eadf8cb0e8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4252d1057e35dcf35e0be35945c0292b"><td class="memItemLeft" align="right" valign="top"><a id="a4252d1057e35dcf35e0be35945c0292b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a4252d1057e35dcf35e0be35945c0292b">setDiagonal</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;vecDiag)</td></tr>
<tr class="memdesc:a4252d1057e35dcf35e0be35945c0292b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set diagonal entries from vector vecDiag <br /></td></tr>
<tr class="separator:a4252d1057e35dcf35e0be35945c0292b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f6ea8901e8df74735b6bf16f62ec38"><td class="memItemLeft" align="right" valign="top"><a id="ae6f6ea8901e8df74735b6bf16f62ec38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ae6f6ea8901e8df74735b6bf16f62ec38">setGraph</a> (graph_ptrtype const &amp;<a class="el" href="classFeel_1_1MatrixSparse.html#a0f9ecc0a4baf17089e56cba0d9c08a8a">graph</a>)</td></tr>
<tr class="memdesc:ae6f6ea8901e8df74735b6bf16f62ec38"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the graph associated to the sparse matrix <br /></td></tr>
<tr class="separator:ae6f6ea8901e8df74735b6bf16f62ec38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfce9c6743668f79f45ff1227aaa569"><td class="memItemLeft" align="right" valign="top"><a id="a7bfce9c6743668f79f45ff1227aaa569"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a7bfce9c6743668f79f45ff1227aaa569">setIndexSplit</a> (indexsplit_ptrtype const &amp;is)</td></tr>
<tr class="memdesc:a7bfce9c6743668f79f45ff1227aaa569"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the indexSplit associated to the sparse matrix <br /></td></tr>
<tr class="separator:a7bfce9c6743668f79f45ff1227aaa569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccc415831ff4c311bb3fb668cfa6716"><td class="memItemLeft" align="right" valign="top"><a id="a6ccc415831ff4c311bb3fb668cfa6716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a6ccc415831ff4c311bb3fb668cfa6716">setInitialized</a> (bool _init)</td></tr>
<tr class="memdesc:a6ccc415831ff4c311bb3fb668cfa6716"><td class="mdescLeft">&#160;</td><td class="mdescRight">set initialized only for subclasses <br /></td></tr>
<tr class="separator:a6ccc415831ff4c311bb3fb668cfa6716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b2e5d7fb2356d54033c88cba33a23d"><td class="memItemLeft" align="right" valign="top"><a id="a79b2e5d7fb2356d54033c88cba33a23d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a79b2e5d7fb2356d54033c88cba33a23d">setIsClosed</a> (bool b) const</td></tr>
<tr class="memdesc:a79b2e5d7fb2356d54033c88cba33a23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">@ set false if the matrix is in assembly state and need to be closed for some next used (global operation) , false otherwise. <br /></td></tr>
<tr class="separator:a79b2e5d7fb2356d54033c88cba33a23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeeff43b4091041fe2bb9b147517386"><td class="memItemLeft" align="right" valign="top"><a id="affeeff43b4091041fe2bb9b147517386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMapCol</b> (datamap_ptrtype const &amp;d)</td></tr>
<tr class="separator:affeeff43b4091041fe2bb9b147517386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3271920253bd03d7f1b02572a1ba55d"><td class="memItemLeft" align="right" valign="top"><a id="ad3271920253bd03d7f1b02572a1ba55d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMapRow</b> (datamap_ptrtype const &amp;d)</td></tr>
<tr class="separator:ad3271920253bd03d7f1b02572a1ba55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34202ecd63a380eb35a65944720de4f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a34202ecd63a380eb35a65944720de4f9">setMatrixProperties</a> (size_type p)</td></tr>
<tr class="memdesc:a34202ecd63a380eb35a65944720de4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set matrix properties,  <a href="classFeel_1_1MatrixSparse.html#a34202ecd63a380eb35a65944720de4f9">More...</a><br /></td></tr>
<tr class="separator:a34202ecd63a380eb35a65944720de4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f5d30f75f23a6a9c39e2de2ffd4ff2"><td class="memItemLeft" align="right" valign="top">virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a45f5d30f75f23a6a9c39e2de2ffd4ff2">size1</a> () const =0</td></tr>
<tr class="separator:a45f5d30f75f23a6a9c39e2de2ffd4ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d70a92c696bf3c398d8f1ba3515674"><td class="memItemLeft" align="right" valign="top">virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a67d70a92c696bf3c398d8f1ba3515674">size2</a> () const =0</td></tr>
<tr class="separator:a67d70a92c696bf3c398d8f1ba3515674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e7b70989e7f1ef534fb71cfa895978"><td class="memItemLeft" align="right" valign="top"><a id="a32e7b70989e7f1ef534fb71cfa895978"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;_m) const</td></tr>
<tr class="separator:a32e7b70989e7f1ef534fb71cfa895978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6df8e9fef8db78c2e8515ab680ca4bc"><td class="memItemLeft" align="right" valign="top"><a id="af6df8e9fef8db78c2e8515ab680ca4bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &gt; &amp;_m) const</td></tr>
<tr class="separator:af6df8e9fef8db78c2e8515ab680ca4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3e0176d80d431f782f72221114b59f"><td class="memItemLeft" align="right" valign="top"><a id="afc3e0176d80d431f782f72221114b59f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#afc3e0176d80d431f782f72221114b59f">symmetricPart</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;Ms) const</td></tr>
<tr class="memdesc:afc3e0176d80d431f782f72221114b59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symmetric part of the matrix. <br /></td></tr>
<tr class="separator:afc3e0176d80d431f782f72221114b59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac066a69a64d798dcad541dc0648e8"><td class="memItemLeft" align="right" valign="top"><a id="a2aac066a69a64d798dcad541dc0648e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a2aac066a69a64d798dcad541dc0648e8">symmetricPart</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &gt; &amp;Ms) const</td></tr>
<tr class="memdesc:a2aac066a69a64d798dcad541dc0648e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symmetric part of the matrix. <br /></td></tr>
<tr class="separator:a2aac066a69a64d798dcad541dc0648e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b307ca8dc71a48e3f323aaaa4e67fa"><td class="memItemLeft" align="right" valign="top"><a id="a61b307ca8dc71a48e3f323aaaa4e67fa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>threshold</b> (void)</td></tr>
<tr class="separator:a61b307ca8dc71a48e3f323aaaa4e67fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ab430d70d048e5da30004e5d88ac5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a32ab430d70d048e5da30004e5d88ac5d">transpose</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;Mt, size_type options=MATRIX_TRANSPOSE_ASSEMBLED) const =0</td></tr>
<tr class="memdesc:a32ab430d70d048e5da30004e5d88ac5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of a matrix.  <a href="classFeel_1_1MatrixSparse.html#a32ab430d70d048e5da30004e5d88ac5d">More...</a><br /></td></tr>
<tr class="separator:a32ab430d70d048e5da30004e5d88ac5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a9b30f03f483b9db8dd969f6fda64e"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#af7a9b30f03f483b9db8dd969f6fda64e">transpose</a> (size_type options=MATRIX_TRANSPOSE_ASSEMBLED) const</td></tr>
<tr class="separator:af7a9b30f03f483b9db8dd969f6fda64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa5e12b2d62183ae32b7c8dc485f088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a1fa5e12b2d62183ae32b7c8dc485f088">transpose</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &gt; &amp;Mt, size_type options=MATRIX_TRANSPOSE_ASSEMBLED) const</td></tr>
<tr class="memdesc:a1fa5e12b2d62183ae32b7c8dc485f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of a matrix.  <a href="classFeel_1_1MatrixSparse.html#a1fa5e12b2d62183ae32b7c8dc485f088">More...</a><br /></td></tr>
<tr class="separator:a1fa5e12b2d62183ae32b7c8dc485f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71901da22e4421cd1358d537f5b7299f"><td class="memItemLeft" align="right" valign="top"><a id="a71901da22e4421cd1358d537f5b7299f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a71901da22e4421cd1358d537f5b7299f">updateBlockMat</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &gt; const &amp;m, std::vector&lt; size_type &gt; const &amp;start_i, std::vector&lt; size_type &gt; const &amp;start_j)=0</td></tr>
<tr class="memdesc:a71901da22e4421cd1358d537f5b7299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">update a block matrix <br /></td></tr>
<tr class="separator:a71901da22e4421cd1358d537f5b7299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add28dc9976b0a149d2816cc881cc4037"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#add28dc9976b0a149d2816cc881cc4037">updateSparsityPattern</a> (const std::vector&lt; std::vector&lt; size_type &gt; &gt; &amp;)</td></tr>
<tr class="memdesc:add28dc9976b0a149d2816cc881cc4037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the matrix sparsity pattern.  <a href="classFeel_1_1MatrixSparse.html#add28dc9976b0a149d2816cc881cc4037">More...</a><br /></td></tr>
<tr class="separator:add28dc9976b0a149d2816cc881cc4037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f92e2042e502fbd02372d8a04afab"><td class="memItemLeft" align="right" valign="top"><a id="ad51f92e2042e502fbd02372d8a04afab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ad51f92e2042e502fbd02372d8a04afab">updateSubMatrix</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &gt; &amp;submatrix, std::vector&lt; size_type &gt; const &amp;rows, std::vector&lt; size_type &gt; const &amp;cols, bool doClose=true)</td></tr>
<tr class="memdesc:ad51f92e2042e502fbd02372d8a04afab"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy matrix entries in submatrix ( submatrix is already built from a createSubMatrix) row and column indices given in the "rows" and "cols" entries. <br /></td></tr>
<tr class="separator:ad51f92e2042e502fbd02372d8a04afab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b388887b1de2436fb1a870194b9094"><td class="memItemLeft" align="right" valign="top"><a id="a86b388887b1de2436fb1a870194b9094"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a86b388887b1de2436fb1a870194b9094">zero</a> ()=0</td></tr>
<tr class="memdesc:a86b388887b1de2436fb1a870194b9094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to 0. <br /></td></tr>
<tr class="separator:a86b388887b1de2436fb1a870194b9094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6127986ed9b1bcd2a5c61e9b3e5b716b"><td class="memItemLeft" align="right" valign="top"><a id="a6127986ed9b1bcd2a5c61e9b3e5b716b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a6127986ed9b1bcd2a5c61e9b3e5b716b">zero</a> (size_type start1, size_type <a class="el" href="classFeel_1_1MatrixSparse.html#a45f5d30f75f23a6a9c39e2de2ffd4ff2">size1</a>, size_type start2, size_type <a class="el" href="classFeel_1_1MatrixSparse.html#a67d70a92c696bf3c398d8f1ba3515674">size2</a>)=0</td></tr>
<tr class="memdesc:a6127986ed9b1bcd2a5c61e9b3e5b716b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set entries between to 0. <br /></td></tr>
<tr class="separator:a6127986ed9b1bcd2a5c61e9b3e5b716b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a377b4207ac4739478d87ba433abef1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a9a377b4207ac4739478d87ba433abef1">zeroRows</a> (std::vector&lt; <a class="el" href="classint.html">int</a> &gt; const &amp;rows, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;values, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;rhs, <a class="el" href="classFeel_1_1meta_1_1Context.html">Context</a> const &amp;on_context, value_type value_on_diagonal)=0</td></tr>
<tr class="memdesc:a9a377b4207ac4739478d87ba433abef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">eliminate rows without change pattern, and put <code>value_on_diagonal</code> on the diagonal entry  <a href="classFeel_1_1MatrixSparse.html#a9a377b4207ac4739478d87ba433abef1">More...</a><br /></td></tr>
<tr class="separator:a9a377b4207ac4739478d87ba433abef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb37362d6cff7fc03e286eda7d2788ba"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#acb37362d6cff7fc03e286eda7d2788ba">~MatrixSparse</a> ()</td></tr>
<tr class="memdesc:acb37362d6cff7fc03e286eda7d2788ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classFeel_1_1MatrixSparse.html#acb37362d6cff7fc03e286eda7d2788ba">More...</a><br /></td></tr>
<tr class="separator:acb37362d6cff7fc03e286eda7d2788ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa018ca5ef1505c1e623957613a80fb50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#aa018ca5ef1505c1e623957613a80fb50">_get_submatrix</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;, const std::vector&lt; size_type &gt; &amp;, const std::vector&lt; size_type &gt; &amp;, const bool) const</td></tr>
<tr class="memdesc:aa018ca5ef1505c1e623957613a80fb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected implementation of the create_submatrix and reinit_submatrix routines.  <a href="classFeel_1_1MatrixSparse.html#aa018ca5ef1505c1e623957613a80fb50">More...</a><br /></td></tr>
<tr class="separator:aa018ca5ef1505c1e623957613a80fb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a752217c8d443365aa7e81b8a3c527417"><td class="memItemLeft" align="right" valign="top"><a id="a752217c8d443365aa7e81b8a3c527417"></a>
graph_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a752217c8d443365aa7e81b8a3c527417">M_graph</a></td></tr>
<tr class="memdesc:a752217c8d443365aa7e81b8a3c527417"><td class="mdescLeft">&#160;</td><td class="mdescRight">non zero entries representation <br /></td></tr>
<tr class="separator:a752217c8d443365aa7e81b8a3c527417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e97d4f6a5ff25bf7e7a5536c200f34"><td class="memItemLeft" align="right" valign="top"><a id="a18e97d4f6a5ff25bf7e7a5536c200f34"></a>
indexsplit_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><b>M_indexSplit</b></td></tr>
<tr class="separator:a18e97d4f6a5ff25bf7e7a5536c200f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f973cac7b62579ee299e2dcb3d30863"><td class="memItemLeft" align="right" valign="top"><a id="a3f973cac7b62579ee299e2dcb3d30863"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a3f973cac7b62579ee299e2dcb3d30863">M_is_closed</a></td></tr>
<tr class="memdesc:a3f973cac7b62579ee299e2dcb3d30863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to see if the Numeric assemble routines have been called yet. <br /></td></tr>
<tr class="separator:a3f973cac7b62579ee299e2dcb3d30863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e4c419f38cc1038240043c486e8d21"><td class="memItemLeft" align="right" valign="top"><a id="a80e4c419f38cc1038240043c486e8d21"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#a80e4c419f38cc1038240043c486e8d21">M_is_initialized</a></td></tr>
<tr class="memdesc:a80e4c419f38cc1038240043c486e8d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether or not the matrix has been initialized. <br /></td></tr>
<tr class="separator:a80e4c419f38cc1038240043c486e8d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff6eccdb6e5f5c4e1edfb9ad121a05f"><td class="memItemLeft" align="right" valign="top"><a id="afff6eccdb6e5f5c4e1edfb9ad121a05f"></a>
datamap_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#afff6eccdb6e5f5c4e1edfb9ad121a05f">M_mapCol</a></td></tr>
<tr class="memdesc:afff6eccdb6e5f5c4e1edfb9ad121a05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">col data distribution in matrix <br /></td></tr>
<tr class="separator:afff6eccdb6e5f5c4e1edfb9ad121a05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f45b9fd3434df3b1e204217c875327"><td class="memItemLeft" align="right" valign="top"><a id="ae8f45b9fd3434df3b1e204217c875327"></a>
datamap_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ae8f45b9fd3434df3b1e204217c875327">M_mapRow</a></td></tr>
<tr class="memdesc:ae8f45b9fd3434df3b1e204217c875327"><td class="mdescLeft">&#160;</td><td class="mdescRight">row data distribution in matrix <br /></td></tr>
<tr class="separator:ae8f45b9fd3434df3b1e204217c875327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac131a85f13eaaa45da80a51fd2c75000"><td class="memItemLeft" align="right" valign="top"><a id="ac131a85f13eaaa45da80a51fd2c75000"></a>
<a class="el" href="classFeel_1_1meta_1_1Context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixSparse.html#ac131a85f13eaaa45da80a51fd2c75000">M_mprop</a></td></tr>
<tr class="memdesc:ac131a85f13eaaa45da80a51fd2c75000"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix properties <br /></td></tr>
<tr class="separator:ac131a85f13eaaa45da80a51fd2c75000"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa018ca5ef1505c1e623957613a80fb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa018ca5ef1505c1e623957613a80fb50">&#9670;&nbsp;</a></span>_get_submatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::_get_submatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected implementation of the create_submatrix and reinit_submatrix routines. </p>
<p>Note that this function must be redefined in derived classes for it to work properly! </p>

</div>
</div>
<a id="ada6dc78edf86b4f893e6942c0c9cc5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6dc78edf86b4f893e6942c0c9cc5e8">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <code>value</code> to the element <code></code>(i,j). </p>
<p>Throws an error if the entry does not exist. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="aa4dca4dcd7b153818229139706d8d30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dca4dcd7b153818229139706d8d30c">&#9670;&nbsp;</a></span>addMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::addMatrix </td>
          <td>(</td>
          <td class="paramtype">const ublas::matrix&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same, but assumes the row and column maps are the same. </p>
<p>Thus the matrix <code>dm</code> must be square. </p>

</div>
</div>
<a id="a2bf1685918b0346985a4647e3a40e3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf1685918b0346985a4647e3a40e3d8">&#9670;&nbsp;</a></span>addMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::addMatrix </td>
          <td>(</td>
          <td class="paramtype">const ublas::matrix&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the full matrix to the Sparse matrix. </p>
<p>This is useful for adding an element matrix at assembly time </p>

</div>
</div>
<a id="a473eba28aae1b62ddd1e531768be2c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473eba28aae1b62ddd1e531768be2c56">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call the Sparse assemble routines. </p>
<p>sends necessary messages to other processors </p>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#a623f77ed5c54cdb96cda2834ddfff844">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#a7ee5b793978ef28f980a671aa4983220">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a6395626717c2ac69a9919d98450edfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6395626717c2ac69a9919d98450edfee">&#9670;&nbsp;</a></span>closed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the matrix is closed (ready for computation), false otherwise. </dd></dl>

</div>
</div>
<a id="a9c3dd6d9d27943803b606a4d62bc8afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3dd6d9d27943803b606a4d62bc8afd">&#9670;&nbsp;</a></span>createSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::createSubmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a matrix called "submatrix" which is defined by the row and column indices given in the "rows" and "cols" entries. </p>
<p>Currently this operation is only defined for the PetscMatrix type. </p>

</div>
</div>
<a id="a27993bcdfc805dd2c3e8c3142720f879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27993bcdfc805dd2c3e8c3142720f879">&#9670;&nbsp;</a></span>createSubMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt;T&gt; &gt; <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::createSubMatrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useSameDataMap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkAndFixRange</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a matrix called "submatrix" which is defined by the row and column indices given in the "rows" and "cols" entries. </p>
<p>useSameDataMap : (opimisation) put at true if dataMapCol == dataMapRow and rows == cols for each proc checkAndFixRange : add missing dof entries in // ( typically a ghost dof present but not active dof associated ) </p>

</div>
</div>
<a id="aa0f30cd21052749616971af82a6a0153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f30cd21052749616971af82a6a0153">&#9670;&nbsp;</a></span>energy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::energy </td>
          <td>(</td>
          <td class="paramtype">vector_ptrtype const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_ptrtype const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the scalar product \((Au, v)= v^T A u\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a vector </td></tr>
    <tr><td class="paramname">v</td><td>a vector </td></tr>
    <tr><td class="paramname">transpose</td><td>true to compute \(v^T A^T u\) instead, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the energy \(v^T A u\) </dd></dl>

</div>
</div>
<a id="aec47bcf734704ed4305b0fd57b9c61bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec47bcf734704ed4305b0fd57b9c61bb">&#9670;&nbsp;</a></span>energy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::energy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">vector_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">vector_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the A scalar product \(v^T A u\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>a vector </td></tr>
    <tr><td class="paramname">v</td><td>a vector </td></tr>
    <tr><td class="paramname">transpose</td><td>true to compute \(v^T A^T u\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the energy \(v^T A u\) </dd></dl>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#a6a34e5c0e77f39539aed2f4f4f0402ce">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#aef2cbc5abdf48b6aaa945907fbcac780">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a0f9ecc0a4baf17089e56cba0d9c08a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9ecc0a4baf17089e56cba0d9c08a8a">&#9670;&nbsp;</a></span>graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">graph_ptrtype const&amp; <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the graph associated to the sparse matrix </dd></dl>

</div>
</div>
<a id="ab1698552e4b5b2f1c776822a03b72d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1698552e4b5b2f1c776822a03b72d91">&#9670;&nbsp;</a></span>hasGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::hasGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix has a graph, false otherwise </dd></dl>

</div>
</div>
<a id="a68cb48e97e54a97d424f2a593604cb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cb48e97e54a97d424f2a593604cb94">&#9670;&nbsp;</a></span>indexSplit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">indexsplit_ptrtype const&amp; <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::indexSplit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the indexSplit associated to the sparse matrix </dd></dl>

</div>
</div>
<a id="a912ef58fbd90fbad544f010b25310065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912ef58fbd90fbad544f010b25310065">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>m_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>nnz</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>noz</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a Sparse matrix that is of global dimension \( m \times n \) with local dimensions \( m_l \times n_l \). </p>
<p><code>nnz</code> is the number of on-processor nonzeros per row (defaults to 30). <code>noz</code> is the number of on-processor nonzeros per row (defaults to 10). </p>

</div>
</div>
<a id="a5b8b2a534956f22288523a69f329943e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8b2a534956f22288523a69f329943e">&#9670;&nbsp;</a></span>isHermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isHermitian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is hermitian, false otherwise </dd></dl>

</div>
</div>
<a id="a1db1baf6e8072a2553cb46e2a861764e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1baf6e8072a2553cb46e2a861764e">&#9670;&nbsp;</a></span>isHermitianPositiveDefinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isHermitianPositiveDefinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is positive definite, false otherwise </dd></dl>

</div>
</div>
<a id="ac38cd3585c4fca22d0c1a7e1d01a71b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38cd3585c4fca22d0c1a7e1d01a71b3">&#9670;&nbsp;</a></span>isIndefinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isIndefinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is negative definite, false otherwise </dd></dl>

</div>
</div>
<a id="a71bddd0749f4536b327f8cebb85f71cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bddd0749f4536b327f8cebb85f71cb">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the matrix has been initialized, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#ac8dd67b80c24c8f922b30e60d9d9d559">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#a3d17860886c7469a0e3dba2fb538d907">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a0619ab62153c145b70938064c275a312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0619ab62153c145b70938064c275a312">&#9670;&nbsp;</a></span>isNegativeDefinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isNegativeDefinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is negative definite, false otherwise </dd></dl>

</div>
</div>
<a id="a515160494e2f4b4a72461c7a5aa792fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515160494e2f4b4a72461c7a5aa792fe">&#9670;&nbsp;</a></span>isNonHermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isNonHermitian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is non hermitian, false otherwise </dd></dl>

</div>
</div>
<a id="af29043cb90ff6739681d7f39d9479cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29043cb90ff6739681d7f39d9479cb4">&#9670;&nbsp;</a></span>isPositiveDefinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isPositiveDefinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is positive definite, false otherwise </dd></dl>

</div>
</div>
<a id="a4b817486861f34255500b639b3b002e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b817486861f34255500b639b3b002e6">&#9670;&nbsp;</a></span>isSingular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isSingular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is singular, false otherwise </dd></dl>

</div>
</div>
<a id="a1f19ec0c200c3b56bbcb517d12f30a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f19ec0c200c3b56bbcb517d12f30a22">&#9670;&nbsp;</a></span>isSPD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isSPD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if matrix is symmetric positive definite(SPD), false otherwise </dd></dl>

</div>
</div>
<a id="aa217a194c7a3be2e1a82f6d20248c0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa217a194c7a3be2e1a82f6d20248c0ba">&#9670;&nbsp;</a></span>isStructurallySymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isStructurallySymmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true is matrix is symmetric struturally, false otherwise </dd></dl>

</div>
</div>
<a id="a01e3110e30e9f413dcccdf1b659afef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e3110e30e9f413dcccdf1b659afef8">&#9670;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true is matrix is symmetric, false otherwise </dd></dl>

</div>
</div>
<a id="a02c2d679bb05e71a9eeabefe991ec812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c2d679bb05e71a9eeabefe991ec812">&#9670;&nbsp;</a></span>isTransposeOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::isTransposeOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Trans</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>this</code> is the transpose of Trans, false otherwise </dd></dl>

</div>
</div>
<a id="a82b896d0669d8ba227aaa189663c587a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b896d0669d8ba227aaa189663c587a">&#9670;&nbsp;</a></span>l1Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::l1Norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the l1-norm of the matrix, that is \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\), (max. </p>
<p>sum of columns).</p>
<p>This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. \(|Mv|_1\leq |M|_1 |v|_1\). </p>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenDense.html#a118835a072d8b26a6733a39b353ffee9">Feel::MatrixEigenDense&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenSparse.html#ad983607d12c7433c23737fa53f217185">Feel::MatrixEigenSparse&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ab1aeca146775f1151a3669e03c546538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1aeca146775f1151a3669e03c546538">&#9670;&nbsp;</a></span>linftyNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::linftyNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the linfty-norm of the matrix, that is. </p>
<p>\(|M|_\infty=max_{all rows i}\sum_{all columns j} |M_ij|\),</p>
<p>(max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. \(|Mv|_\infty \leq |M|_\infty |v|_\infty\). </p>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenDense.html#a8e7dd1dae313f8c6bc9c66148684b558">Feel::MatrixEigenDense&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenSparse.html#a5563ab69cfcf5b33b603fd44d5b6404f">Feel::MatrixEigenSparse&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ad2645f380bddc0bd0031a4663fc23587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2645f380bddc0bd0031a4663fc23587">&#9670;&nbsp;</a></span>nnz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_type <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::nnz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of allocated non-zero entries </dd></dl>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#a11dd2289c22f8027ac46ef0f00a71375">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#ae8bec342c27ab3d8d641c41eace410a6">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a71f480700bcd3a918ed0925de10cd460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f480700bcd3a918ed0925de10cd460">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the entry <code></code>(i,j). </p>
<p>This may be an expensive operation and you should always take care where to call this function. In order to avoid abuse, this function throws an exception if the required element does not exist in the matrix.</p>
<p>In case you want a function that returns zero instead (for entries that are not in the sparsity pattern of the matrix), use the <code>el</code> function. </p>

</div>
</div>
<a id="ad79e9c5e8d3ca180ade2b929c4c4f5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79e9c5e8d3ca180ade2b929c4c4f5cc">&#9670;&nbsp;</a></span>printMatlab()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::printMatlab </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;NULL&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of the matrix in Matlab's sparse matrix format. </p>
<p>Optionally prints the matrix to the file named <code>name</code>. If <code>name</code> is not specified it is dumped to the screen. </p>

<p>Reimplemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#abf077f53e13724ca8ec8a629697967cf">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#a753d92643d6e33572cc1a163684926b4">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a140551aa8f92ad9853a67bf0d1ccc8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140551aa8f92ad9853a67bf0d1ccc8bb">&#9670;&nbsp;</a></span>reinitSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::reinitSubmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is similar to the one above, but it allows you to reuse the existing sparsity pattern of "submatrix" instead of reallocating it again. </p>
<p>This should hopefully be more efficient if you are frequently extracting submatrices of the same size. </p>

</div>
</div>
<a id="ac0333712d390479a5935088518fe5496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0333712d390479a5935088518fe5496">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the element <code></code>(i,j) to <code>value</code>. </p>
<p>Throws an error if the entry does not exist. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="a34202ecd63a380eb35a65944720de4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34202ecd63a380eb35a65944720de4f9">&#9670;&nbsp;</a></span>setMatrixProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::setMatrixProperties </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set matrix properties, </p>
<dl class="section see"><dt>See also</dt><dd>MatrixProperties </dd></dl>

</div>
</div>
<a id="a45f5d30f75f23a6a9c39e2de2ffd4ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f5d30f75f23a6a9c39e2de2ffd4ff2">&#9670;&nbsp;</a></span>size1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_type <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::size1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>m</code>, the row-dimension of the matrix where the marix is \( M \times N \). </dd></dl>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#a5889fd49f9ef687b20673e332de03c12">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#a55dd7eb37f4b4bd970f1d1950ae1ddd4">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a67d70a92c696bf3c398d8f1ba3515674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d70a92c696bf3c398d8f1ba3515674">&#9670;&nbsp;</a></span>size2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_type <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::size2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>n</code>, the column-dimension of the matrix where the marix is \( M \times N \). </dd></dl>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#a7ddfa9e98a84bcf2f71681a38a0f1e8e">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#adab95d0f39025040969847b3a551fc82">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a32ab430d70d048e5da30004e5d88ac5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ab430d70d048e5da30004e5d88ac5d">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>options</em> = <code>MATRIX_TRANSPOSE_ASSEMBLED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transpose of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mt</td><td>the matrix transposed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7a9b30f03f483b9db8dd969f6fda64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a9b30f03f483b9db8dd969f6fda64e">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt;T&gt; &gt; <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>options</em> = <code>MATRIX_TRANSPOSE_ASSEMBLED</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the transpose of the matrix </dd></dl>

</div>
</div>
<a id="a1fa5e12b2d62183ae32b7c8dc485f088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa5e12b2d62183ae32b7c8dc485f088">&#9670;&nbsp;</a></span>transpose() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>options</em> = <code>MATRIX_TRANSPOSE_ASSEMBLED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transpose of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the matrix to transpose </td></tr>
    <tr><td class="paramname">Mt</td><td>the matrix transposed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add28dc9976b0a149d2816cc881cc4037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add28dc9976b0a149d2816cc881cc4037">&#9670;&nbsp;</a></span>updateSparsityPattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::updateSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the matrix sparsity pattern. </p>
<p>When your <code>MatrixSparse&lt;T&gt;</code> implementation does not need this data simply do not overload this method. </p>

</div>
</div>
<a id="a9a377b4207ac4739478d87ba433abef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a377b4207ac4739478d87ba433abef1">&#9670;&nbsp;</a></span>zeroRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::zeroRows </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1meta_1_1Context.html">Context</a> const &amp;&#160;</td>
          <td class="paramname"><em>on_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value_on_diagonal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>eliminate rows without change pattern, and put <code>value_on_diagonal</code> on the diagonal entry </p>
<dl class="section warning"><dt>Warning</dt><dd>if the matrix was symmetric before this operation, it won't be afterwards. So use the proper solver (nonsymmetric) </dd></dl>

<p>Implemented in <a class="el" href="classFeel_1_1MatrixEigenSparse.html#abe6869b7d20c8b050d2ee994f395310d">Feel::MatrixEigenSparse&lt; T &gt;</a>, and <a class="el" href="classFeel_1_1MatrixEigenDense.html#ae50d8df30d955cf715d99516781eb891">Feel::MatrixEigenDense&lt; T &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0f77635be141df03a1067b86340b325e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f77635be141df03a1067b86340b325e">&#9670;&nbsp;</a></span>MatrixSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a> </td>
          <td>(</td>
          <td class="paramtype">worldcomm_ptr_t const &amp;&#160;</td>
          <td class="paramname"><em>worldComm</em> = <code><a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor; initializes the matrix to be empty, without any structure, i.e. </p>
<p>the matrix is not usable at all. This constructor is therefore only useful for matrices which are members of a class. All other matrices should be created at a point in the data flow where all necessary information is available.</p>
<p>You have to initialize the matrix before usage with <code>init(...)</code>. </p>

</div>
</div>
<a id="acb37362d6cff7fc03e286eda7d2788ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb37362d6cff7fc03e286eda7d2788ba">&#9670;&nbsp;</a></span>~MatrixSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeel_1_1MatrixSparse.html">Feel::MatrixSparse</a>&lt; T &gt;::~<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Free all memory, but do not release the memory of the sparsity structure. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceFeel.html">Feel</a></li><li class="navelem"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
