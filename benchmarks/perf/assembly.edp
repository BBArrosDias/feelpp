// To run this script, first go inside $HOME/feel/assembly/np_1 and make sure that the integer l defined below has the same value of --parameters.l
int l = 3;
macro grad(u)[dx(u), dy(u)]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
load "gmsh"
load "Element_P3"
real[int, int] timers(l * 3, 5);

for(int j = 1; j <= l; ++j) {
    mesh Th = gmshload("hypercube_" + j + ".msh");
    for(int i = 0; i < 4; ++i) {
        if(i == 0) {
            func Pk = P2;
            timers(j - 1, 2) = clock();
            fespace Vh(Th, Pk);
            timers(j - 1, 2) = clock() - timers(j - 1, 2);
            timers(j - 1, 0) = Th.nt;
            timers(j - 1, 1) = Vh.ndof;
            timers(j - 1, 3) = clock();
            varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
            matrix A = vPb(Vh, Vh);
            timers(j - 1, 3) = clock() - timers(j - 1, 3);
            timers(j - 1, 4) = clock();
            real[int] rhs = vPb(0, Vh);
            timers(j - 1, 4) = clock() - timers(j - 1, 4);
        }
        else if(i == 1) {
            func Pk = [P2, P2];
            timers(l + j - 1, 2) = clock();
            fespace Vh(Th, Pk);
            timers(l + j - 1, 2) = clock() - timers(l + j - 1, 2);
            timers(l + j - 1, 0) = Th.nt;
            timers(l + j - 1, 1) = Vh.ndof;
            timers(l + j - 1, 3) = clock();
            real f = -90000.;
            real strain = 100.;
            real Young = 1e7;
            real poisson = 0.4;
            real tmp = 1. + poisson;
            real mu = Young / (2. * tmp);
            real lambda = Young * poisson / (tmp * (1. - 2. * poisson));
            varf vPb([u, uB], [v, vB]) = int2d(Th)(lambda * div(u)' * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th)(f * vB) + int1d(Th, 3)(strain * vB) + on(1, u = 0.0, uB = 0.0);
            matrix A = vPb(Vh, Vh);
            timers(l + j - 1, 3) = clock() - timers(l + j - 1, 3);
            timers(l + j - 1, 4) = clock();
            real[int] rhs = vPb(0, Vh);
            timers(l + j - 1, 4) = clock() - timers(l + j - 1, 4);
        }
        else if(i == 2) {
            func Pk = [P3, P3, P2];
            timers(l * 2 + j - 1, 2) = clock();
            fespace Vh(Th, Pk);
            timers(l * 2 + j - 1, 2) = clock() - timers(l * 2 + j - 1, 2);
            timers(l * 2 + j - 1, 0) = Th.nt;
            timers(l * 2 + j - 1, 1) = Vh.ndof;
            timers(l * 2 + j - 1, 3) = clock();
            varf vPb([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
            matrix A = vPb(Vh, Vh);
            timers(l * 2 + j - 1, 3) = clock() - timers(l * 2 + j - 1, 3);
            timers(l * 2 + j - 1, 4) = clock();
            real[int] rhs = vPb(0, Vh);
            timers(l * 2 + j - 1, 4) = clock() - timers(l * 2 + j - 1, 4);
        }
    }
}
cout << "nelements\tnDof\t\tFunctionSpace\tform2\t\tform1" << endl;
cout.precision(6);
cout.fixed;
for(int j = 0; j < 3 * l; ++j) {
    for(int i = 0; i < 2; ++i)
        cout << int(timers(j, i)) << "\t\t";
    for(int i = 2; i < 5; ++i) {
        cout << timers(j, i) << "\t";
    }
    cout << endl;
}
