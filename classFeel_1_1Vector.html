<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Feel++: Feel::Vector&lt; T, SizeT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="feel_logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Feel++
   &#160;<span id="projectnumber">0.109.0-alpha.1</span>
   </div>
   <div id="projectbrief">Finite Element Embedded Library in C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classFeel_1_1Vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#friends">Friends</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classFeel_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Feel::Vector&lt; T, SizeT &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename SizeT = uint32_type&gt;<br />
class Feel::Vector&lt; T, SizeT &gt;</h3>

<p>Numeric vector. </p>
<p>Provides a uniform interface to vector storage schemes for different linear algebra libraries.</p>
<dl class="section author"><dt>Author</dt><dd>Benjamin S. Kirk, 2003 </dd>
<dd>
Christophe Prud'homme 2005 </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad5738a478236539d76804ad5b63a8359"><td class="memItemLeft" align="right" valign="top"><a id="ad5738a478236539d76804ad5b63a8359"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ad5738a478236539d76804ad5b63a8359">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T, <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ad5738a478236539d76804ad5b63a8359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but allows you to use stream syntax. <br /></td></tr>
<tr class="separator:ad5738a478236539d76804ad5b63a8359"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:affce69027cc91c6f4564c4a0ec17a0c3"><td class="memItemLeft" align="right" valign="top"><a id="affce69027cc91c6f4564c4a0ec17a0c3"></a>
typedef std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>clone_ptrtype</b></td></tr>
<tr class="separator:affce69027cc91c6f4564c4a0ec17a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7457215b2ac2f43d3536f4226876845"><td class="memItemLeft" align="right" valign="top"><a id="ae7457215b2ac2f43d3536f4226876845"></a>
typedef std::shared_ptr&lt; <a class="el" href="classFeel_1_1DataMap.html">datamap_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>datamap_ptrtype</b></td></tr>
<tr class="separator:ae7457215b2ac2f43d3536f4226876845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aa1ab13c6c6a2a19745abc7dff0604"><td class="memItemLeft" align="right" valign="top"><a id="a27aa1ab13c6c6a2a19745abc7dff0604"></a>
typedef <a class="el" href="classFeel_1_1DataMap.html">DataMap</a>&lt; <a class="el" href="classSizeT.html">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>datamap_type</b></td></tr>
<tr class="separator:a27aa1ab13c6c6a2a19745abc7dff0604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ad2a28d2319347f586c107cc08f0f8"><td class="memItemLeft" align="right" valign="top"><a id="a93ad2a28d2319347f586c107cc08f0f8"></a>
typedef <a class="el" href="structFeel_1_1type__traits.html">type_traits</a>&lt; T &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><b>real_type</b></td></tr>
<tr class="separator:a93ad2a28d2319347f586c107cc08f0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96435240e8801bf18ddce4c2392f92fc"><td class="memItemLeft" align="right" valign="top"><a id="a96435240e8801bf18ddce4c2392f92fc"></a>
typedef std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>self_ptrtype</b></td></tr>
<tr class="separator:a96435240e8801bf18ddce4c2392f92fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ed7a390d504a599c3f7ee93661812"><td class="memItemLeft" align="right" valign="top"><a id="ad44ed7a390d504a599c3f7ee93661812"></a>
typedef <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>self_type</b></td></tr>
<tr class="separator:ad44ed7a390d504a599c3f7ee93661812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fd956e956ba1e65e68c390d253c6ca"><td class="memItemLeft" align="right" valign="top"><a id="a92fd956e956ba1e65e68c390d253c6ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = <a class="el" href="classSizeT.html">SizeT</a></td></tr>
<tr class="separator:a92fd956e956ba1e65e68c390d253c6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a4cd64a973ac637f7abb448a316990"><td class="memItemLeft" align="right" valign="top"><a id="ad1a4cd64a973ac637f7abb448a316990"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ad1a4cd64a973ac637f7abb448a316990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c786a71af85a919abb26c2008cef2"><td class="memItemLeft" align="right" valign="top"><a id="ab79c786a71af85a919abb26c2008cef2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vector_ptrtype</b> = std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:ab79c786a71af85a919abb26c2008cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed27d86ac9ccd05b9c81510e72768e1c"><td class="memItemLeft" align="right" valign="top"><a id="aed27d86ac9ccd05b9c81510e72768e1c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#aed27d86ac9ccd05b9c81510e72768e1c">abs</a> ()</td></tr>
<tr class="memdesc:aed27d86ac9ccd05b9c81510e72768e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces every element in a vector with its absolute value. <br /></td></tr>
<tr class="separator:aed27d86ac9ccd05b9c81510e72768e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bb0f9447e6fbc9cc3cb6cb5bb85a80"><td class="memItemLeft" align="right" valign="top"><a id="a41bb0f9447e6fbc9cc3cb6cb5bb85a80"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a41bb0f9447e6fbc9cc3cb6cb5bb85a80">add</a> (const <a class="el" href="classSizeT.html">size_type</a> i, const value_type &amp;value)=0</td></tr>
<tr class="memdesc:a41bb0f9447e6fbc9cc3cb6cb5bb85a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">v(i) += value <br /></td></tr>
<tr class="separator:a41bb0f9447e6fbc9cc3cb6cb5bb85a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472c93f1c5c8ed620aa52113430070ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a472c93f1c5c8ed620aa52113430070ee">add</a> (const value_type &amp;a, const std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &gt; &amp;v)</td></tr>
<tr class="memdesc:a472c93f1c5c8ed620aa52113430070ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=a*V\).  <a href="classFeel_1_1Vector.html#a472c93f1c5c8ed620aa52113430070ee">More...</a><br /></td></tr>
<tr class="separator:a472c93f1c5c8ed620aa52113430070ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4679818739c8cd2d11e2133924ad973"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#aa4679818739c8cd2d11e2133924ad973">add</a> (const value_type &amp;a, const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;v)=0</td></tr>
<tr class="memdesc:aa4679818739c8cd2d11e2133924ad973"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=a*V\).  <a href="classFeel_1_1Vector.html#aa4679818739c8cd2d11e2133924ad973">More...</a><br /></td></tr>
<tr class="separator:aa4679818739c8cd2d11e2133924ad973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608b4ab1096e1c2ba742e55d1b1ca422"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a608b4ab1096e1c2ba742e55d1b1ca422">add</a> (const value_type &amp;s)=0</td></tr>
<tr class="memdesc:a608b4ab1096e1c2ba742e55d1b1ca422"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U(0-DIM)+=s\).  <a href="classFeel_1_1Vector.html#a608b4ab1096e1c2ba742e55d1b1ca422">More...</a><br /></td></tr>
<tr class="separator:a608b4ab1096e1c2ba742e55d1b1ca422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8dcd7ce680d4e41f6dc79e16d4d4d8"><td class="memItemLeft" align="right" valign="top"><a id="a5e8dcd7ce680d4e41f6dc79e16d4d4d8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a5e8dcd7ce680d4e41f6dc79e16d4d4d8">add</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;V)=0</td></tr>
<tr class="memdesc:a5e8dcd7ce680d4e41f6dc79e16d4d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=V\): Simple vector addition, equal to the <code>operator</code> +=. <br /></td></tr>
<tr class="separator:a5e8dcd7ce680d4e41f6dc79e16d4d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10996d5eba47201e308bb8880a08fd0"><td class="memItemLeft" align="right" valign="top"><a id="ae10996d5eba47201e308bb8880a08fd0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ae10996d5eba47201e308bb8880a08fd0">addVector</a> (const std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; &amp;V_in, const std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixShell.html">MatrixShell</a>&lt; T &gt; &gt; &amp;A_in)</td></tr>
<tr class="memdesc:ae10996d5eba47201e308bb8880a08fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=A*V\), add the product of a <code><a class="el" href="classFeel_1_1MatrixShell.html" title="matrices that define its action against a vector">MatrixShell</a></code> <code>A</code> and a <code><a class="el" href="classFeel_1_1Vector.html" title="Numeric vector.">Vector</a></code> <code>V</code> to <code>this</code>, where <code>this=U</code>. <br /></td></tr>
<tr class="separator:ae10996d5eba47201e308bb8880a08fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0de7d51fc1a1d8bf1b4affbab0a2c4"><td class="memItemLeft" align="right" valign="top"><a id="a6c0de7d51fc1a1d8bf1b4affbab0a2c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a6c0de7d51fc1a1d8bf1b4affbab0a2c4">addVector</a> (const std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; &amp;V_in, const std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &gt; &amp;A_in)</td></tr>
<tr class="memdesc:a6c0de7d51fc1a1d8bf1b4affbab0a2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=A*V\), add the product of a <code>SparseMatrix</code> <code>A</code> and a <code><a class="el" href="classFeel_1_1Vector.html" title="Numeric vector.">Vector</a></code> <code>V</code> to <code>this</code>, where <code>this=U</code>. <br /></td></tr>
<tr class="separator:a6c0de7d51fc1a1d8bf1b4affbab0a2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb342e100d07c53af7d25841e8f4be3"><td class="memItemLeft" align="right" valign="top"><a id="a2eb342e100d07c53af7d25841e8f4be3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a2eb342e100d07c53af7d25841e8f4be3">addVector</a> (const std::vector&lt; T &gt; &amp;v, const std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;dof_indices)=0</td></tr>
<tr class="memdesc:a2eb342e100d07c53af7d25841e8f4be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( U+=v \) where v is a ublas::vector&lt;T&gt; and you want to specify WHERE to add it <br /></td></tr>
<tr class="separator:a2eb342e100d07c53af7d25841e8f4be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585008223cc8f3dc74afb9047b7fab51"><td class="memItemLeft" align="right" valign="top"><a id="a585008223cc8f3dc74afb9047b7fab51"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a585008223cc8f3dc74afb9047b7fab51">addVector</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;V, const std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;dof_indices)=0</td></tr>
<tr class="memdesc:a585008223cc8f3dc74afb9047b7fab51"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=V\), where U and V are type <a class="el" href="classFeel_1_1Vector.html">Vector&lt;T&gt;</a> and you want to specify WHERE to add the <a class="el" href="classFeel_1_1Vector.html">Vector&lt;T&gt;</a> V <br /></td></tr>
<tr class="separator:a585008223cc8f3dc74afb9047b7fab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c10cddefa251c000ee6e0c95767995"><td class="memItemLeft" align="right" valign="top"><a id="a14c10cddefa251c000ee6e0c95767995"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a14c10cddefa251c000ee6e0c95767995">addVector</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;V_in, const <a class="el" href="classFeel_1_1MatrixShell.html">MatrixShell</a>&lt; T &gt; &amp;A_in)</td></tr>
<tr class="memdesc:a14c10cddefa251c000ee6e0c95767995"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=A*V\), add the product of a <code><a class="el" href="classFeel_1_1MatrixShell.html" title="matrices that define its action against a vector">MatrixShell</a></code> <code>A</code> and a <code><a class="el" href="classFeel_1_1Vector.html" title="Numeric vector.">Vector</a></code> <code>V</code> to <code>this</code>, where <code>this=U</code>. <br /></td></tr>
<tr class="separator:a14c10cddefa251c000ee6e0c95767995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee86a1fb65026583c937f851645033f"><td class="memItemLeft" align="right" valign="top"><a id="a7ee86a1fb65026583c937f851645033f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a7ee86a1fb65026583c937f851645033f">addVector</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;V_in, const <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; T &gt; &amp;A_in)=0</td></tr>
<tr class="memdesc:a7ee86a1fb65026583c937f851645033f"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U+=A*V\), add the product of a <code>SparseMatrix</code> <code>A</code> and a <code><a class="el" href="classFeel_1_1Vector.html" title="Numeric vector.">Vector</a></code> <code>V</code> to <code>this</code>, where <code>this=U</code>. <br /></td></tr>
<tr class="separator:a7ee86a1fb65026583c937f851645033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6064b79e742d200156b2b3a58ca59b9f"><td class="memItemLeft" align="right" valign="top"><a id="a6064b79e742d200156b2b3a58ca59b9f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a6064b79e742d200156b2b3a58ca59b9f">addVector</a> (<a class="el" href="classint.html">int</a> *i, <a class="el" href="classint.html">int</a> n, value_type *v, <a class="el" href="classSizeT.html">size_type</a> K, <a class="el" href="classSizeT.html">size_type</a> K2)=0</td></tr>
<tr class="memdesc:a6064b79e742d200156b2b3a58ca59b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">v([i1,i2,...,in]) += [value1,...,valuen] <br /></td></tr>
<tr class="separator:a6064b79e742d200156b2b3a58ca59b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255cec5b14ed90a8961c049d38c51131"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a255cec5b14ed90a8961c049d38c51131">clear</a> ()</td></tr>
<tr class="separator:a255cec5b14ed90a8961c049d38c51131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f4af2c4a549737f6c095f9e3a09b89"><td class="memItemLeft" align="right" valign="top">virtual clone_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ab0f4af2c4a549737f6c095f9e3a09b89">clone</a> () const =0</td></tr>
<tr class="memdesc:ab0f4af2c4a549737f6c095f9e3a09b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of this vector and returns it in an <code>shared_ptr&lt;&gt;</code>.  <a href="classFeel_1_1Vector.html#ab0f4af2c4a549737f6c095f9e3a09b89">More...</a><br /></td></tr>
<tr class="separator:ab0f4af2c4a549737f6c095f9e3a09b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f8da7ff53284a78b7305f96f6b0f1f"><td class="memItemLeft" align="right" valign="top"><a id="a61f8da7ff53284a78b7305f96f6b0f1f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a61f8da7ff53284a78b7305f96f6b0f1f">close</a> ()=0</td></tr>
<tr class="memdesc:a61f8da7ff53284a78b7305f96f6b0f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the assemble functions. <br /></td></tr>
<tr class="separator:a61f8da7ff53284a78b7305f96f6b0f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435eab103fba473ddc12482e9a5e3d39"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a435eab103fba473ddc12482e9a5e3d39">closed</a> () const</td></tr>
<tr class="separator:a435eab103fba473ddc12482e9a5e3d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4fa1761353a59127c141a67984fe54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFeel_1_1WorldComm.html">WorldComm</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a8b4fa1761353a59127c141a67984fe54">comm</a> () const</td></tr>
<tr class="separator:a8b4fa1761353a59127c141a67984fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4673a8a146bd4d106ade28b61df42445"><td class="memItemLeft" align="right" valign="top">worldcomm_ptr_t const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a4673a8a146bd4d106ade28b61df42445">commPtr</a> () const</td></tr>
<tr class="separator:a4673a8a146bd4d106ade28b61df42445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb6680bcf998c9cf59cb40355d47251"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#aafb6680bcf998c9cf59cb40355d47251">compare</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other_vector, const real_type threshold=1e-10) const</td></tr>
<tr class="separator:aafb6680bcf998c9cf59cb40355d47251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa11065234f40eb1366f86c64e3d9aaa"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#aaa11065234f40eb1366f86c64e3d9aaa">createSubVector</a> (std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; const &amp;rows, bool checkAndFixRange=true) const</td></tr>
<tr class="memdesc:aaa11065234f40eb1366f86c64e3d9aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the subvector "subvector" from the indices in the "rows" array.  <a href="classFeel_1_1Vector.html#aaa11065234f40eb1366f86c64e3d9aaa">More...</a><br /></td></tr>
<tr class="separator:aaa11065234f40eb1366f86c64e3d9aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5b6a3090b66705651500a0091433c6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ada5b6a3090b66705651500a0091433c6">createSubvector</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;, const std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;) const</td></tr>
<tr class="memdesc:ada5b6a3090b66705651500a0091433c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the subvector "subvector" from the indices in the "rows" array.  <a href="classFeel_1_1Vector.html#ada5b6a3090b66705651500a0091433c6">More...</a><br /></td></tr>
<tr class="separator:ada5b6a3090b66705651500a0091433c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214d18fb09e933ddae91a38b55b44ebe"><td class="memItemLeft" align="right" valign="top"><a id="a214d18fb09e933ddae91a38b55b44ebe"></a>
virtual value_type&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; const &amp;v) const</td></tr>
<tr class="separator:a214d18fb09e933ddae91a38b55b44ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de87c225e311af527b506d41217fb0e"><td class="memItemLeft" align="right" valign="top"><a id="a7de87c225e311af527b506d41217fb0e"></a>
virtual value_type&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;v) const =0</td></tr>
<tr class="separator:a7de87c225e311af527b506d41217fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf09e5e3e8884de9120f7efc399215c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSizeT.html">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#adbf09e5e3e8884de9120f7efc399215c">firstLocalIndex</a> () const</td></tr>
<tr class="separator:adbf09e5e3e8884de9120f7efc399215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc7dc46db404edcaeace99c01651ca3"><td class="memItemLeft" align="right" valign="top"><a id="a4bc7dc46db404edcaeace99c01651ca3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a4bc7dc46db404edcaeace99c01651ca3">init</a> (const <a class="el" href="classSizeT.html">size_type</a>, const bool=false)</td></tr>
<tr class="memdesc:a4bc7dc46db404edcaeace99c01651ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">call init with n_local = N, <br /></td></tr>
<tr class="separator:a4bc7dc46db404edcaeace99c01651ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325bd3e3b14ac591b40fae23724b61c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a325bd3e3b14ac591b40fae23724b61c4">init</a> (const <a class="el" href="classSizeT.html">size_type</a>, const <a class="el" href="classSizeT.html">size_type</a>, const bool=false)</td></tr>
<tr class="memdesc:a325bd3e3b14ac591b40fae23724b61c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the dimension of the vector to <code>N</code>.  <a href="classFeel_1_1Vector.html#a325bd3e3b14ac591b40fae23724b61c4">More...</a><br /></td></tr>
<tr class="separator:a325bd3e3b14ac591b40fae23724b61c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cedc0ef404148ad19f5f1dcc2c0f9f"><td class="memItemLeft" align="right" valign="top"><a id="af8cedc0ef404148ad19f5f1dcc2c0f9f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#af8cedc0ef404148ad19f5f1dcc2c0f9f">init</a> (datamap_ptrtype const &amp;dm)</td></tr>
<tr class="memdesc:af8cedc0ef404148ad19f5f1dcc2c0f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">call init with datamap, <br /></td></tr>
<tr class="separator:af8cedc0ef404148ad19f5f1dcc2c0f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca543dfc0923170d7e83fe263eccf94c"><td class="memItemLeft" align="right" valign="top"><a id="aca543dfc0923170d7e83fe263eccf94c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#aca543dfc0923170d7e83fe263eccf94c">insert</a> (const std::vector&lt; T &gt; &amp;v, const std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;dof_indices)=0</td></tr>
<tr class="memdesc:aca543dfc0923170d7e83fe263eccf94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( U=v \) where v is a DenseVector&lt;T&gt; and you want to specify WHERE to insert it <br /></td></tr>
<tr class="separator:aca543dfc0923170d7e83fe263eccf94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac244d82c78af4abc101437e8b51ef2dd"><td class="memItemLeft" align="right" valign="top"><a id="ac244d82c78af4abc101437e8b51ef2dd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ac244d82c78af4abc101437e8b51ef2dd">insert</a> (const ublas::vector&lt; T &gt; &amp;V, const std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;dof_indices)=0</td></tr>
<tr class="memdesc:ac244d82c78af4abc101437e8b51ef2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( U+=V \) where U and V are type DenseVector&lt;T&gt; and you want to specify WHERE to insert the DenseVector&lt;T&gt; V <br /></td></tr>
<tr class="separator:ac244d82c78af4abc101437e8b51ef2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a872fa779485ee54dbdb3ee16f00b33"><td class="memItemLeft" align="right" valign="top"><a id="a1a872fa779485ee54dbdb3ee16f00b33"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a1a872fa779485ee54dbdb3ee16f00b33">insert</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;V, const std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;dof_indices)=0</td></tr>
<tr class="memdesc:a1a872fa779485ee54dbdb3ee16f00b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U=V\), where U and V are type <a class="el" href="classFeel_1_1Vector.html">Vector&lt;T&gt;</a> and you want to specify WHERE to insert the <a class="el" href="classFeel_1_1Vector.html">Vector&lt;T&gt;</a> V <br /></td></tr>
<tr class="separator:a1a872fa779485ee54dbdb3ee16f00b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d84e6190e89e195171d64ce1803af9a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a8d84e6190e89e195171d64ce1803af9a">isInitialized</a> () const</td></tr>
<tr class="separator:a8d84e6190e89e195171d64ce1803af9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9964c89cd2658906fc5db8b7f7bd560"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#af9964c89cd2658906fc5db8b7f7bd560">l1Norm</a> () const =0</td></tr>
<tr class="memdesc:af9964c89cd2658906fc5db8b7f7bd560"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the max component as well as the index of the max component  <a href="classFeel_1_1Vector.html#af9964c89cd2658906fc5db8b7f7bd560">More...</a><br /></td></tr>
<tr class="separator:af9964c89cd2658906fc5db8b7f7bd560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f136155f018e1876a7bcce27484f08"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ae3f136155f018e1876a7bcce27484f08">l2Norm</a> () const =0</td></tr>
<tr class="separator:ae3f136155f018e1876a7bcce27484f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e6aebc864bfac106733af7c592c0d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSizeT.html">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#af5e6aebc864bfac106733af7c592c0d5">lastLocalIndex</a> () const</td></tr>
<tr class="separator:af5e6aebc864bfac106733af7c592c0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ee8fdb752413f35e4fd7ab7c9d08e0"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a74ee8fdb752413f35e4fd7ab7c9d08e0">linftyNorm</a> () const =0</td></tr>
<tr class="separator:a74ee8fdb752413f35e4fd7ab7c9d08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043fee879e79b07442c34c7bbeb8f54b"><td class="memItemLeft" align="right" valign="top"><a id="a043fee879e79b07442c34c7bbeb8f54b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>load</b> (std::string const &amp;filename=&quot;default_archive_name&quot;, std::string const &amp;format=&quot;binary&quot;)</td></tr>
<tr class="separator:a043fee879e79b07442c34c7bbeb8f54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b54069550e91e8e77bc1b5887cc56a"><td class="memItemLeft" align="right" valign="top"><a id="a03b54069550e91e8e77bc1b5887cc56a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>localIndexIsGhost</b> (<a class="el" href="classSizeT.html">size_type</a> localDof) const</td></tr>
<tr class="separator:a03b54069550e91e8e77bc1b5887cc56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448842584c50fea57afbb873b521ea5"><td class="memItemLeft" align="right" valign="top"><a id="a3448842584c50fea57afbb873b521ea5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>localize</b> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;V)</td></tr>
<tr class="separator:a3448842584c50fea57afbb873b521ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a73d96ec40251a2a073f652e049665"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSizeT.html">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a29a73d96ec40251a2a073f652e049665">localSize</a> () const</td></tr>
<tr class="separator:a29a73d96ec40251a2a073f652e049665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a89803f92e116cd4faaa65443ad92f"><td class="memItemLeft" align="right" valign="top"><a id="ad1a89803f92e116cd4faaa65443ad92f"></a>
<a class="el" href="classFeel_1_1DataMap.html">datamap_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>map</b> () const</td></tr>
<tr class="separator:ad1a89803f92e116cd4faaa65443ad92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77494f12bd89055e3e4e5472b9de32f"><td class="memItemLeft" align="right" valign="top"><a id="af77494f12bd89055e3e4e5472b9de32f"></a>
datamap_ptrtype const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>mapPtr</b> () const</td></tr>
<tr class="separator:af77494f12bd89055e3e4e5472b9de32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdd5e9cc7bedb4608dc92050372878a"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a2cdd5e9cc7bedb4608dc92050372878a">max</a> () const =0</td></tr>
<tr class="memdesc:a2cdd5e9cc7bedb4608dc92050372878a"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the min component as well as the index of the min component  <a href="classFeel_1_1Vector.html#a2cdd5e9cc7bedb4608dc92050372878a">More...</a><br /></td></tr>
<tr class="separator:a2cdd5e9cc7bedb4608dc92050372878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b21d546abe568f2045a0f6562fa8407"><td class="memItemLeft" align="right" valign="top"><a id="a5b21d546abe568f2045a0f6562fa8407"></a>
virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><b>maxWithIndex</b> (<a class="el" href="classint.html">int</a> *index=nullptr) const</td></tr>
<tr class="separator:a5b21d546abe568f2045a0f6562fa8407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad395c1fe95a789e9243cf780aa7413ba"><td class="memItemLeft" align="right" valign="top">virtual real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ad395c1fe95a789e9243cf780aa7413ba">min</a> () const =0</td></tr>
<tr class="separator:ad395c1fe95a789e9243cf780aa7413ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be5bf8bf2fde998c6da3ac7a034604a"><td class="memItemLeft" align="right" valign="top"><a id="a5be5bf8bf2fde998c6da3ac7a034604a"></a>
virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a5be5bf8bf2fde998c6da3ac7a034604a">operator()</a> (const <a class="el" href="classSizeT.html">size_type</a> i) const =0</td></tr>
<tr class="memdesc:a5be5bf8bf2fde998c6da3ac7a034604a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access components, returns <code>U(i)</code>. <br /></td></tr>
<tr class="separator:a5be5bf8bf2fde998c6da3ac7a034604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0979c39f3b1377eccaaeb115bd29c671"><td class="memItemLeft" align="right" valign="top"><a id="a0979c39f3b1377eccaaeb115bd29c671"></a>
virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const <a class="el" href="classSizeT.html">size_type</a> i)=0</td></tr>
<tr class="separator:a0979c39f3b1377eccaaeb115bd29c671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050876ab2adda9ce7c8688533fed1a38"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a050876ab2adda9ce7c8688533fed1a38">operator+=</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;V)=0</td></tr>
<tr class="memdesc:a050876ab2adda9ce7c8688533fed1a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator.  <a href="classFeel_1_1Vector.html#a050876ab2adda9ce7c8688533fed1a38">More...</a><br /></td></tr>
<tr class="separator:a050876ab2adda9ce7c8688533fed1a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c99cf8e37876db1f2d13705d2908bf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a0c99cf8e37876db1f2d13705d2908bf4">operator-=</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;V)=0</td></tr>
<tr class="memdesc:a0c99cf8e37876db1f2d13705d2908bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator.  <a href="classFeel_1_1Vector.html#a0c99cf8e37876db1f2d13705d2908bf4">More...</a><br /></td></tr>
<tr class="separator:a0c99cf8e37876db1f2d13705d2908bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fa936aff5f986014c6b1cfc6de02b7"><td class="memItemLeft" align="right" valign="top"><a id="a63fa936aff5f986014c6b1cfc6de02b7"></a>
<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a63fa936aff5f986014c6b1cfc6de02b7">operator=</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a63fa936aff5f986014c6b1cfc6de02b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U = V\): copy all components. <br /></td></tr>
<tr class="separator:a63fa936aff5f986014c6b1cfc6de02b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9858398bd926dee5eb796009ca934e7"><td class="memItemLeft" align="right" valign="top"><a id="aa9858398bd926dee5eb796009ca934e7"></a>
<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#aa9858398bd926dee5eb796009ca934e7">operator=</a> (const T s)</td></tr>
<tr class="memdesc:aa9858398bd926dee5eb796009ca934e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U(0-N) = s\): fill all components. <br /></td></tr>
<tr class="separator:aa9858398bd926dee5eb796009ca934e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d679c55cf663c211e2dfdd67f7eda2c"><td class="memItemLeft" align="right" valign="top"><a id="a6d679c55cf663c211e2dfdd67f7eda2c"></a>
virtual <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a6d679c55cf663c211e2dfdd67f7eda2c">operator=</a> (const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;V)</td></tr>
<tr class="memdesc:a6d679c55cf663c211e2dfdd67f7eda2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(U = V\): copy all components. <br /></td></tr>
<tr class="separator:a6d679c55cf663c211e2dfdd67f7eda2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2499a77b736fb97061a29db8acf158a9"><td class="memItemLeft" align="right" valign="top"><a id="a2499a77b736fb97061a29db8acf158a9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a2499a77b736fb97061a29db8acf158a9">pointwiseDivide</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;x, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;y)</td></tr>
<tr class="memdesc:a2499a77b736fb97061a29db8acf158a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(v = x/y\): coefficient-wise divide <br /></td></tr>
<tr class="separator:a2499a77b736fb97061a29db8acf158a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ad7e3ace65cfd0bab9cfbaeb8aae6b"><td class="memItemLeft" align="right" valign="top"><a id="ae2ad7e3ace65cfd0bab9cfbaeb8aae6b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ae2ad7e3ace65cfd0bab9cfbaeb8aae6b">pointwiseMult</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;x, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;y)</td></tr>
<tr class="memdesc:ae2ad7e3ace65cfd0bab9cfbaeb8aae6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(v = x*y\): coefficient-wise multiplication <br /></td></tr>
<tr class="separator:ae2ad7e3ace65cfd0bab9cfbaeb8aae6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8033092f93c45b866dd2f4920b8caf"><td class="memItemLeft" align="right" valign="top"><a id="ada8033092f93c45b866dd2f4920b8caf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ada8033092f93c45b866dd2f4920b8caf">print</a> (std::ostream &amp;os=std::cout) const</td></tr>
<tr class="memdesc:ada8033092f93c45b866dd2f4920b8caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of the vector to the screen. <br /></td></tr>
<tr class="separator:ada8033092f93c45b866dd2f4920b8caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a136d63e66d97309ab768fc09ff00c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a47a136d63e66d97309ab768fc09ff00c">printMatlab</a> (const std::string name=&quot;NULL&quot;, bool renumber=false) const =0</td></tr>
<tr class="memdesc:a47a136d63e66d97309ab768fc09ff00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the matrix in Matlab's sparse matrix format.  <a href="classFeel_1_1Vector.html#a47a136d63e66d97309ab768fc09ff00c">More...</a><br /></td></tr>
<tr class="separator:a47a136d63e66d97309ab768fc09ff00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad179d69ad8f0b864be3f32a0ef4d196a"><td class="memItemLeft" align="right" valign="top"><a id="ad179d69ad8f0b864be3f32a0ef4d196a"></a>
virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ad179d69ad8f0b864be3f32a0ef4d196a">reciprocal</a> ()</td></tr>
<tr class="memdesc:ad179d69ad8f0b864be3f32a0ef4d196a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each component of a vector by its reciprocal. <br /></td></tr>
<tr class="separator:ad179d69ad8f0b864be3f32a0ef4d196a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e81c971fa76374f3c75b91c15bafa8"><td class="memItemLeft" align="right" valign="top"><a id="a83e81c971fa76374f3c75b91c15bafa8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>save</b> (std::string const &amp;filename=&quot;default_archive_name&quot;, std::string const &amp;format=&quot;binary&quot;)</td></tr>
<tr class="separator:a83e81c971fa76374f3c75b91c15bafa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964fd6d5ccf95c689b2eef1e7b1bb328"><td class="memItemLeft" align="right" valign="top"><a id="a964fd6d5ccf95c689b2eef1e7b1bb328"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a964fd6d5ccf95c689b2eef1e7b1bb328">scale</a> (const T factor)=0</td></tr>
<tr class="memdesc:a964fd6d5ccf95c689b2eef1e7b1bb328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale each element of the vector by the given factor. <br /></td></tr>
<tr class="separator:a964fd6d5ccf95c689b2eef1e7b1bb328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0548a7391eb3a02ab0dfb0f11ce04a2e"><td class="memItemLeft" align="right" valign="top"><a id="a0548a7391eb3a02ab0dfb0f11ce04a2e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a0548a7391eb3a02ab0dfb0f11ce04a2e">set</a> (const <a class="el" href="classSizeT.html">size_type</a> i, const value_type &amp;value)=0</td></tr>
<tr class="memdesc:a0548a7391eb3a02ab0dfb0f11ce04a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">v(i) = value <br /></td></tr>
<tr class="separator:a0548a7391eb3a02ab0dfb0f11ce04a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95455fd539611a2d171adc920e12e7d"><td class="memItemLeft" align="right" valign="top"><a id="ae95455fd539611a2d171adc920e12e7d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ae95455fd539611a2d171adc920e12e7d">setConstant</a> (value_type v)=0</td></tr>
<tr class="memdesc:ae95455fd539611a2d171adc920e12e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the entries to the constant <code>v</code> <br /></td></tr>
<tr class="separator:ae95455fd539611a2d171adc920e12e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e814582e5e237665c3cc8015211fbf"><td class="memItemLeft" align="right" valign="top"><a id="a31e814582e5e237665c3cc8015211fbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a31e814582e5e237665c3cc8015211fbf">setInitialized</a> (bool b)</td></tr>
<tr class="memdesc:a31e814582e5e237665c3cc8015211fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">set initialized only for subclasses <br /></td></tr>
<tr class="separator:a31e814582e5e237665c3cc8015211fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58975fcf3906f9a20fa7b817f8c5a924"><td class="memItemLeft" align="right" valign="top"><a id="a58975fcf3906f9a20fa7b817f8c5a924"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a58975fcf3906f9a20fa7b817f8c5a924">setIsClosed</a> (bool b)</td></tr>
<tr class="memdesc:a58975fcf3906f9a20fa7b817f8c5a924"><td class="mdescLeft">&#160;</td><td class="mdescRight">@ set false if the vector is in assembly state and need to be closed for some next used (global operation) , false otherwise. <br /></td></tr>
<tr class="separator:a58975fcf3906f9a20fa7b817f8c5a924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fbe030599cae96512c5646375d19bc"><td class="memItemLeft" align="right" valign="top"><a id="a36fbe030599cae96512c5646375d19bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMap</b> (datamap_ptrtype const &amp;d)</td></tr>
<tr class="separator:a36fbe030599cae96512c5646375d19bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec42a9ffc6d45b6633aa567d3055a6"><td class="memItemLeft" align="right" valign="top"><a id="a15ec42a9ffc6d45b6633aa567d3055a6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a15ec42a9ffc6d45b6633aa567d3055a6">setOnes</a> ()</td></tr>
<tr class="memdesc:a15ec42a9ffc6d45b6633aa567d3055a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the entries to 1 <br /></td></tr>
<tr class="separator:a15ec42a9ffc6d45b6633aa567d3055a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7000f32c5a4e6eb2081dc8c6c680bf0"><td class="memItemLeft" align="right" valign="top"><a id="af7000f32c5a4e6eb2081dc8c6c680bf0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#af7000f32c5a4e6eb2081dc8c6c680bf0">setVector</a> (<a class="el" href="classint.html">int</a> *i, <a class="el" href="classint.html">int</a> n, value_type *v)=0</td></tr>
<tr class="memdesc:af7000f32c5a4e6eb2081dc8c6c680bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">v([i1,i2,...,in]) = [value1,...,valuen] <br /></td></tr>
<tr class="separator:af7000f32c5a4e6eb2081dc8c6c680bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483f31a7152063529143a841c988590c"><td class="memItemLeft" align="right" valign="top"><a id="a483f31a7152063529143a841c988590c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a483f31a7152063529143a841c988590c">setZero</a> ()</td></tr>
<tr class="memdesc:a483f31a7152063529143a841c988590c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the entries to 0 <br /></td></tr>
<tr class="separator:a483f31a7152063529143a841c988590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1db22f2b504db0cffbb156ef0f41928"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSizeT.html">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#aa1db22f2b504db0cffbb156ef0f41928">size</a> () const</td></tr>
<tr class="separator:aa1db22f2b504db0cffbb156ef0f41928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f3e88db862b9685269b0863d17e26b"><td class="memItemLeft" align="right" valign="top">virtual value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a54f3e88db862b9685269b0863d17e26b">sum</a> () const =0</td></tr>
<tr class="separator:a54f3e88db862b9685269b0863d17e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b0d90a2c9ac077e564012f318cd680"><td class="memItemLeft" align="right" valign="top"><a id="af3b0d90a2c9ac077e564012f318cd680"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#af3b0d90a2c9ac077e564012f318cd680">updateSubVector</a> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &gt; &amp;subvector, std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; const &amp;rows, bool <a class="el" href="classFeel_1_1Vector.html#a325bd3e3b14ac591b40fae23724b61c4">init</a>=true)</td></tr>
<tr class="memdesc:af3b0d90a2c9ac077e564012f318cd680"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy vector entries in subvector ( subvector is already built from a createSubVector) row indices given in the "rows" entries. <br /></td></tr>
<tr class="separator:af3b0d90a2c9ac077e564012f318cd680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cee28db3619ab3c3efc5d870b2174a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a2cee28db3619ab3c3efc5d870b2174a9">Vector</a> (const <a class="el" href="classSizeT.html">size_type</a> n, const <a class="el" href="classSizeT.html">size_type</a> n_local, worldcomm_ptr_t const &amp;_worldComm=<a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>())</td></tr>
<tr class="memdesc:a2cee28db3619ab3c3efc5d870b2174a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classFeel_1_1Vector.html#a2cee28db3619ab3c3efc5d870b2174a9">More...</a><br /></td></tr>
<tr class="separator:a2cee28db3619ab3c3efc5d870b2174a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668fcb09d915f68d46b573f0740cb220"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a668fcb09d915f68d46b573f0740cb220">Vector</a> (const <a class="el" href="classSizeT.html">size_type</a> n, worldcomm_ptr_t const &amp;_worldComm=<a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>())</td></tr>
<tr class="memdesc:a668fcb09d915f68d46b573f0740cb220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classFeel_1_1Vector.html#a668fcb09d915f68d46b573f0740cb220">More...</a><br /></td></tr>
<tr class="separator:a668fcb09d915f68d46b573f0740cb220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdac88a40ad7460af00014ca28e3af0"><td class="memItemLeft" align="right" valign="top"><a id="adcdac88a40ad7460af00014ca28e3af0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (datamap_ptrtype const &amp;n)</td></tr>
<tr class="separator:adcdac88a40ad7460af00014ca28e3af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5e2e3fc0b0cd027746ff3a30882d52"><td class="memItemLeft" align="right" valign="top"><a id="a8f5e2e3fc0b0cd027746ff3a30882d52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (<a class="el" href="classFeel_1_1Vector.html">Vector</a> const &amp;v)</td></tr>
<tr class="separator:a8f5e2e3fc0b0cd027746ff3a30882d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b9593607359356e6161ed6d6924313"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a56b9593607359356e6161ed6d6924313">Vector</a> (worldcomm_ptr_t const &amp;_worldComm=<a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>())</td></tr>
<tr class="memdesc:a56b9593607359356e6161ed6d6924313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy-Constructor.  <a href="classFeel_1_1Vector.html#a56b9593607359356e6161ed6d6924313">More...</a><br /></td></tr>
<tr class="separator:a56b9593607359356e6161ed6d6924313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14039922d995a0a0933e49af2c55c29"><td class="memItemLeft" align="right" valign="top">worldcomm_ptr_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#af14039922d995a0a0933e49af2c55c29">worldCommPtr</a> ()</td></tr>
<tr class="separator:af14039922d995a0a0933e49af2c55c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b625f1981df1612a1169f19fc2699b3"><td class="memItemLeft" align="right" valign="top">worldcomm_ptr_t const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a2b625f1981df1612a1169f19fc2699b3">worldCommPtr</a> () const</td></tr>
<tr class="separator:a2b625f1981df1612a1169f19fc2699b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bbf4b97037ff0484d01e5b9a0ef396"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a80bbf4b97037ff0484d01e5b9a0ef396">zero</a> ()=0</td></tr>
<tr class="memdesc:a80bbf4b97037ff0484d01e5b9a0ef396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero.  <a href="classFeel_1_1Vector.html#a80bbf4b97037ff0484d01e5b9a0ef396">More...</a><br /></td></tr>
<tr class="separator:a80bbf4b97037ff0484d01e5b9a0ef396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f4b5f045bf0d95462ff24b53030908"><td class="memItemLeft" align="right" valign="top"><a id="a99f4b5f045bf0d95462ff24b53030908"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a99f4b5f045bf0d95462ff24b53030908">zero</a> (<a class="el" href="classSizeT.html">size_type</a>, <a class="el" href="classSizeT.html">size_type</a>)=0</td></tr>
<tr class="memdesc:a99f4b5f045bf0d95462ff24b53030908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set entries to zero between <code>start</code> and <code>stop</code>. <br /></td></tr>
<tr class="separator:a99f4b5f045bf0d95462ff24b53030908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f40cffa2afd095299a5cc0d37dc55d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a28f40cffa2afd095299a5cc0d37dc55d">~Vector</a> ()</td></tr>
<tr class="memdesc:a28f40cffa2afd095299a5cc0d37dc55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, deallocates memory.  <a href="classFeel_1_1Vector.html#a28f40cffa2afd095299a5cc0d37dc55d">More...</a><br /></td></tr>
<tr class="separator:a28f40cffa2afd095299a5cc0d37dc55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5846aed2f59c8d447d81e7a8b220aa6f"><td class="memItemLeft" align="right" valign="top"><a id="a5846aed2f59c8d447d81e7a8b220aa6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a5846aed2f59c8d447d81e7a8b220aa6f">M_is_closed</a></td></tr>
<tr class="memdesc:a5846aed2f59c8d447d81e7a8b220aa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to see if the Numeric assemble routines have been called yet. <br /></td></tr>
<tr class="separator:a5846aed2f59c8d447d81e7a8b220aa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac540187c0df217bd7d4ff05bb83f6b0e"><td class="memItemLeft" align="right" valign="top"><a id="ac540187c0df217bd7d4ff05bb83f6b0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#ac540187c0df217bd7d4ff05bb83f6b0e">M_is_initialized</a></td></tr>
<tr class="memdesc:ac540187c0df217bd7d4ff05bb83f6b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to tell if init has been called yet. <br /></td></tr>
<tr class="separator:ac540187c0df217bd7d4ff05bb83f6b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1253c3dac17c46892c3b0a656d1d8c3c"><td class="memItemLeft" align="right" valign="top"><a id="a1253c3dac17c46892c3b0a656d1d8c3c"></a>
datamap_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1Vector.html#a1253c3dac17c46892c3b0a656d1d8c3c">M_map</a></td></tr>
<tr class="memdesc:a1253c3dac17c46892c3b0a656d1d8c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">data distribution map of the vector over the processors <br /></td></tr>
<tr class="separator:a1253c3dac17c46892c3b0a656d1d8c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a472c93f1c5c8ed620aa52113430070ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472c93f1c5c8ed620aa52113430070ee">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\(U+=a*V\). </p>
<p>Simple vector addition, equal to the <code>operator</code> +=. </p>

</div>
</div>
<a id="aa4679818739c8cd2d11e2133924ad973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4679818739c8cd2d11e2133924ad973">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\(U+=a*V\). </p>
<p>Simple vector addition, equal to the <code>operator</code> +=. </p>

<p>Implemented in <a class="el" href="classFeel_1_1VectorEigen.html#ab41f09c0d3f0791b85fc8291150fd4be">Feel::VectorEigen&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a608b4ab1096e1c2ba742e55d1b1ca422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608b4ab1096e1c2ba742e55d1b1ca422">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\(U(0-DIM)+=s\). </p>
<p>Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector. </p>

<p>Implemented in <a class="el" href="classFeel_1_1VectorEigen.html#ae80feb0809c2c8e4706acfcee6e3d6ab">Feel::VectorEigen&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a255cec5b14ed90a8961c049d38c51131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255cec5b14ed90a8961c049d38c51131">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <code><a class="el" href="classFeel_1_1Vector.html">Vector&lt;T&gt;</a></code> to a pristine state. </dd></dl>

<p>Reimplemented in <a class="el" href="classFeel_1_1VectorEigen.html#ad1ce54b1441af635d7c753cc0e94342f">Feel::VectorEigen&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ab0f4af2c4a549737f6c095f9e3a09b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f4af2c4a549737f6c095f9e3a09b89">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual clone_ptrtype <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of this vector and returns it in an <code>shared_ptr&lt;&gt;</code>. </p>
<p>This must be overloaded in the derived classes. </p>

</div>
</div>
<a id="a435eab103fba473ddc12482e9a5e3d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435eab103fba473ddc12482e9a5e3d39">&#9670;&nbsp;</a></span>closed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the vector is closed and ready for computation, false otherwise. </dd></dl>

</div>
</div>
<a id="a8b4fa1761353a59127c141a67984fe54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4fa1761353a59127c141a67984fe54">&#9670;&nbsp;</a></span>comm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeel_1_1WorldComm.html">WorldComm</a> const&amp; <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the communicator </dd></dl>

</div>
</div>
<a id="a4673a8a146bd4d106ade28b61df42445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4673a8a146bd4d106ade28b61df42445">&#9670;&nbsp;</a></span>commPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">worldcomm_ptr_t const&amp; <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::commPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the communicator </dd></dl>

</div>
</div>
<a id="aafb6680bcf998c9cf59cb40355d47251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb6680bcf998c9cf59cb40355d47251">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real_type&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>-1</code> when <code>this</code> is equivalent to <code>other_vector</code>, up to the given <code>threshold</code>. When differences occur, the return value contains the first index where the difference exceeded the threshold. When no threshold is given, the <code><a class="el" href="classFeel_1_1Application.html" title="provides information about the Application">Application</a></code> <code>TOLERANCE</code> is used. </dd></dl>

</div>
</div>
<a id="aaa11065234f40eb1366f86c64e3d9aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa11065234f40eb1366f86c64e3d9aaa">&#9670;&nbsp;</a></span>createSubVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt;T&gt; &gt; <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::createSubVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkAndFixRange</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the subvector "subvector" from the indices in the "rows" array. </p>
<p>Similar to the create_submatrix routine for the SparseMatrix class, it is currently only implemented for PetscVectors. </p>

</div>
</div>
<a id="ada5b6a3090b66705651500a0091433c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5b6a3090b66705651500a0091433c6">&#9670;&nbsp;</a></span>createSubvector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::createSubvector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSizeT.html">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the subvector "subvector" from the indices in the "rows" array. </p>
<p>Similar to the create_submatrix routine for the SparseMatrix class, it is currently only implemented for PetscVectors. </p>

</div>
</div>
<a id="adbf09e5e3e8884de9120f7efc399215c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf09e5e3e8884de9120f7efc399215c">&#9670;&nbsp;</a></span>firstLocalIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSizeT.html">size_type</a> <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::firstLocalIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the index of the first vector element actually stored on this processor. Hint: the minimum for this index is <code>0</code>. </dd></dl>

</div>
</div>
<a id="a325bd3e3b14ac591b40fae23724b61c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325bd3e3b14ac591b40fae23724b61c4">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>size_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>size_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the dimension of the vector to <code>N</code>. </p>
<p>The reserved memory for this vector remains unchanged if possible, to make things faster, but this may waste some memory, so take this in the back of your head. However, if <code>N==0</code> all memory is freed, i.e. if you want to resize the vector and release the memory not needed, you have to first call <code>init(0)</code> and then <code>init(N)</code>. This cited behaviour is analogous to that of the STL containers.</p>
<p>On <code>fast==false</code>, the vector is filled by zeros. </p>

</div>
</div>
<a id="a8d84e6190e89e195171d64ce1803af9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d84e6190e89e195171d64ce1803af9a">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the vector has been initialized, false otherwise. </dd></dl>

</div>
</div>
<a id="af9964c89cd2658906fc5db8b7f7bd560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9964c89cd2658906fc5db8b7f7bd560">&#9670;&nbsp;</a></span>l1Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::l1Norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>retrieve the max component as well as the index of the max component </p>
<dl class="section return"><dt>Returns</dt><dd>the \(l_1\)-norm of the vector, i.e. the sum of the absolute values. </dd></dl>

</div>
</div>
<a id="ae3f136155f018e1876a7bcce27484f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f136155f018e1876a7bcce27484f08">&#9670;&nbsp;</a></span>l2Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::l2Norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the \(l_2\)-norm of the vector, i.e. the square root of the sum of the squares of the elements. </dd></dl>

</div>
</div>
<a id="af5e6aebc864bfac106733af7c592c0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e6aebc864bfac106733af7c592c0d5">&#9670;&nbsp;</a></span>lastLocalIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSizeT.html">size_type</a> <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::lastLocalIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the index+1 of the last vector element actually stored on this processor. Hint: the maximum for this index is <code><a class="el" href="classFeel_1_1Vector.html#aa1db22f2b504db0cffbb156ef0f41928">size()</a></code>. </dd></dl>

</div>
</div>
<a id="a74ee8fdb752413f35e4fd7ab7c9d08e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ee8fdb752413f35e4fd7ab7c9d08e0">&#9670;&nbsp;</a></span>linftyNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::linftyNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum absolute value of the elements of this vector, which is the \(l_\infty\)-norm of a vector. </dd></dl>

</div>
</div>
<a id="a29a73d96ec40251a2a073f652e049665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a73d96ec40251a2a073f652e049665">&#9670;&nbsp;</a></span>localSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSizeT.html">size_type</a> <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::localSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the local size of the vector (index_stop-index_start) </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceFeel.html#aa3ebeedb0c6e5d25d0272d1ec451cc46">Feel::inner_product()</a>.</p>

</div>
</div>
<a id="a2cdd5e9cc7bedb4608dc92050372878a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdd5e9cc7bedb4608dc92050372878a">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>retrieve the min component as well as the index of the min component </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum element in the vector. In case of complex numbers, this returns the maximum Real part. </dd></dl>

</div>
</div>
<a id="ad395c1fe95a789e9243cf780aa7413ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad395c1fe95a789e9243cf780aa7413ba">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual real_type <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum element in the vector. In case of complex numbers, this returns the minimum Real part. </dd></dl>

</div>
</div>
<a id="a050876ab2adda9ce7c8688533fed1a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050876ab2adda9ce7c8688533fed1a38">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt;T&gt;&amp; <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator. </p>
<p>Fast equivalent to <code>U.add(1, V)</code>. </p>

<p>Implemented in <a class="el" href="classFeel_1_1VectorEigen.html#aab04809aee62d6e065a4c6f60e8af865">Feel::VectorEigen&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a0c99cf8e37876db1f2d13705d2908bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c99cf8e37876db1f2d13705d2908bf4">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt;T&gt;&amp; <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator. </p>
<p>Fast equivalent to <code>U.add</code>(-1, V). </p>

<p>Implemented in <a class="el" href="classFeel_1_1VectorEigen.html#ae002b05aa2476ad696f7098268729682">Feel::VectorEigen&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a47a136d63e66d97309ab768fc09ff00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a136d63e66d97309ab768fc09ff00c">&#9670;&nbsp;</a></span>printMatlab()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::printMatlab </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;NULL&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>renumber</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of the matrix in Matlab's sparse matrix format. </p>
<p>Optionally prints the matrix to the file named <code>name</code>. If <code>name</code> is not specified it is dumped to the screen. </p>

<p>Implemented in <a class="el" href="classFeel_1_1VectorEigen.html#a375b5e4baa2fcb21539c71ac1f04d232">Feel::VectorEigen&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aa1db22f2b504db0cffbb156ef0f41928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1db22f2b504db0cffbb156ef0f41928">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSizeT.html">size_type</a> <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>dimension of the vector. This function was formerly called <code>n()</code>, but was renamed to get the <code><a class="el" href="classFeel_1_1Vector.html">Vector&lt;T&gt;</a></code> class closer to the C++ standard library's <code>std::vector</code> container. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceFeel.html#aa3ebeedb0c6e5d25d0272d1ec451cc46">Feel::inner_product()</a>.</p>

</div>
</div>
<a id="a54f3e88db862b9685269b0863d17e26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f3e88db862b9685269b0863d17e26b">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual value_type <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the components of the vector </dd></dl>

</div>
</div>
<a id="af14039922d995a0a0933e49af2c55c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14039922d995a0a0933e49af2c55c29">&#9670;&nbsp;</a></span>worldCommPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">worldcomm_ptr_t&amp; <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::worldCommPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the communicator </dd></dl>

</div>
</div>
<a id="a2b625f1981df1612a1169f19fc2699b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b625f1981df1612a1169f19fc2699b3">&#9670;&nbsp;</a></span>worldCommPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">worldcomm_ptr_t const&amp; <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::worldCommPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the communicator </dd></dl>

</div>
</div>
<a id="a80bbf4b97037ff0484d01e5b9a0ef396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bbf4b97037ff0484d01e5b9a0ef396">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries to zero. </p>
<p>Equivalent to <code>v</code> = 0, but more obvious and faster. </p>

<p>Implemented in <a class="el" href="classFeel_1_1VectorEigen.html#a5a068e16ab5e08335515a9e137a5d1bb">Feel::VectorEigen&lt; T &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56b9593607359356e6161ed6d6924313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b9593607359356e6161ed6d6924313">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::<a class="el" href="classFeel_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">worldcomm_ptr_t const &amp;&#160;</td>
          <td class="paramname"><em>_worldComm</em> = <code><a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dummy-Constructor. </p>
<p>Dimension=0 </p>

</div>
</div>
<a id="a668fcb09d915f68d46b573f0740cb220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668fcb09d915f68d46b573f0740cb220">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::<a class="el" href="classFeel_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSizeT.html">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">worldcomm_ptr_t const &amp;&#160;</td>
          <td class="paramname"><em>_worldComm</em> = <code><a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Set dimension to <code>n</code> and initialize all elements with zero. </p>

</div>
</div>
<a id="a2cee28db3619ab3c3efc5d870b2174a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cee28db3619ab3c3efc5d870b2174a9">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::<a class="el" href="classFeel_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSizeT.html">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSizeT.html">size_type</a>&#160;</td>
          <td class="paramname"><em>n_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">worldcomm_ptr_t const &amp;&#160;</td>
          <td class="paramname"><em>_worldComm</em> = <code><a class="el" href="classFeel_1_1Environment.html#a3ffa1e65a0e0cf627d2187173c7feebb">Environment::worldCommPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Set local dimension to <code>n_local</code>, the global dimension to <code>n</code>, and initialize all elements with zero. </p>

</div>
</div>
<a id="a28f40cffa2afd095299a5cc0d37dc55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f40cffa2afd095299a5cc0d37dc55d">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeT  = uint32_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFeel_1_1Vector.html">Feel::Vector</a>&lt; T, <a class="el" href="classSizeT.html">SizeT</a> &gt;::~<a class="el" href="classFeel_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor, deallocates memory. </p>
<p>Made virtual to allow for derived classes to behave properly. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceFeel.html">Feel</a></li><li class="navelem"><a class="el" href="classFeel_1_1Vector.html">Vector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
