<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Feel++: Feel::MatrixBlockBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="feel_logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Feel++
   &#160;<span id="projectnumber">0.109.0-alpha.1</span>
   </div>
   <div id="projectbrief">Finite Element Embedded Library in C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classFeel_1_1MatrixBlockBase.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classFeel_1_1MatrixBlockBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Feel::MatrixBlockBase&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Feel::MatrixBlockBase&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classFeel_1_1MatrixBlockBase.png" usemap="#Feel::MatrixBlockBase_3C_20T_20_3E_map" alt=""/>
  <map id="Feel::MatrixBlockBase_3C_20T_20_3E_map" name="Feel::MatrixBlockBase_3C_20T_20_3E_map">
<area href="classFeel_1_1MatrixCondensed.html" title="Matrix to represent statically condensed matrices." alt="Feel::MatrixCondensed&lt; T &gt;" shape="rect" coords="0,56,173,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a828a4b6914e1265a69f5a828c19fd9b2"><td class="memItemLeft" align="right" valign="top"><a id="a828a4b6914e1265a69f5a828c19fd9b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename super::size_type</td></tr>
<tr class="separator:a828a4b6914e1265a69f5a828c19fd9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86d5e5468ba93a392090b618e2ac95b"><td class="memItemLeft" align="right" valign="top"><a id="ad86d5e5468ba93a392090b618e2ac95b"></a>
typedef <a class="el" href="classFeel_1_1MatrixBlockBase.html">MatrixBlockBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>self_type</b></td></tr>
<tr class="separator:ad86d5e5468ba93a392090b618e2ac95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1c988b9386d9224b3f406ba480bc85"><td class="memItemLeft" align="right" valign="top"><a id="a4b1c988b9386d9224b3f406ba480bc85"></a>
typedef super::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a4b1c988b9386d9224b3f406ba480bc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1151da8948fc43753a070461217eb2a"><td class="memItemLeft" align="right" valign="top"><a id="ac1151da8948fc43753a070461217eb2a"></a>
typedef super::real_type&#160;</td><td class="memItemRight" valign="bottom"><b>real_type</b></td></tr>
<tr class="separator:ac1151da8948fc43753a070461217eb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee53c753722b7fe78e5d5ddc5d326660"><td class="memItemLeft" align="right" valign="top"><a id="aee53c753722b7fe78e5d5ddc5d326660"></a>
typedef <a class="el" href="classFeel_1_1Backend.html">Backend</a>&lt; value_type, size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>backend_type</b></td></tr>
<tr class="separator:aee53c753722b7fe78e5d5ddc5d326660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb62c23e4cb3c927e323bf1b9bb8212"><td class="memItemLeft" align="right" valign="top"><a id="a5bb62c23e4cb3c927e323bf1b9bb8212"></a>
typedef std::shared_ptr&lt; <a class="el" href="classFeel_1_1Backend.html">backend_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>backend_ptrtype</b></td></tr>
<tr class="separator:a5bb62c23e4cb3c927e323bf1b9bb8212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae803260d465847ede81fbadc48b056b4"><td class="memItemLeft" align="right" valign="top"><a id="ae803260d465847ede81fbadc48b056b4"></a>
typedef <a class="el" href="classMatrixSparse_3_01T_01_4.html">super</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_type</b></td></tr>
<tr class="separator:ae803260d465847ede81fbadc48b056b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823fb5121b6210c529259f1e81d4c32f"><td class="memItemLeft" align="right" valign="top"><a id="a823fb5121b6210c529259f1e81d4c32f"></a>
typedef std::shared_ptr&lt; <a class="el" href="classMatrixSparse_3_01T_01_4.html">matrix_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_ptrtype</b></td></tr>
<tr class="separator:a823fb5121b6210c529259f1e81d4c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278cc9e4c0831da73328ba8c1303c501"><td class="memItemLeft" align="right" valign="top"><a id="a278cc9e4c0831da73328ba8c1303c501"></a>
typedef std::vector&lt; matrix_ptrtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vector_matrix_ptrtype</b></td></tr>
<tr class="separator:a278cc9e4c0831da73328ba8c1303c501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb06ec80b1966e1fcfb0720d136337a"><td class="memItemLeft" align="right" valign="top"><a id="acdb06ec80b1966e1fcfb0720d136337a"></a>
typedef super::graph_type&#160;</td><td class="memItemRight" valign="bottom"><b>graph_type</b></td></tr>
<tr class="separator:acdb06ec80b1966e1fcfb0720d136337a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834fbeed0673d0fb39d5f1370460c14a"><td class="memItemLeft" align="right" valign="top"><a id="a834fbeed0673d0fb39d5f1370460c14a"></a>
typedef super::graph_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><b>graph_ptrtype</b></td></tr>
<tr class="separator:a834fbeed0673d0fb39d5f1370460c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3412c92911516619f766fe9e4a38dc"><td class="memItemLeft" align="right" valign="top"><a id="a6f3412c92911516619f766fe9e4a38dc"></a>
typedef super::indexsplit_type&#160;</td><td class="memItemRight" valign="bottom"><b>indexsplit_type</b></td></tr>
<tr class="separator:a6f3412c92911516619f766fe9e4a38dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6014ec0b542e6f3248bf7326a937790e"><td class="memItemLeft" align="right" valign="top"><a id="a6014ec0b542e6f3248bf7326a937790e"></a>
typedef super::indexsplit_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><b>indexsplit_ptrtype</b></td></tr>
<tr class="separator:a6014ec0b542e6f3248bf7326a937790e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructors, destructor</h2></td></tr>
<tr class="memitem:a01a1ed37cfc407c27a320098c9ac36bf"><td class="memItemLeft" align="right" valign="top"><a id="a01a1ed37cfc407c27a320098c9ac36bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixBlockBase</b> (<a class="el" href="structFeel_1_1vf_1_1BlocksBase.html">vf::BlocksBase</a>&lt; matrix_ptrtype &gt; const &amp;blockSet, backend_ptrtype <a class="el" href="classFeel_1_1MatrixBlockBase.html#a2cd05fdde994d70fe2d2234e69d4dee7">backend</a>, bool copy_values=true, bool diag_is_nonzero=true)</td></tr>
<tr class="separator:a01a1ed37cfc407c27a320098c9ac36bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2367e1741a6019a650b3dec9b913d123"><td class="memItemLeft" align="right" valign="top"><a id="a2367e1741a6019a650b3dec9b913d123"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixBlockBase</b> (<a class="el" href="structFeel_1_1vf_1_1BlocksBase.html">vf::BlocksBase</a>&lt; graph_ptrtype &gt; const &amp;graph, backend_ptrtype <a class="el" href="classFeel_1_1MatrixBlockBase.html#a2cd05fdde994d70fe2d2234e69d4dee7">backend</a>, bool diag_is_nonzero=true)</td></tr>
<tr class="separator:a2367e1741a6019a650b3dec9b913d123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9e6ed4c8a38c6f3701bc3ee3719cae"><td class="memItemLeft" align="right" valign="top"><a id="acc9e6ed4c8a38c6f3701bc3ee3719cae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixBlockBase</b> (<a class="el" href="structFeel_1_1vf_1_1BlocksBase.html">vf::BlocksBase</a>&lt; matrix_ptrtype &gt; const &amp;blockSet, <a class="el" href="classFeel_1_1Backend.html">backend_type</a> &amp;<a class="el" href="classFeel_1_1MatrixBlockBase.html#a2cd05fdde994d70fe2d2234e69d4dee7">backend</a>, bool copy_values=true, bool diag_is_nonzero=true)</td></tr>
<tr class="separator:acc9e6ed4c8a38c6f3701bc3ee3719cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8efdb785c9a4962ec086216a6a4a1c"><td class="memItemLeft" align="right" valign="top"><a id="a5a8efdb785c9a4962ec086216a6a4a1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixBlockBase</b> (<a class="el" href="structFeel_1_1vf_1_1BlocksBase.html">vf::BlocksBase</a>&lt; graph_ptrtype &gt; const &amp;graph, <a class="el" href="classFeel_1_1Backend.html">backend_type</a> &amp;<a class="el" href="classFeel_1_1MatrixBlockBase.html#a2cd05fdde994d70fe2d2234e69d4dee7">backend</a>, bool diag_is_nonzero=true)</td></tr>
<tr class="separator:a5a8efdb785c9a4962ec086216a6a4a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28980cc57c2df255c5dba92a208408f2"><td class="memItemLeft" align="right" valign="top"><a id="a28980cc57c2df255c5dba92a208408f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixBlockBase</b> (worldcomm_ptr_t const &amp;wc)</td></tr>
<tr class="separator:a28980cc57c2df255c5dba92a208408f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f8bc4e32ec10c7d57ce52886562251"><td class="memItemLeft" align="right" valign="top"><a id="a43f8bc4e32ec10c7d57ce52886562251"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixBlockBase</b> (<a class="el" href="classFeel_1_1MatrixBlockBase.html">MatrixBlockBase</a> const &amp;mb)</td></tr>
<tr class="separator:a43f8bc4e32ec10c7d57ce52886562251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2035642c595461ae1e74e1b6bea670c"><td class="memItemLeft" align="right" valign="top"><a id="af2035642c595461ae1e74e1b6bea670c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~MatrixBlockBase</b> ()</td></tr>
<tr class="separator:af2035642c595461ae1e74e1b6bea670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Operator overloads</h2></td></tr>
<tr class="memitem:a751432539ca21207d57ef4415a080faf"><td class="memItemLeft" align="right" valign="top"><a id="a751432539ca21207d57ef4415a080faf"></a>
<a class="el" href="classFeel_1_1MatrixBlockBase.html">MatrixBlockBase</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFeel_1_1MatrixBlockBase.html">MatrixBlockBase</a> const &amp;mb)</td></tr>
<tr class="separator:a751432539ca21207d57ef4415a080faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accessors</h2></td></tr>
<tr class="memitem:ab52c626603c25c2c8f8b1fbeab75a4d5"><td class="memItemLeft" align="right" valign="top"><a id="ab52c626603c25c2c8f8b1fbeab75a4d5"></a>
matrix_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><b>getSparseMatrix</b> ()</td></tr>
<tr class="separator:ab52c626603c25c2c8f8b1fbeab75a4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Methods</h2></td></tr>
<tr class="memitem:a4dfe06fa0c0e495cc74e1533cc2869f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a4dfe06fa0c0e495cc74e1533cc2869f0">init</a> (const size_type m, const size_type n, const size_type m_l, const size_type n_l, const size_type <a class="el" href="classFeel_1_1MatrixBlockBase.html#ac6616a8aef43ac9e76ffaced407b78dd">nnz</a>=30, const size_type noz=10) override</td></tr>
<tr class="memdesc:a4dfe06fa0c0e495cc74e1533cc2869f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Petsc matrix that is of global dimension \( m \times n \) with local dimensions \( m_l \times n_l \).  <a href="classFeel_1_1MatrixBlockBase.html#a4dfe06fa0c0e495cc74e1533cc2869f0">More...</a><br /></td></tr>
<tr class="separator:a4dfe06fa0c0e495cc74e1533cc2869f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feed9f49c77efc1a9497e85189e2df8"><td class="memItemLeft" align="right" valign="top"><a id="a2feed9f49c77efc1a9497e85189e2df8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a2feed9f49c77efc1a9497e85189e2df8">init</a> (const size_type m, const size_type n, const size_type m_l, const size_type n_l, graph_ptrtype const &amp;graph) override</td></tr>
<tr class="memdesc:a2feed9f49c77efc1a9497e85189e2df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize using sparsity structure computed by <code>dof_map</code>. <br /></td></tr>
<tr class="separator:a2feed9f49c77efc1a9497e85189e2df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd05fdde994d70fe2d2234e69d4dee7"><td class="memItemLeft" align="right" valign="top"><a id="a2cd05fdde994d70fe2d2234e69d4dee7"></a>
backend_ptrtype const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a2cd05fdde994d70fe2d2234e69d4dee7">backend</a> () const</td></tr>
<tr class="memdesc:a2cd05fdde994d70fe2d2234e69d4dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the backend read-only <br /></td></tr>
<tr class="separator:a2cd05fdde994d70fe2d2234e69d4dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c997b5da4c81594423b9f4db01f16e"><td class="memItemLeft" align="right" valign="top"><a id="a86c997b5da4c81594423b9f4db01f16e"></a>
backend_ptrtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a86c997b5da4c81594423b9f4db01f16e">backend</a> ()</td></tr>
<tr class="memdesc:a86c997b5da4c81594423b9f4db01f16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the backend read-write <br /></td></tr>
<tr class="separator:a86c997b5da4c81594423b9f4db01f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8e5697cbf9df295b6ae4878c97a1a3"><td class="memItemLeft" align="right" valign="top"><a id="a9a8e5697cbf9df295b6ae4878c97a1a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a9a8e5697cbf9df295b6ae4878c97a1a3">setBackend</a> (backend_ptrtype b)</td></tr>
<tr class="memdesc:a9a8e5697cbf9df295b6ae4878c97a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the backend <br /></td></tr>
<tr class="separator:a9a8e5697cbf9df295b6ae4878c97a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d5aa3e3f018d5434eb0d15b8aa7fcf"><td class="memItemLeft" align="right" valign="top"><a id="a16d5aa3e3f018d5434eb0d15b8aa7fcf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a16d5aa3e3f018d5434eb0d15b8aa7fcf">clear</a> () override</td></tr>
<tr class="memdesc:a16d5aa3e3f018d5434eb0d15b8aa7fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all memory and return to a state just like after having called the default constructor. <br /></td></tr>
<tr class="separator:a16d5aa3e3f018d5434eb0d15b8aa7fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e64f19c9a50da9030ac84882663fb56"><td class="memItemLeft" align="right" valign="top"><a id="a3e64f19c9a50da9030ac84882663fb56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a3e64f19c9a50da9030ac84882663fb56">zero</a> () override</td></tr>
<tr class="memdesc:a3e64f19c9a50da9030ac84882663fb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to 0. <br /></td></tr>
<tr class="separator:a3e64f19c9a50da9030ac84882663fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d931083b1cdd5500840a20f2168f08a"><td class="memItemLeft" align="right" valign="top"><a id="a6d931083b1cdd5500840a20f2168f08a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a6d931083b1cdd5500840a20f2168f08a">zero</a> (size_type start1, size_type <a class="el" href="classFeel_1_1MatrixBlockBase.html#a86feaea765e7bdba23af136d472c35db">size1</a>, size_type start2, size_type <a class="el" href="classFeel_1_1MatrixBlockBase.html#aed0a756a1162d3fa3c10c2d99b99cae6">size2</a>) override</td></tr>
<tr class="memdesc:a6d931083b1cdd5500840a20f2168f08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set entries between to 0. <br /></td></tr>
<tr class="separator:a6d931083b1cdd5500840a20f2168f08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ffddff6561684f7101960523f90fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#aa4ffddff6561684f7101960523f90fd3">close</a> () const override</td></tr>
<tr class="memdesc:aa4ffddff6561684f7101960523f90fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the Sparse assemble routines.  <a href="classFeel_1_1MatrixBlockBase.html#aa4ffddff6561684f7101960523f90fd3">More...</a><br /></td></tr>
<tr class="separator:aa4ffddff6561684f7101960523f90fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86feaea765e7bdba23af136d472c35db"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a86feaea765e7bdba23af136d472c35db">size1</a> () const override</td></tr>
<tr class="separator:a86feaea765e7bdba23af136d472c35db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0a756a1162d3fa3c10c2d99b99cae6"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#aed0a756a1162d3fa3c10c2d99b99cae6">size2</a> () const override</td></tr>
<tr class="separator:aed0a756a1162d3fa3c10c2d99b99cae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6616a8aef43ac9e76ffaced407b78dd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#ac6616a8aef43ac9e76ffaced407b78dd">nnz</a> () const override</td></tr>
<tr class="separator:ac6616a8aef43ac9e76ffaced407b78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541cdcada76260b226fab66a374187f7"><td class="memItemLeft" align="right" valign="top"><a id="a541cdcada76260b226fab66a374187f7"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a541cdcada76260b226fab66a374187f7">rowStart</a> () const override</td></tr>
<tr class="memdesc:a541cdcada76260b226fab66a374187f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return row_start, the index of the first matrix row stored on this processor <br /></td></tr>
<tr class="separator:a541cdcada76260b226fab66a374187f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca7edab3f58ed40e7b602b27edba82"><td class="memItemLeft" align="right" valign="top"><a id="ad1ca7edab3f58ed40e7b602b27edba82"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#ad1ca7edab3f58ed40e7b602b27edba82">rowStop</a> () const override</td></tr>
<tr class="memdesc:ad1ca7edab3f58ed40e7b602b27edba82"><td class="mdescLeft">&#160;</td><td class="mdescRight">return row_stop, the index of the last matrix row (+1) stored on this processor <br /></td></tr>
<tr class="separator:ad1ca7edab3f58ed40e7b602b27edba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a9ed9a45b4222b4b8d84ab15178fc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a53a9ed9a45b4222b4b8d84ab15178fc5">set</a> (const size_type i, const size_type j, const value_type &amp;value) override</td></tr>
<tr class="memdesc:a53a9ed9a45b4222b4b8d84ab15178fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element <code></code>(i,j) to <code>value</code>.  <a href="classFeel_1_1MatrixBlockBase.html#a53a9ed9a45b4222b4b8d84ab15178fc5">More...</a><br /></td></tr>
<tr class="separator:a53a9ed9a45b4222b4b8d84ab15178fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e3a530f26f8261e53c4e7cbb59e6fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a27e3a530f26f8261e53c4e7cbb59e6fa">add</a> (const size_type i, const size_type j, const value_type &amp;value) override</td></tr>
<tr class="memdesc:a27e3a530f26f8261e53c4e7cbb59e6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>value</code> to the element <code></code>(i,j).  <a href="classFeel_1_1MatrixBlockBase.html#a27e3a530f26f8261e53c4e7cbb59e6fa">More...</a><br /></td></tr>
<tr class="separator:a27e3a530f26f8261e53c4e7cbb59e6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad4dd02ac271c94e139e4854e85fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#aacad4dd02ac271c94e139e4854e85fef">addMatrix</a> (const ublas::matrix&lt; value_type &gt; &amp;dm, const std::vector&lt; size_type &gt; &amp;rows, const std::vector&lt; size_type &gt; &amp;cols) override</td></tr>
<tr class="memdesc:aacad4dd02ac271c94e139e4854e85fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the full matrix to the Sparse matrix.  <a href="classFeel_1_1MatrixBlockBase.html#aacad4dd02ac271c94e139e4854e85fef">More...</a><br /></td></tr>
<tr class="separator:aacad4dd02ac271c94e139e4854e85fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01d2c28c7cf78527f9d32ff09fba3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#aa01d2c28c7cf78527f9d32ff09fba3cc">addMatrix</a> (<a class="el" href="classint.html">int</a> *rows, <a class="el" href="classint.html">int</a> nrows, <a class="el" href="classint.html">int</a> *cols, <a class="el" href="classint.html">int</a> ncols, value_type *data, size_type K=0, size_type K2=<a class="el" href="namespaceFeel.html#a566f946adc847c2d452e0682edc9e98c">invalid_v</a>&lt; size_type &gt;) override</td></tr>
<tr class="memdesc:aa01d2c28c7cf78527f9d32ff09fba3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the full matrix to the Sparse matrix.  <a href="classFeel_1_1MatrixBlockBase.html#aa01d2c28c7cf78527f9d32ff09fba3cc">More...</a><br /></td></tr>
<tr class="separator:aa01d2c28c7cf78527f9d32ff09fba3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62f587b476edf19c16db6582f10d33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#ada62f587b476edf19c16db6582f10d33">addMatrix</a> (const ublas::matrix&lt; value_type &gt; &amp;dm, const std::vector&lt; size_type &gt; &amp;dof_indices) override</td></tr>
<tr class="memdesc:ada62f587b476edf19c16db6582f10d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, but assumes the row and column maps are the same.  <a href="classFeel_1_1MatrixBlockBase.html#ada62f587b476edf19c16db6582f10d33">More...</a><br /></td></tr>
<tr class="separator:ada62f587b476edf19c16db6582f10d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74adb8d572a72a7d0d0f916c372a8c96"><td class="memItemLeft" align="right" valign="top"><a id="a74adb8d572a72a7d0d0f916c372a8c96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a74adb8d572a72a7d0d0f916c372a8c96">addMatrix</a> (const value_type, <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; const &amp;, <a class="el" href="namespaceFeel.html#a3d7a6c5948e669b187f2d4620499715a">Feel::MatrixStructure</a> matStruc=Feel::SAME_NONZERO_PATTERN) override</td></tr>
<tr class="memdesc:a74adb8d572a72a7d0d0f916c372a8c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Sparse matrix <code>_X</code>, scaled with <code>_a</code>, to <code>this</code>, stores the result in <code>this:</code> \(\texttt{this} = \_a*\_X + \texttt{this} \). <br /></td></tr>
<tr class="separator:a74adb8d572a72a7d0d0f916c372a8c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6acc2659a3ac1eb9af2adb136578aa"><td class="memItemLeft" align="right" valign="top"><a id="a1c6acc2659a3ac1eb9af2adb136578aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b> (const value_type) override</td></tr>
<tr class="separator:a1c6acc2659a3ac1eb9af2adb136578aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449db91e201e55ca7d380bea3b4d1acd"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a449db91e201e55ca7d380bea3b4d1acd">operator()</a> (const size_type i, const size_type j) const override</td></tr>
<tr class="memdesc:a449db91e201e55ca7d380bea3b4d1acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the entry <code></code>(i,j).  <a href="classFeel_1_1MatrixBlockBase.html#a449db91e201e55ca7d380bea3b4d1acd">More...</a><br /></td></tr>
<tr class="separator:a449db91e201e55ca7d380bea3b4d1acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d393688630fb9fd755c607ce5cdd6c5"><td class="memItemLeft" align="right" valign="top"><a id="a3d393688630fb9fd755c607ce5cdd6c5"></a>
<a class="el" href="classFeel_1_1MatrixBlockBase.html">self_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; const &amp;M) override</td></tr>
<tr class="separator:a3d393688630fb9fd755c607ce5cdd6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cd334ac0f9a6404a434593c4c33344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#af1cd334ac0f9a6404a434593c4c33344">diagonal</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;out) const override</td></tr>
<tr class="memdesc:af1cd334ac0f9a6404a434593c4c33344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the diagonal of the block matrix.  <a href="classFeel_1_1MatrixBlockBase.html#af1cd334ac0f9a6404a434593c4c33344">More...</a><br /></td></tr>
<tr class="separator:af1cd334ac0f9a6404a434593c4c33344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdb3f6272fbcc6e53a9cf07da9dddb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a4fdb3f6272fbcc6e53a9cf07da9dddb2">transpose</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;Mt, size_type options) const override</td></tr>
<tr class="memdesc:a4fdb3f6272fbcc6e53a9cf07da9dddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of a matrix.  <a href="classFeel_1_1MatrixBlockBase.html#a4fdb3f6272fbcc6e53a9cf07da9dddb2">More...</a><br /></td></tr>
<tr class="separator:a4fdb3f6272fbcc6e53a9cf07da9dddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e3885733512b41f1eaf8951e9598f6"><td class="memItemLeft" align="right" valign="top">real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#ab3e3885733512b41f1eaf8951e9598f6">energy</a> (<a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;__v, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;__u, bool <a class="el" href="classFeel_1_1MatrixBlockBase.html#a4fdb3f6272fbcc6e53a9cf07da9dddb2">transpose</a>=false) const override</td></tr>
<tr class="separator:ab3e3885733512b41f1eaf8951e9598f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae2800b105f7362008abae79c244829"><td class="memItemLeft" align="right" valign="top">real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a3ae2800b105f7362008abae79c244829">l1Norm</a> () const override</td></tr>
<tr class="memdesc:a3ae2800b105f7362008abae79c244829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the l1-norm of the matrix, that is \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\), (max.  <a href="classFeel_1_1MatrixBlockBase.html#a3ae2800b105f7362008abae79c244829">More...</a><br /></td></tr>
<tr class="separator:a3ae2800b105f7362008abae79c244829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4acb4eed5905b7ce20031cb75c97e9"><td class="memItemLeft" align="right" valign="top">real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a1e4acb4eed5905b7ce20031cb75c97e9">linftyNorm</a> () const override</td></tr>
<tr class="memdesc:a1e4acb4eed5905b7ce20031cb75c97e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linfty-norm of the matrix, that is.  <a href="classFeel_1_1MatrixBlockBase.html#a1e4acb4eed5905b7ce20031cb75c97e9">More...</a><br /></td></tr>
<tr class="separator:a1e4acb4eed5905b7ce20031cb75c97e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf67926c9c5ebcd32fb511e65e5e4ccf"><td class="memItemLeft" align="right" valign="top"><a id="abf67926c9c5ebcd32fb511e65e5e4ccf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#abf67926c9c5ebcd32fb511e65e5e4ccf">closed</a> () const override</td></tr>
<tr class="memdesc:abf67926c9c5ebcd32fb511e65e5e4ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">see if Sparse matrix has been closed and fully assembled yet <br /></td></tr>
<tr class="separator:abf67926c9c5ebcd32fb511e65e5e4ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4e4089a771c7ca4c1a6bc9a72cd74a"><td class="memItemLeft" align="right" valign="top"><a id="a8b4e4089a771c7ca4c1a6bc9a72cd74a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a8b4e4089a771c7ca4c1a6bc9a72cd74a">print</a> (std::ostream &amp;os=std::cout) const</td></tr>
<tr class="memdesc:a8b4e4089a771c7ca4c1a6bc9a72cd74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the matrix to the screen in a uniform style, regardless of matrix/solver package being used. <br /></td></tr>
<tr class="separator:a8b4e4089a771c7ca4c1a6bc9a72cd74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c21c2a87db1cada366fb2a4795869f8"><td class="memItemLeft" align="right" valign="top"><a id="a7c21c2a87db1cada366fb2a4795869f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a7c21c2a87db1cada366fb2a4795869f8">printPersonal</a> (std::ostream &amp;=std::cout) const override</td></tr>
<tr class="memdesc:a7c21c2a87db1cada366fb2a4795869f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the matrix to the screen in a package-personalized style, if available. <br /></td></tr>
<tr class="separator:a7c21c2a87db1cada366fb2a4795869f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33039425c90a808b53a30d046641d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#aa33039425c90a808b53a30d046641d50">printMatlab</a> (const std::string name=&quot;NULL&quot;) const override</td></tr>
<tr class="memdesc:aa33039425c90a808b53a30d046641d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the matrix in Matlab's sparse matrix format.  <a href="classFeel_1_1MatrixBlockBase.html#aa33039425c90a808b53a30d046641d50">More...</a><br /></td></tr>
<tr class="separator:aa33039425c90a808b53a30d046641d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af93073408dd7d50dd6f53033d7f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#ac6af93073408dd7d50dd6f53033d7f62">createSubmatrix</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;submatrix, const std::vector&lt; size_type &gt; &amp;rows, const std::vector&lt; size_type &gt; &amp;cols) const override</td></tr>
<tr class="memdesc:ac6af93073408dd7d50dd6f53033d7f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a matrix called "submatrix" which is defined by the row and column indices given in the "rows" and "cols" entries.  <a href="classFeel_1_1MatrixBlockBase.html#ac6af93073408dd7d50dd6f53033d7f62">More...</a><br /></td></tr>
<tr class="separator:ac6af93073408dd7d50dd6f53033d7f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb040755b5a706acf9272788f0fa378d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#aeb040755b5a706acf9272788f0fa378d">reinitSubmatrix</a> (<a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;submatrix, const std::vector&lt; size_type &gt; &amp;rows, const std::vector&lt; size_type &gt; &amp;cols) const override</td></tr>
<tr class="memdesc:aeb040755b5a706acf9272788f0fa378d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to the one above, but it allows you to reuse the existing sparsity pattern of "submatrix" instead of reallocating it again.  <a href="classFeel_1_1MatrixBlockBase.html#aeb040755b5a706acf9272788f0fa378d">More...</a><br /></td></tr>
<tr class="separator:aeb040755b5a706acf9272788f0fa378d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eaf626107b653b25d3007285ac75f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#a4eaf626107b653b25d3007285ac75f93">zeroRows</a> (std::vector&lt; <a class="el" href="classint.html">int</a> &gt; const &amp;rows, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;values, <a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;rhs, <a class="el" href="classFeel_1_1meta_1_1Context.html">Context</a> const &amp;on_context, value_type value_on_diagonal) override</td></tr>
<tr class="memdesc:a4eaf626107b653b25d3007285ac75f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">eliminate rows without change pattern, and put 1 on the diagonal entry  <a href="classFeel_1_1MatrixBlockBase.html#a4eaf626107b653b25d3007285ac75f93">More...</a><br /></td></tr>
<tr class="separator:a4eaf626107b653b25d3007285ac75f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061c74778766da6cbb21a519fe7937fc"><td class="memItemLeft" align="right" valign="top"><a id="a061c74778766da6cbb21a519fe7937fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateBlockMat</b> (std::shared_ptr&lt; <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt;&gt; const &amp;m, std::vector&lt; size_type &gt; const &amp;start_i, std::vector&lt; size_type &gt; const &amp;start_j) override</td></tr>
<tr class="separator:a061c74778766da6cbb21a519fe7937fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af154a6d470908d4e78f71af90892b566"><td class="memTemplParams" colspan="2"><a id="af154a6d470908d4e78f71af90892b566"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:af154a6d470908d4e78f71af90892b566"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFeel_1_1MatrixBlockBase.html#af154a6d470908d4e78f71af90892b566">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; U &gt; &amp;m)</td></tr>
<tr class="memdesc:af154a6d470908d4e78f71af90892b566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the print method above, but allows you to print to a stream in the standard syntax. <br /></td></tr>
<tr class="separator:af154a6d470908d4e78f71af90892b566"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27e3a530f26f8261e53c4e7cbb59e6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e3a530f26f8261e53c4e7cbb59e6fa">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <code>value</code> to the element <code></code>(i,j). </p>
<p>Throws an error if the entry does not exist. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="ada62f587b476edf19c16db6582f10d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62f587b476edf19c16db6582f10d33">&#9670;&nbsp;</a></span>addMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::addMatrix </td>
          <td>(</td>
          <td class="paramtype">const ublas::matrix&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same, but assumes the row and column maps are the same. </p>
<p>Thus the matrix <code>dm</code> must be square. </p>

</div>
</div>
<a id="aacad4dd02ac271c94e139e4854e85fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacad4dd02ac271c94e139e4854e85fef">&#9670;&nbsp;</a></span>addMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::addMatrix </td>
          <td>(</td>
          <td class="paramtype">const ublas::matrix&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the full matrix to the Sparse matrix. </p>
<p>This is useful for adding an element matrix at assembly time </p>

</div>
</div>
<a id="aa01d2c28c7cf78527f9d32ff09fba3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01d2c28c7cf78527f9d32ff09fba3cc">&#9670;&nbsp;</a></span>addMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::addMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>K</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>K2</em> = <code><a class="el" href="namespaceFeel.html#a566f946adc847c2d452e0682edc9e98c">invalid_v</a>&lt;&#160;size_type&#160;&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the full matrix to the Sparse matrix. </p>
<p>This is useful for adding an element matrix at assembly time </p>

</div>
</div>
<a id="aa4ffddff6561684f7101960523f90fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ffddff6561684f7101960523f90fd3">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call the Sparse assemble routines. </p>
<p>sends necessary messages to other processors </p>

</div>
</div>
<a id="ac6af93073408dd7d50dd6f53033d7f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6af93073408dd7d50dd6f53033d7f62">&#9670;&nbsp;</a></span>createSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::createSubmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a matrix called "submatrix" which is defined by the row and column indices given in the "rows" and "cols" entries. </p>
<p>Currently this operation is only defined for the PetscMatrix type. </p>

</div>
</div>
<a id="af1cd334ac0f9a6404a434593c4c33344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cd334ac0f9a6404a434593c4c33344">&#9670;&nbsp;</a></span>diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the diagonal of the block matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the vector to store the diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3e3885733512b41f1eaf8951e9598f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e3885733512b41f1eaf8951e9598f6">&#9670;&nbsp;</a></span>energy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">real_type <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::energy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>__v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>__u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>\( v^T M u \) </dd></dl>

</div>
</div>
<a id="a4dfe06fa0c0e495cc74e1533cc2869f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfe06fa0c0e495cc74e1533cc2869f0">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>m_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>nnz</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>noz</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a Petsc matrix that is of global dimension \( m \times n \) with local dimensions \( m_l \times n_l \). </p>
<p><code>nnz</code> is the number of on-processor nonzeros per row (defaults to 30). <code>noz</code> is the number of on-processor nonzeros per row (defaults to 30). </p>

</div>
</div>
<a id="a3ae2800b105f7362008abae79c244829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae2800b105f7362008abae79c244829">&#9670;&nbsp;</a></span>l1Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">real_type <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::l1Norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the l1-norm of the matrix, that is \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\), (max. </p>
<p>sum of columns).</p>
<p>This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. \(|Mv|_1\leq |M|_1 |v|_1\). </p>

</div>
</div>
<a id="a1e4acb4eed5905b7ce20031cb75c97e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4acb4eed5905b7ce20031cb75c97e9">&#9670;&nbsp;</a></span>linftyNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">real_type <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::linftyNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the linfty-norm of the matrix, that is. </p>
<p>\(|M|_\infty=max_{all rows i}\sum_{all columns j} |M_ij|\),</p>
<p>(max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. \(|Mv|_\infty \leq |M|_\infty |v|_\infty\). </p>

</div>
</div>
<a id="ac6616a8aef43ac9e76ffaced407b78dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6616a8aef43ac9e76ffaced407b78dd">&#9670;&nbsp;</a></span>nnz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::nnz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of non-zero entries </dd></dl>

</div>
</div>
<a id="a449db91e201e55ca7d380bea3b4d1acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449db91e201e55ca7d380bea3b4d1acd">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the entry <code></code>(i,j). </p>
<p>This may be an expensive operation and you should always take care where to call this function. In order to avoid abuse, this function throws an exception if the required element does not exist in the matrix.</p>
<p>In case you want a function that returns zero instead (for entries that are not in the sparsity pattern of the matrix), use the <code>el</code> function. </p>

</div>
</div>
<a id="aa33039425c90a808b53a30d046641d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33039425c90a808b53a30d046641d50">&#9670;&nbsp;</a></span>printMatlab()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::printMatlab </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;NULL&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of the matrix in Matlab's sparse matrix format. </p>
<p>Optionally prints the matrix to the file named <code>name</code>. If <code>name</code> is not specified it is dumped to the screen. </p>

</div>
</div>
<a id="aeb040755b5a706acf9272788f0fa378d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb040755b5a706acf9272788f0fa378d">&#9670;&nbsp;</a></span>reinitSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::reinitSubmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is similar to the one above, but it allows you to reuse the existing sparsity pattern of "submatrix" instead of reallocating it again. </p>
<p>This should hopefully be more efficient if you are frequently extracting submatrices of the same size. </p>

</div>
</div>
<a id="a53a9ed9a45b4222b4b8d84ab15178fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a9ed9a45b4222b4b8d84ab15178fc5">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the element <code></code>(i,j) to <code>value</code>. </p>
<p>Throws an error if the entry does not exist. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="a86feaea765e7bdba23af136d472c35db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86feaea765e7bdba23af136d472c35db">&#9670;&nbsp;</a></span>size1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::size1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>m</code>, the row-dimension of the matrix where the marix is \( M \times N \). </dd></dl>

</div>
</div>
<a id="aed0a756a1162d3fa3c10c2d99b99cae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0a756a1162d3fa3c10c2d99b99cae6">&#9670;&nbsp;</a></span>size2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::size2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>n</code>, the column-dimension of the matrix where the marix is \( M \times N \). </dd></dl>

</div>
</div>
<a id="a4fdb3f6272fbcc6e53a9cf07da9dddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdb3f6272fbcc6e53a9cf07da9dddb2">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFeel_1_1MatrixSparse.html">MatrixSparse</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transpose of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mt</td><td>the matrix transposed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4eaf626107b653b25d3007285ac75f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eaf626107b653b25d3007285ac75f93">&#9670;&nbsp;</a></span>zeroRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFeel_1_1MatrixBlockBase.html">Feel::MatrixBlockBase</a>&lt; T &gt;::zeroRows </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1Vector.html">Vector</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFeel_1_1meta_1_1Context.html">Context</a> const &amp;&#160;</td>
          <td class="paramname"><em>on_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value_on_diagonal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>eliminate rows without change pattern, and put 1 on the diagonal entry </p>
<dl class="section warning"><dt>Warning</dt><dd>if the matrix was symmetric before this operation, it won't be afterwards. So use the proper solver (nonsymmetric) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceFeel.html">Feel</a></li><li class="navelem"><a class="el" href="classFeel_1_1MatrixBlockBase.html">MatrixBlockBase</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
