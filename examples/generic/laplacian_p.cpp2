/* -*- mode: c++ -*-

  This file is part of the Life library

  Author(s): Christophe Prud'homme <christophe.prudhomme@ujf-grenoble.fr>
       Date: 2006-11-23

  Copyright (C) 2006,2007 Universit� Joseph Fourier (Grenoble I)

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
/**
   \file laplacian.cpp
   \author Christophe Prud'homme <christophe.prudhomme@ujf-grenoble.fr>
   \date 2006-11-23
 */
#include <life/options.hpp>
#include <life/lifecore/application.hpp>

#include <life/lifealg/backend.hpp>

#include <life/lifediscr/functionspace.hpp>
#include <life/lifepoly/im.hpp>

#include <life/lifefilters/importergmsh.hpp>
#include <life/lifefilters/exporter.hpp>
#include <life/lifefilters/gmshtensorizeddomain.hpp>
#include <life/lifepoly/polynomialset.hpp>


#include <life/lifevf/vf.hpp>


inline
Life::po::options_description
makeOptions()
{
    Life::po::options_description laplacianoptions("Laplacian options");
    laplacianoptions.add_options()
        ("diff", Life::po::value<double>()->default_value( 1 ), "diffusion parameter")
        ("gamma", Life::po::value<double>()->default_value( 10 ), "jump penalisation parameter")
        ("delta", Life::po::value<double>()->default_value( 0 ), "lifting operator penalisation parameter")
        ("theta", Life::po::value<double>()->default_value( 1 ), "theta=1: symmetric, theta=-1: non-symmetric")
        ("alpha", Life::po::value<double>()->default_value( 1.5 ), "Regularity coefficient for example 2")
        ("example", Life::po::value<int>()->default_value( 1 ), "Example number")
        ("f", Life::po::value<double>()->default_value( 1 ), "forcing term")
        ("g", Life::po::value<double>()->default_value( 0 ), "boundary term")
        ("hsize", Life::po::value<double>()->default_value( 0.5 ), "first h value to start convergence")
        ("export", "export results(ensight, data file(1D)")
        ("export-matlab", "export matrix and vectors in matlab" )
        ;
    return laplacianoptions.add( Life::life_options() );
}
inline
Life::AboutData
makeAbout()
{
    Life::AboutData about( "laplacian_hpOPT" ,
                            "laplacian_hpOPT" ,
                            "0.2",
                            "nD(n=1,2,3) Laplacian on simplices or simplex products",
                            Life::AboutData::License_GPL,
                            "Copyright (c) 2006, 2007 Universit� Joseph Fourier");

    about.addAuthor("Christophe Prud'homme", "developer", "christophe.prudhomme@ujf-grenoble.fr", "");
    return about;

}


namespace Life
{
using namespace vf;
template<int Dim>struct ExactSolution{};
template<>
struct ExactSolution<1>
{
    static const double pi = M_PI;
    typedef __typeof__( sin(pi*Px()) ) type;
    typedef __typeof__( pi*pi*sin(pi*Px()) ) laplacian_type;
};

template<>
struct ExactSolution<2>
{
    static const double pi = M_PI;
    typedef __typeof__( sin(pi*Px())*cos(pi*Py()) ) type;
    typedef __typeof__( 2*pi*pi*sin(pi*Px())*cos(pi*Py()) ) laplacian_type;
};

template<>
struct ExactSolution<3>
{
    static const double pi = M_PI;
    typedef __typeof__( sin(pi*Px())*cos(pi*Py())*cos(pi*Pz()) ) type;
    typedef __typeof__( 3*pi*pi*sin(pi*Px())*cos(pi*Py())*cos(pi*Pz()) ) laplacian_type;
};
/**
 * Laplacian Solver using discontinous approximation spaces
 *
 * solve \f$ -\Delta u = f\f$ on \f$\Omega\f$ and \f$u= g\f$ on \f$\Gamma\f$
 */
template<int Dim,
         int Order,
         template<uint16_type,uint16_type,uint16_type> class Entity>
class Laplacian
    :
        public Application
{
    typedef Application super;
public:

    // -- TYPEDEFS --
	// Define also more accurate for norm computations since a singularity is in the domain
    static const uint16_type imOrder = 2*Order;
	static const uint16_type imOrder_norm = 5*Order;

    typedef double value_type;

    typedef Backend<value_type> backend_type;
    typedef boost::shared_ptr<backend_type> backend_ptrtype;

    /*matrix*/
    typedef typename backend_type::sparse_matrix_type sparse_matrix_type;
    typedef typename backend_type::sparse_matrix_ptrtype sparse_matrix_ptrtype;
    typedef typename backend_type::vector_type vector_type;
    typedef typename backend_type::vector_ptrtype vector_ptrtype;

    /*mesh*/
    typedef Entity<Dim, 1,Dim> entity_type;
    typedef Mesh<GeoEntity<entity_type> > mesh_type;
    typedef boost::shared_ptr<mesh_type> mesh_ptrtype;

    /*discontinuous basis*/
    typedef fusion::vector<fem::Lagrange<Dim, Order, Scalar, Discontinuous, value_type, Entity>,
                           fem::Lagrange<Dim, Order, Vectorial, Discontinuous, value_type, Entity>
                           > basis_type;
//    typedef fusion::vector<fem::Dubiner<Dim, Order, Scalar, Discontinuous, value_type, Entity>,
//						   fem::Dubiner<Dim, Order, Vectorial, Discontinuous, value_type, Entity>
//						   > basis_type;
	/*discontinuous space*/
	typedef FunctionSpace<mesh_type, basis_type, value_type> space_type;
	typedef boost::shared_ptr<space_type> space_ptrtype;
	typedef typename space_type::element_type element_type;
	typedef typename element_type::template sub_element<0>::type element_0_type;
	typedef typename element_type::template sub_element<1>::type element_1_type;

#if 0
        typedef typename mpl::if_<mpl::bool_<Conti::is_continuous>,
                                  mpl::identity<fusion::vector<fem::Lagrange<Dim, Order, FType, Conti, double, Entity> > >,
                                  mpl::identity<fusion::vector<OrthonormalPolynomialSet<Dim, Order, FType, double, Entity> > > >::type::type basis_type;
#endif
    /*continuous basis*/
	typedef fusion::vector<fem::Lagrange<Dim, Order, Scalar, Continuous, double, Entity> > basis_type_cont;

	/*continuous space*/
    typedef FunctionSpace<mesh_type, basis_type_cont, value_type> type_cont;
    typedef boost::shared_ptr<type_cont> ptrtype_cont;
    typedef typename type_cont::element_type element_type_cont;


    /*quadrature*/
    //typedef IM_PK<Dim, imOrder, value_type> im_type;
    typedef IM<Dim, imOrder, value_type, Entity> im_type;
	typedef IM<Dim, imOrder_norm, value_type, Entity> im_type_norm;

    /* export */
    typedef Exporter<mesh_type> export_type;
    typedef typename Exporter<mesh_type>::timeset_type timeset_type;

    Laplacian( int argc, char** argv, AboutData const& ad, po::options_description const& od )
        :
        super( argc, argv, ad, od ),
        M_backend( backend_type::build( this->vm() ) ),
        meshSize( this->vm()["hsize"].template as<double>() ),
        exporter( Exporter<mesh_type>::New( this->vm()["exporter"].template as<std::string>() )->setOptions( this->vm() ) ),
        timeSet( new timeset_type( "laplacian" ) ),
        timers(),
        stats()
    {
        Log() << "[Laplacian] hsize = " << meshSize << "\n";
        Log() << "[Laplacian] export = " << this->vm().count("export") << "\n";

        timeSet->setTimeIncrement( 1.0 );
        exporter->addTimeSet( timeSet );
    }

    /**
     * create the mesh using mesh size \c meshSize
     */
    mesh_ptrtype createMesh( double meshSize );

    /**
     * alias for run()
     */
    void operator()()
    {
        run();
    }

    /**
     * run the convergence test
     */
    void run();

private:

    /**
     * solve the system
     */
    template<typename Mat, typename Vec1, typename Vec2>
    void solve( Mat const& D, Vec1& u, Vec2 const& F, bool is_sym );


    /**
     * export results to ensight format (enabled by  --export cmd line options)
     */
    template<typename f1_type, typename f2_type, typename f3_type>
    void exportResults( f1_type& u,
                        f2_type& v,
                        f3_type& e );

//template<typename f1_type, typename f2_type, typename f3_type>
	void writeResults( value_type e1,
                       value_type e2,
                       value_type e3,
                       value_type e4,
                       value_type e5,
					   value_type& theta,
					   value_type& delta,
					   value_type& gamma
					   );

private:

    backend_ptrtype M_backend;
    double meshSize;

    boost::shared_ptr<export_type> exporter;
    typename export_type::timeset_ptrtype timeSet;

    std::map<std::string,std::pair<boost::timer,double> > timers;
    std::map<std::string,double> stats;
}; // Laplacian

template<int Dim, int Order, template<uint16_type,uint16_type,uint16_type> class Entity>
typename Laplacian<Dim,Order,Entity>::mesh_ptrtype
Laplacian<Dim,Order,Entity>::createMesh( double meshSize )
{
    timers["mesh"].first.restart();
    mesh_ptrtype mesh( new mesh_type );

    GmshTensorizedDomain<entity_type::nDim,entity_type::nOrder,Entity> td;
    td.setCharacteristicLength( meshSize );
    td.setX( std::make_pair( -1, 1 ) );
    ImporterGmsh<mesh_type> import( td.generate( entity_type::name().c_str() ) );
    mesh->accept( import );
    timers["mesh"].second = timers["mesh"].first.elapsed();
    Log() << "[timer] createMesh(): " << timers["mesh"].second << "\n";
    return mesh;
} // Laplacian::createMesh


template<int Dim, int Order, template<uint16_type,uint16_type,uint16_type> class Entity>
void
Laplacian<Dim, Order, Entity>::run()
{
    if ( this->vm().count( "help" ) )
        {
            std::cout << this->optionsDescription() << "\n";
            return;
        }

    //    int maxIter = 10.0/meshSize;
    using namespace Life::vf;

    /*
     * First we create the mesh
     */
    mesh_ptrtype mesh = createMesh( meshSize );
    stats["nelt"] = mesh->elements().size();

    /*
     * The function space and some associate elements are then defined
     */
    timers["init"].first.restart();
	space_ptrtype Xh = space_type::New( mesh );
    element_type U( Xh, "U" );
    element_type V( Xh, "V" );
    element_0_type u( U.template element<0>() );
    element_1_type tau( U.template element<1>() );
    element_0_type v( V.template element<0>() );
    element_1_type phi( V.template element<1>() );

    timers["init"].second = timers["init"].first.elapsed();
    stats["ndof"] = Xh->nDof();

    /*
     * a quadrature rule for numerical integration
     */
    im_type im;
	im_type_norm im_norm;

    value_type gamma = this->vm()["gamma"].template as<value_type>();
    value_type delta = this->vm()["delta"].template as<value_type>();
    value_type theta = this->vm()["theta"].template as<value_type>();
    value_type diff = this->vm()["diff"].template as<double>();
	//value_type hsize = this->vm()["hsize"].template as<value_type>();
    value_type alpha = this->vm()["alpha"].template as<value_type>();
	int example = this->vm()["example"].template as<int>();

	value_type pi = 4.0*math::atan(1.0);

	// ONLY 2D
	AUTO( g, val( sin(pi*Px())*sin(pi*Py()) ) );
	AUTO( grad_g, (pi*cos(pi*Px())*sin(pi*Py()))*oneX() + (pi*sin(pi*Px())*cos(pi*Py()))*oneY() );
	AUTO( f,        2*pi*pi*sin(pi*Px())*sin(pi*Py()) * chi(example==3)*(
                                                                         2*((1-Px()*Px())+(1-Py()*Py()))*((Px()*Px()+Py()*Py())^(alpha/2))
                                                                         -2*alpha*(1-Px()*Px())*(1-Py()*Py())*((Px()*Px()+Py()*Py())^(alpha/2-1))
                                                                         +4*alpha*(Px()*Px()+Py()*Py())*((Px()*Px()+Py()*Py())^(alpha/2-1))
                                                                         -8*alpha*(Px()*Px()*Py()*Py())*((Px()*Px()+Py()*Py())^(alpha/2-1))
                                                                         - alpha*(alpha-2)*(1-Px()*Px())*(1-Py()*Py())*(Px()*Px()+Py()*Py())*((Px()*Px()+Py()*Py())^(alpha/2-2))
                                                                         )
          );


/*    AUTO( g, val( chi(example==1)*sin(pi*Px())*sin(pi*Py())
				  +chi(example==2)*(1-cos()*cos*(vf::pow(abs(Px()),alpha)))
				  ));
	AUTO( grad_g, val( chi(example==1)*(
								pi*cos(pi*Px())*sin(pi*Py())*oneX() + pi*sin(pi*Px())*cos(pi*Py())*oneY() )
					   +chi(example==2)*(
								alpha*(vf::pow(abs(Px()),alpha-1)))*oneX()

					));
    AUTO( f, 		val( 2*pi*pi*sin(pi*Px())*sin(pi*Py()) - chi(example==2)*(alpha*(alpha-1)*(vf::pow(abs(Px()),alpha-2)))
					));*/

    vector_ptrtype F( M_backend->newVector( Xh ) );
    timers["assembly"].first.restart();


    form1( Xh, F, _init=true )  = integrate( elements(mesh), im_norm, f*id(v) );
	// ATTENTION: MESH MIGHT HAVE NEGATIVE X-COORDINATES (1E-18)
    form1( Xh, F ) += integrate( boundaryfaces(mesh), im, g*( - theta*grad(v)*N() + gamma*id(v)*Order*Order/hFace() ) );
//    form( Xh, F, false ) += integrate( boundaryfaces(mesh), im, -g*trans(N())*(id(phi)) );

    if ( this->vm().count( "export-matlab" ) )
        F->printMatlab( "F.m" );
    timers["assembly"].second = timers["assembly"].first.elapsed();

    /*
     * Construction of the left hand side
     */
    sparse_matrix_ptrtype D( M_backend->newMatrix( Xh, Xh ) );

    timers["assembly"].first.restart();
    size_type pattern = (DOF_PATTERN_COUPLED|DOF_PATTERN_NEIGHBOR );
    form2( Xh, Xh, D, _init=true, _pattern=pattern ) = integrate( elements(mesh), im, ( diff*gradt(u)*trans(grad(v)))
                                                                  +trans(idt(tau))*id(phi)
                                                                  +0.*idt(u)*div(phi)
                                                                  +0.*divt(tau)*id(v)
                                                                  );
	// -----------------------------------------
	// TODO: Write correct lifting stabilization
	// -----------------------------------------
    form2( Xh, Xh, D ) +=integrate( internalfaces(mesh), im,
                                              // - {grad(u)} . [v]
                                              - averaget(gradt(u))*jump(id(v))
                                              // - theta*[u] . {grad(v)}
                                              - theta * average(grad(v))*jumpt(idt(u))
                                              // gamma*[u] . [v]*p/h_face
                                              + gamma * (trans(jumpt(idt(u)))*jump(id(v)) )*Order*Order/hFace()
                                              // delta*{tau} . [v]
                                              + delta * (trans(averaget(idt(tau)))*jump(id(v)) )
                                              // - [u] . {phi}
                                              - trans(jumpt(idt(u)))*average(id(phi))
                                              );
    form2( Xh, Xh, D ) += integrate( boundaryfaces(mesh), im,
                                              - trans(id(v))*(gradt(u)*N())
                                              - theta * trans(idt(u))*(grad(v)*N())
                                              + gamma * (trans(idt(u))*id(v))*Order*Order/hFace()
											  + delta * (trans(idt(tau))*id(v)*N() )
											  - trans(idt(u)*N())*id(phi)
											  );

    D->close();
    timers["assembly"].second += timers["assembly"].first.elapsed();
    if ( this->vm().count( "export-matlab" ) )
        D->printMatlab( "D" );

    this->solve( D, U, F, false );

    ptrtype_cont Xch = type_cont::New( mesh );
    element_type_cont uEx( Xch, "uEx" );

    sparse_matrix_ptrtype M( M_backend->newMatrix( Xch, Xch ) );
    form2( Xch, Xch, M, _init=true ) = integrate( elements( mesh ), im, trans(idt(uEx))*id(uEx) );
    M->close();
    vector_ptrtype L( M_backend->newVector( Xch ) );
    form1( Xch, L ) = integrate( elements( mesh ), im_norm, trans(g)*id(uEx) );
    this->solve( M, uEx, L, true );

//    std::cout << "||error||_0 = " << math::sqrt(integrate( elements(mesh), im, val( trans(idv(u)-g)*(idv(u)-g) ) ).evaluate()(0,0)) << "\n";
//    std::cout << "||error||_0 = " << math::sqrt(integrate( elements(mesh), im, trans(idv(u)-idv(uEx))*(idv(u)-idv(uEx)) ).evaluate()(0,0)) << "\n";

	// Norm computations
	value_type n1 = integrate( elements(mesh), im_norm, val( (gradv(u)-trans(grad_g))*(trans(gradv(u))-grad_g) ) ).evaluate()(0,0);
	value_type n2 = delta*integrate( elements(mesh), im_norm, val( trans(idv(tau))*idv(tau) ) ).evaluate()(0,0);
	value_type n3 = gamma*Order*Order*integrate( internalfaces(mesh), im_norm,  (trans(jumpv(idv(u)))*jumpv(idv(u)))/hFace()  ).evaluate()(0,0);
	value_type n4 = gamma*Order*Order*integrate( boundaryfaces(mesh), im_norm,  (trans(idv(u)-g)*(idv(u)-g))/hFace()  ).evaluate()(0,0);
	value_type n5 = integrate( elements(mesh), im_norm, val( (idv(u)-g)^2 ) ).evaluate()(0,0);


// 	n1 = integrate( elements(mesh), im, val( (gradv(u)-trans(grad_g))*(trans(gradv(u))-grad_g) ) ).evaluate()(0,0);
// 	n2 = delta*integrate( elements(mesh), im, val( trans(idv(tau))*idv(tau) ) ).evaluate()(0,0);
// 	n3 = gamma*/hsize*integrate( internalfaces(mesh), im, (trans(jumpv(idv(u)))*jumpv(idv(u))) ).evaluate()(0,0);
// 	n4 = gamma*Order/hsize*integrate( boundaryfaces(mesh), im, (trans(idv(u))*idv(u)) ).evaluate()(0,0);

	std::cout << "||dg-error||_dg = " << math::sqrt(n1+n2+n3+n4) << "\n";
    std::cout << "||u-error||_0 = " << math::sqrt(n5) << "\n";
	std::cout << "||u-error||_1 = " << math::sqrt(n1) << "\n";
	std::cout << "||tau-error||_0 = " << math::sqrt(n2) << "\n";
	std::cout << "||jump-error||_0 = " << math::sqrt(n3+n4) << "\n";

	this->writeResults(math::sqrt(n1+n2+n3+n4), math::sqrt(n5), math::sqrt(n1), math::sqrt(n2), math::sqrt(n3+n4), theta, delta, gamma );

    form1( Xch, L, _init=true ) = integrate( elements( mesh ), im, trans(idv(u))*id(uEx) );
    element_type_cont uc( Xch, "uc" );
    this->solve( M, uc, L, true );

    this->exportResults( u, uc, uEx );

    std::cout << "[timer] run(): init (" << mesh->numElements() << " Elems): " << timers["init"].second << "\n";
//    std::cout << "[timer] run(): assembly (" << Xh->dof()->nDofs() << " DOFs): " << timers["assembly"].second << "\n";

} // Laplacian::run

template<int Dim, int Order, template<uint16_type,uint16_type,uint16_type> class Entity>
template<typename Mat, typename Vec1, typename Vec2>
void
Laplacian<Dim, Order, Entity>::solve( Mat const& D,
                                                   Vec1& u,
                                                   Vec2 const& F,
                                                   bool is_sym  )
{
    timers["solver"].first.restart();


    backend_ptrtype b( backend_type::build( this->vm() ) );
    vector_ptrtype U( b->newVector( u.functionSpace() ) );
    Log() << "[solve] D sizes: " << D->size1() << ", " << D->size2() << "\n";
    Log() << "[solve] u  size: " << u.size() << "\n";
    Log() << "[solve] U  size: " << U->size() << "\n";
    Log() << "[solve] F  size: " << F->size() << "\n";
    //backend.set_symmetric( is_sym );

    b->solve( D, D, U, F );
    u = *U;

    timers["solver"].second = timers["solver"].first.elapsed();
    Log() << "[timer] solve: " << timers["solver"].second << "\n";
} // Laplacian::solve


template<int Dim, int Order, template<uint16_type,uint16_type,uint16_type> class Entity>
template<typename f1_type, typename f2_type, typename f3_type>
void
Laplacian<Dim, Order, Entity>::exportResults( f1_type& U,
                                                          f2_type& V,
                                                          f3_type& E )
{
    timers["export"].first.restart();

    typename timeset_type::step_ptrtype timeStep = timeSet->step( 1.0 );
    timeStep->setMesh( U.functionSpace()->mesh() );
    timeStep->add( "u", U );
    timeStep->add( "v", V );
    timeStep->add( "e", E );
    exporter->save();


    if ( Dim == 1 )
        {
            std::ostringstream fname_u;
            fname_u << "u.dat";
            std::ofstream ofs3( fname_u.str().c_str() );
            typename mesh_type::element_iterator it = U.functionSpace()->mesh()->beginElement();
            typename mesh_type::element_iterator en = U.functionSpace()->mesh()->endElement();
            for( ; it!=en; ++it )
                {
                    for( size_type i = 0; i < U.nLocalDof(); ++i )
                        {
                            size_type dof0 = boost::get<0>( U.functionSpace()->dof()->localToGlobal( it->id(), i ) );
                            ofs3 << std::setw( 5 ) << it->id() << " "
                                 << std::setw( 5 ) << i << " "
                                 << std::setw( 5 ) << dof0 << " "
                                 << std::setw( 15 ) << U( dof0 ) << " ";
                            value_type a = it->point(0).node()[0];
                            value_type b = it->point(1).node()[0];
                            if ( i == 0 )
                                ofs3 << a;
                            else if ( i == 1 )
                                ofs3 <<  b;
                            else
                                ofs3 <<  a + (i-1)*(b-a)/(V.nLocalDof()-1);

                            ofs3 << "\n";

                        }
                }
            ofs3.close();

            std::ostringstream fname_v;
            fname_v << "values.dat";
            std::ofstream ofs2( fname_v.str().c_str() );
            it = V.functionSpace()->mesh()->beginElement();
            en = V.functionSpace()->mesh()->endElement();
            for( ; it!=en; ++it )
                {
                    for( size_type i = 0; i < V.nLocalDof(); ++i )
                        {
                            size_type dof0 = boost::get<0>( V.functionSpace()->dof()->localToGlobal( it->id(), i ) );
                            ofs2 << std::setw( 5 ) << it->id() << " "
                                 << std::setw( 5 ) << i << " "
                                 << std::setw( 5 ) << dof0 << " "
                                 << std::setw( 15 ) << V( dof0 ) << " "
                                 << std::setw( 15 ) << E( dof0 ) << " ";
                            value_type a = it->point(0).node()[0];
                            value_type b = it->point(1).node()[0];
                            if ( i == 0 )
                                ofs2 << a;
                            else if ( i == 1 )
                                ofs2 <<  b;
                            else
                                ofs2 <<  a + (i-1)*(b-a)/(V.nLocalDof()-1);
                            ofs2 << "\n";

                        }
                }

        }

    timers["export"].second = timers["export"].first.elapsed();
    Log() << "[timer] exportResults(): " << timers["export"].second << "\n";
} // Laplacian::export

template<int Dim, int Order, template<uint16_type,uint16_type,uint16_type> class Entity>
//template<typename f1_type, typename f2_type, typename f3_type>
void
Laplacian<Dim, Order, Entity>::writeResults( value_type e1,
                                             value_type e2,
                                             value_type e3,
                                             value_type e4,
                                             value_type e5,
										     value_type& theta,
										     value_type& delta,
										     value_type& gamma
										   )
{
    timers["write"].first.restart();

//     typename timeset_type::step_ptrtype timeStep = timeSet->step( 1.0 );
//     timeStep->setMesh( U.functionSpace()->mesh() );
//     timeStep->add( "u", U );
//     timeStep->add( "v", V );
//     timeStep->add( "e", E );
//     exporter->save();


	std::ostringstream fname_errors;
	fname_errors << "errors_" << theta << "_" << delta << "_" << gamma << "_" << ".dat";
	std::ofstream ofs( fname_errors.str().c_str() );

	int wspace=15;
	ofs << std::setw( wspace ) << "theta" << " "
		<< std::setw( wspace ) << "delta" << " "
		<< std::setw( wspace ) << "gamma" << " \n";
	ofs << std::setw( wspace ) << theta << " "
		<< std::setw( wspace ) << delta << " "
		<< std::setw( wspace ) << gamma << " \n\n";
	ofs << std::setw( wspace ) << "||u||_DG" << " "
		<< std::setw( wspace ) << "||u||_0" << " "
		<< std::setw( wspace ) << "||u||_1" << " "
		<< std::setw( wspace ) << "||L(u)||_0" << " "
		<< std::setw( wspace ) << "||[u]||_0" << " \n";
	ofs << std::setw( wspace ) << e1 << " "
		<< std::setw( wspace ) << e2 << " "
		<< std::setw( wspace ) << e3 << " "
		<< std::setw( wspace ) << e4 << " "
		<< std::setw( wspace ) << e5 << " ";
	ofs << "\n\n";
	ofs << e1 << " "
		<< e2 << " "
		<< e3 << " "
		<< e4 << " "
		<< e5 << " ";
	ofs << "\n";
	ofs.close();

    timers["write"].second = timers["write"].first.elapsed();
    Log() << "[timer] writeResults(): " << timers["write"].second << "\n";
} // Laplacian::writeResults

} // Life




int
main( int argc, char** argv )
{
    using namespace Life;

    /* change parameters below */
    const int nDim = 2;
    const int nOrder = 1;

    //typedef Continuous MyContinuity;  no continuous version
    typedef Discontinuous MyContinuity;
    typedef Life::Laplacian<nDim, nOrder, SimplexProduct> laplacian_type;
    //typedef Life::Laplacian<nDim, nOrder, MyContinuity, Simplex, Scalar> laplacian_type;

    /* assertions handling */
    Life::Assert::setLog( "laplacian.assert");

    /* define and run application */
    laplacian_type laplacian( argc, argv, makeAbout(), makeOptions() );

	int example = laplacian.vm()["example"].as<int>();

	if( example==2 ) {
		laplacian.changeRepository( boost::format( "%1%/Ex%2%/alpha_%3%/%4%/P%5%/%6%/" )
									% laplacian.about().appName()
									% laplacian.vm()["example"].as<int>()
									% laplacian.vm()["alpha"].as<double>()
									% laplacian_type::entity_type::name()
									% nOrder
									% laplacian.vm()["hsize"].as<double>()
									);
	} else {
		laplacian.changeRepository( boost::format( "%1%/Ex%2%/%3%/P%4%/%5%/" )
									% laplacian.about().appName()
									% laplacian.vm()["example"].as<int>()
									% laplacian_type::entity_type::name()
									% nOrder
									% laplacian.vm()["hsize"].as<double>()
									);
	}
    laplacian.run();
}




